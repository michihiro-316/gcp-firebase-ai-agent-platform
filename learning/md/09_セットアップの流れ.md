# セットアップの流れ - 完全解説

**想定読者**: GASを少し触ったことがある新卒エンジニア
**読了時間**: 約2時間（実作業含む）

**このドキュメントの目的**：
「ゼロからシステムを動かす」までの全手順を、**なぜその設定が必要か**を理解しながら進める。

---

## まず知っておくべきこと

### GAS経験者向け: 環境構築の違い

```
【GASの場合】
Googleドライブ → 新規作成 → Google Apps Script
→ すぐコードが書ける！（環境構築不要）

【本番システムの場合】
GCPプロジェクト作成 → Firebase設定 → サービスアカウント作成 → ...
→ 手順が多い（でも一度やれば終わり！）
```

**なぜこんなに手順が多い？**

| GAS | 本番システム |
|-----|-------------|
| Googleが全部管理 | 自分で管理（自由度が高い） |
| 1人で使う前提 | 複数ユーザー・複数会社で使う前提 |
| セキュリティはGoogle任せ | セキュリティを自分で設定 |
| 無料の範囲で使う | 使った分だけ課金（スケール可能） |

**大事なこと**: 手順は多いですが、一つ一つは簡単です。焦らず進めましょう！

---

## 全体の流れ

```
【事前準備】
  1. GCPプロジェクト作成
  2. Firebase設定
  3. サービスアカウント作成
     ↓
【環境変数設定】
  4. backend/.env 作成
  5. frontend/.env 作成
     ↓
【依存関係インストール】
  6. pip install（バックエンド）
  7. npm install（フロントエンド）
     ↓
【初期データ設定】
  8. 顧客を追加
  9. ユーザーを顧客に紐付け
     ↓
【起動】
  10. バックエンド起動
  11. フロントエンド起動
     ↓
【動作確認】
  12. ログインしてチャット
```

---

## ステップ1: GCPプロジェクト作成

### 1.1 Google Cloud Console を開く

1. https://console.cloud.google.com/ にアクセス
2. 右上のGoogleアカウントでログイン

### 1.2 新しいプロジェクトを作成

1. 左上の「プロジェクトを選択」をクリック
2. 「新しいプロジェクト」をクリック
3. プロジェクト名を入力（例: `my-ai-agent`）
4. 「作成」をクリック

```
【なぜプロジェクトが必要？】
GCPのすべてのリソース（データベース、AI、認証など）は
プロジェクト単位で管理される。
請求もプロジェクト単位で行われる。
```

### 1.3 必要なAPIを有効化

左メニュー → 「APIとサービス」 → 「ライブラリ」

以下を検索して「有効にする」:
- **Vertex AI API** - AIモデルを使うため
- **Cloud Firestore API** - データベースを使うため
- **Identity and Access Management (IAM) API** - 権限管理のため

---

## ステップ2: Firebase設定

### 2.1 Firebase Console を開く

1. https://console.firebase.google.com/ にアクセス
2. 「プロジェクトを追加」をクリック
3. **既存のGCPプロジェクトを選択**（さっき作ったもの）
4. 「続行」を数回クリック

```
【なぜFirebase？】
Firebase は GCP の上に作られた「使いやすい層」。
認証（ログイン機能）が特に簡単に作れる。
```

### 2.2 Authentication を設定

1. 左メニュー → 「Authentication」
2. 「始める」をクリック
3. 「Sign-in method」タブ
4. 「Google」を選択 → 「有効にする」
5. サポートメール（自分のメール）を入力
6. 「保存」

### 2.3 Firestore を設定

1. 左メニュー → 「Firestore Database」
2. 「データベースを作成」をクリック
3. 「本番モードで開始」を選択
4. ロケーション: `asia-northeast1`（東京）を選択
5. 「有効にする」

### 2.4 Firestore セキュリティルールを設定

```
【なぜセキュリティルールが必要？】

GASの場合:
  スプレッドシートの共有設定 → 「リンクを知っている人全員」など

Firestoreの場合:
  セキュリティルール → 「誰が、どのデータに、何ができるか」を細かく設定

ルールがないと、誰でもデータを読み書きできてしまう！
```

#### 設定手順

1. Firebase Console → Firestore Database
2. 「ルール」タブをクリック
3. 以下のルールをコピー＆ペースト:

```javascript
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // 基本: 全て拒否（明示的に許可したものだけアクセス可能）
    match /{document=**} {
      allow read, write: if false;
    }

    // 顧客データ: サーバー（Admin SDK）からのみアクセス可能
    // ※ブラウザから直接アクセスはできない
    match /customers/{customerId}/{document=**} {
      // Admin SDKはこのルールをバイパスするので、
      // ここに書いても意味はないが、意図を明示
      allow read, write: if false;
    }

    // アクセス制御設定: サーバーからのみ
    match /config/{document=**} {
      allow read, write: if false;
    }
  }
}
```

4. 「公開」をクリック

#### ルールの解説

```
【このルールの意味】

match /{document=**} {
  allow read, write: if false;
}
↓
「すべてのドキュメントに対して、読み書きを禁止」

でも、サーバー（Admin SDK）はこのルールを無視できる。
→ サーバー経由でのみデータにアクセスできる
→ ブラウザから直接Firestoreを触れない（セキュア！）
```

```
【GASで例えると】

セキュリティルール = スプレッドシートの保護

「シートを保護」→「自分だけ編集可能」に設定
→ 他の人はGASスクリプト経由でしか編集できない

Firestoreも同じ考え方！
```

#### よくある間違い

```
❌ 開発中だからルールを緩くする
   allow read, write: if true;  // 危険！誰でもアクセス可能

⭕ 開発中でも本番と同じルールを使う
   → サーバー経由でアクセスする設計にする
```

### 2.5 Webアプリを登録

1. プロジェクト設定（歯車アイコン）→ 「全般」
2. 下の方の「アプリを追加」→ Web（</>アイコン）
3. アプリのニックネーム: `frontend`
4. 「アプリを登録」

表示された設定をメモ:
```javascript
const firebaseConfig = {
  apiKey: "AIzaSy...",              // ← これをメモ
  authDomain: "xxx.firebaseapp.com", // ← これをメモ
  projectId: "your-project-id",      // ← これをメモ
};
```

---

## ステップ3: サービスアカウント作成

### 3.1 サービスアカウントとは？

```
【人間のアカウント】
  Googleアカウント（〇〇@gmail.com）
  → 人間がブラウザでログインする用

【サービスアカウント】
  xxx@project.iam.gserviceaccount.com
  → プログラム（バックエンド）がGCPにアクセスする用
```

### 3.2 サービスアカウントを作成

1. Google Cloud Console を開く
2. 左メニュー → 「IAMと管理」 → 「サービスアカウント」
3. 「サービスアカウントを作成」

設定:
- 名前: `backend-service`
- ID: `backend-service`（自動入力）
- 「作成して続行」

### 3.3 ロール（権限）を付与

以下のロールを追加:
- **Firebase Admin SDK 管理者サービス エージェント** - 認証用
- **Cloud Datastore ユーザー** - Firestore用
- **Vertex AI ユーザー** - AI用

「続行」→「完了」

### 3.4 鍵をダウンロード

1. 作成したサービスアカウントをクリック
2. 「鍵」タブ
3. 「鍵を追加」→「新しい鍵を作成」
4. 「JSON」を選択 →「作成」

JSONファイルがダウンロードされる。

### 3.5 鍵ファイルを配置

ダウンロードしたJSONファイルを:
```
backend/service-account.json
```
に配置（リネーム）。

```
【重要】
このファイルは絶対にGitにコミットしないこと！
.gitignore に入れておく（デフォルトで入っている）
```

---

## ステップ4: バックエンド環境変数設定

### 場所: `backend/.env`

```bash
# backend/.env

# ===== GCP設定 =====
# GCPプロジェクトID（Firebase Consoleで確認）
GOOGLE_CLOUD_PROJECT=your-project-id

# サービスアカウントの鍵ファイルパス
GOOGLE_APPLICATION_CREDENTIALS=./service-account.json

# ===== CORS設定 =====
# フロントエンドのURL（ローカル開発時）
ALLOWED_ORIGINS=http://localhost:5173

# ===== Vertex AI設定 =====
# AIモデルのリージョン
VERTEX_AI_LOCATION=asia-northeast1

# ===== レート制限 =====
# 1分あたりの最大リクエスト数
RATE_LIMIT_REQUESTS=60
# レート制限のウィンドウ（秒）
RATE_LIMIT_WINDOW=60
```

### 各設定の意味

| 設定 | 意味 | 間違えると |
|------|------|-----------|
| `GOOGLE_CLOUD_PROJECT` | どのGCPプロジェクトを使うか | Firestoreにアクセスできない |
| `GOOGLE_APPLICATION_CREDENTIALS` | 認証情報ファイルの場所 | 「認証エラー」が出る |
| `ALLOWED_ORIGINS` | どのURLからのアクセスを許可するか | 「CORSエラー」が出る |
| `VERTEX_AI_LOCATION` | AIモデルのリージョン | 「リージョンエラー」が出る |

---

## ステップ5: フロントエンド環境変数設定

### 場所: `frontend/.env`

```bash
# frontend/.env

# ===== Firebase設定 =====
# Firebase Console → プロジェクト設定 → Webアプリ から取得
VITE_FIREBASE_API_KEY=AIzaSyXXXXXXXXXXXXXXXXXXXX
VITE_FIREBASE_AUTH_DOMAIN=your-project.firebaseapp.com
VITE_FIREBASE_PROJECT_ID=your-project-id

# ===== API設定 =====
# バックエンドのURL（ローカル開発時）
VITE_API_BASE_URL=http://localhost:8080
```

### なぜ VITE_ で始まる？

```
【Viteの仕様】
環境変数のうち、VITE_ で始まるものだけが
ブラウザ側のJavaScriptで使える。

VITE_ で始まらない変数は、セキュリティのため
ブラウザには渡されない。
```

### どこで使われる？

```typescript
// frontend/src/services/firebase.ts

const firebaseConfig = {
  apiKey: import.meta.env.VITE_FIREBASE_API_KEY,        // ← ここ
  authDomain: import.meta.env.VITE_FIREBASE_AUTH_DOMAIN, // ← ここ
  projectId: import.meta.env.VITE_FIREBASE_PROJECT_ID,   // ← ここ
}
```

---

## ステップ6: バックエンド依存関係インストール

### ターミナルで実行

```bash
# プロジェクトのルートにいることを確認
pwd
# /path/to/GCP

# backendフォルダに移動
cd backend

# 仮想環境を作成（推奨）
python -m venv venv

# 仮想環境を有効化
# Mac/Linux:
source venv/bin/activate
# Windows:
# venv\Scripts\activate

# 依存パッケージをインストール
pip install -r requirements.txt
```

### requirements.txt の中身

```text
# Cloud Functions
functions-framework==3.*   # ローカルで Cloud Functions を動かすツール

# Firebase/GCP
firebase-admin==6.*        # Firebase管理（認証、Firestore）
google-cloud-aiplatform==1.*  # Vertex AI
google-cloud-firestore==2.*   # Firestore（直接アクセス用）

# LangChain/LangGraph
langchain==0.3.*           # AIフレームワーク
langchain-google-vertexai==2.*  # LangChain + Vertex AI連携
langgraph==0.2.*           # 状態管理付きAIフレームワーク
langgraph-checkpoint==2.*  # 会話履歴保存

# Web Framework
flask==3.*                 # Webサーバー
flask-cors==4.*            # CORS対応

# Utilities
pydantic==2.*              # データバリデーション
python-dotenv==1.*         # .envファイル読み込み
```

---

## ステップ7: フロントエンド依存関係インストール

### ターミナルで実行

```bash
# frontendフォルダに移動
cd frontend

# 依存パッケージをインストール
npm install
```

### 成功すると

```
added 200 packages in 30s
```

### package.json の中身（一部）

```json
{
  "dependencies": {
    "react": "^18.2.0",        // UIフレームワーク
    "firebase": "^10.7.0"      // Firebase SDK
  },
  "devDependencies": {
    "typescript": "^5.0.0",    // TypeScript
    "vite": "^5.0.0"           // 開発サーバー
  }
}
```

---

## ステップ8: 顧客を追加

### なぜ顧客が必要？

```
【このシステムの構造】
顧客（会社） → ユーザー（社員）
             → データ（会話履歴など）

ユーザーは必ずどこかの顧客に所属する必要がある。
```

### 実行

```bash
# backendフォルダにいることを確認
cd backend

# 顧客を追加
python scripts/manage_customer.py add test-corp "テスト株式会社"
```

### 成功すると

```
=== 顧客を作成 ===

✅ 顧客 'テスト株式会社' (test-corp) を作成しました

次のステップ:
  python scripts/manage_customer.py add-domain test-corp example.com
```

---

## ステップ9: ドメインを登録（自動振り分け）

### 推奨：自動振り分けを使う

```bash
# ドメインを登録（社員全員が自動で振り分けられる）
python scripts/manage_customer.py add-domain test-corp test-corp.co.jp
```

### 成功すると

```
=== ドメインを追加 ===

✅ ドメイン '@test-corp.co.jp' を 'テスト株式会社' に追加しました

→ @test-corp.co.jp のユーザーはログイン時に自動で振り分けられます
```

### 自動振り分けの仕組み

```
【従来の方法】
1. フロントエンドを起動
2. ブラウザでログイン
3. manage_customer.py add-user でユーザーを紐付け
4. ユーザーが再ログイン ← 面倒！

【自動振り分け】
1. manage_customer.py add-domain でドメインを登録
2. ユーザーがログイン
3. 完了！（再ログイン不要）
```

### テスト用に個別メールを登録する場合

Gmailなど会社ドメイン以外でテストする場合は、個別メールを登録します。

```bash
python scripts/manage_customer.py add-email test-corp your-email@gmail.com
```

---

## ステップ10: バックエンド起動

### ターミナル1で実行

```bash
# backendフォルダにいることを確認
cd backend

# 仮想環境が有効か確認（プロンプトに(venv)があるか）
# なければ: source venv/bin/activate

# サーバーを起動
functions-framework --target=main --port=8080
```

### 成功すると

```
 * Serving Flask app 'main'
 * Running on http://127.0.0.1:8080
```

### このコマンドの意味

```bash
functions-framework    # Cloud Functions をローカルで動かすツール
--target=main          # main.py の main 関数を起動
--port=8080            # ポート8080で待ち受け
```

---

## ステップ11: フロントエンド起動

### ターミナル2（別のターミナル）で実行

```bash
# frontendフォルダに移動
cd frontend

# 開発サーバーを起動
npm run dev
```

### 成功すると

```
  VITE v5.x.x  ready in 500ms

  ➜  Local:   http://localhost:5173/
  ➜  Network: use --host to expose
```

### このコマンドの意味

```bash
npm run dev
# ↓ package.json の scripts.dev を実行
# ↓ "dev": "vite"
# ↓ Vite開発サーバーを起動
```

---

## ステップ12: 動作確認

### 12.1 ブラウザでアクセス

http://localhost:5173/ を開く

### 12.2 ログイン

1. 「Googleでログイン」をクリック
2. Googleアカウントを選択
3. **自動振り分けが設定されていれば、そのままチャット画面へ**

### 12.3 エラーが出た場合

「顧客に紐付けされていません」と表示された場合：

```bash
cd backend

# 方法1: メールを個別登録（推奨）
python scripts/manage_customer.py add-email test-corp your-email@gmail.com

# 方法2: 手動紐付け（ログイン後のみ使用可能）
python scripts/manage_customer.py add-user test-corp your-email@gmail.com
# → この場合は再ログインが必要
```

### 12.4 チャット

1. 「こんにちは」と入力
2. 送信
3. AIが返答する！

---

## よくあるエラーと対処法

### エラー1: 「Module not found」

```
原因: 依存パッケージがインストールされていない
対処: pip install -r requirements.txt を再実行
```

### エラー2: 「CORS エラー」

```
原因: ALLOWED_ORIGINS の設定が違う
対処:
  1. backend/.env を確認
  2. ALLOWED_ORIGINS=http://localhost:5173
     （末尾のスラッシュなし）
  3. バックエンドを再起動
```

### エラー3: 「認証エラー」/ 「トークンの検証に失敗」

```
原因:
  - service-account.json がない
  - 環境変数が設定されていない
  - Firebase Auth が有効になっていない

対処:
  1. backend/service-account.json が存在するか確認
  2. backend/.env の GOOGLE_APPLICATION_CREDENTIALS を確認
  3. Firebase Console で Authentication が有効か確認
```

### エラー4: 「顧客に紐付けされていません」

```
原因: ユーザーが顧客に紐付けされていない（自動振り分けにもマッチしない）
対処:
  方法1（推奨）: メールを個別登録
    python scripts/manage_customer.py add-email test-corp your-email@gmail.com
    → 次回ログイン時に自動で振り分けられる

  方法2: 手動紐付け
    python scripts/manage_customer.py add-user test-corp your-email@gmail.com
    → 再ログインが必要
```

### エラー5: 「Vertex AI API が無効です」

```
原因: APIが有効化されていない
対処:
  1. Google Cloud Console を開く
  2. 「APIとサービス」→「ライブラリ」
  3. 「Vertex AI API」を検索して有効化
```

---

## 設定ファイルの対応関係

```
【フロントエンド】
frontend/.env
  │
  ├── VITE_FIREBASE_API_KEY ────→ firebase.ts で Firebase 初期化
  ├── VITE_FIREBASE_AUTH_DOMAIN ─→ firebase.ts で Firebase 初期化
  ├── VITE_FIREBASE_PROJECT_ID ──→ firebase.ts で Firebase 初期化
  └── VITE_API_BASE_URL ─────────→ api.ts で バックエンド呼び出し


【バックエンド】
backend/.env
  │
  ├── GOOGLE_CLOUD_PROJECT ──────→ firebase_init.py で Firebase 初期化
  ├── GOOGLE_APPLICATION_CREDENTIALS → firebase_init.py で認証
  ├── ALLOWED_ORIGINS ───────────→ cors.py で CORS 設定
  ├── VERTEX_AI_LOCATION ────────→ agent.py で AI モデル呼び出し
  └── RATE_LIMIT_* ──────────────→ rate_limiter.py でレート制限


【サービスアカウント】
backend/service-account.json
  │
  └── バックエンドがGCPにアクセスするための認証情報
      - Firestore へのアクセス
      - Firebase Auth の検証
      - Vertex AI の呼び出し
```

---

## チェックリスト

セットアップが完了したか確認:

- [ ] GCPプロジェクトを作成した
- [ ] Vertex AI API を有効化した
- [ ] Firebase プロジェクトを設定した
- [ ] Authentication で Google を有効化した
- [ ] Firestore データベースを作成した
- [ ] Webアプリを登録してAPIキー等を取得した
- [ ] サービスアカウントを作成した
- [ ] 鍵をダウンロードして backend/service-account.json に配置した
- [ ] backend/.env を作成した
- [ ] frontend/.env を作成した
- [ ] `pip install -r requirements.txt` を実行した
- [ ] `npm install` を実行した
- [ ] 顧客を追加した
- [ ] ドメインまたはメールを登録した（自動振り分け）
- [ ] バックエンドが起動している
- [ ] フロントエンドが起動している
- [ ] チャットができた！

---

## 本番環境へのデプロイ（発展編）

ローカル開発が完了したら、インターネットに公開して実際に使えるようにします。

```
【ローカル開発 vs 本番環境】

ローカル開発:
  http://localhost:5173 → 自分のPCでしか見れない

本番環境:
  https://your-app.web.app → 誰でもアクセスできる
```

### デプロイの全体像

```
【デプロイ先】

フロントエンド → Firebase Hosting
  - 静的ファイル（HTML/CSS/JS）をホスティング
  - 無料枠あり

バックエンド → Cloud Run Functions
  - Pythonサーバーを動かす
  - リクエストがある時だけ課金（コスト効率◎）
```

### ステップ1: Firebase CLI のインストール

```bash
# Node.jsがインストールされていることを確認
node -v

# Firebase CLI をインストール
npm install -g firebase-tools

# Firebaseにログイン
firebase login
```

### ステップ2: フロントエンドをビルド

```bash
cd frontend

# 本番用にビルド
npm run build

# distフォルダにファイルが生成される
ls dist/
# index.html  assets/  ...
```

**ビルドとは？**

```
【GASとの違い】

GASの場合:
  保存 → 即座に反映
  （Googleが裏でいろいろやってくれる）

React/Viteの場合:
  開発時: npm run dev（開発サーバー）
  本番時: npm run build → distフォルダ生成 → デプロイ
  （自分でビルドして、結果をアップロード）
```

### ステップ3: フロントエンドをデプロイ

```bash
# frontendフォルダで実行
firebase deploy --only hosting
```

成功すると:
```
✔  Deploy complete!

Hosting URL: https://your-project.web.app
```

### ステップ4: バックエンドをデプロイ

```bash
cd backend

# Cloud Run Functionsにデプロイ
gcloud functions deploy main \
  --gen2 \
  --runtime=python311 \
  --region=asia-northeast1 \
  --source=. \
  --entry-point=main \
  --trigger-http \
  --allow-unauthenticated
```

**各オプションの意味:**

| オプション | 意味 |
|-----------|------|
| `--gen2` | 第2世代のCloud Functions（推奨） |
| `--runtime=python311` | Python 3.11を使用 |
| `--region=asia-northeast1` | 東京リージョン |
| `--trigger-http` | HTTPリクエストで起動 |
| `--allow-unauthenticated` | 誰でもアクセス可能（認証はアプリ側で行う） |

### ステップ5: 環境変数の更新

#### frontend/.env（本番用）

```bash
# バックエンドのURLを本番のものに変更
VITE_API_BASE_URL=https://main-xxxxx-an.a.run.app
```

#### backend/.env（本番用）

```bash
# フロントエンドのURLを本番のものに変更
ALLOWED_ORIGINS=https://your-project.web.app
```

**重要**: 環境変数を変更したら、再ビルド＆再デプロイが必要！

### ステップ6: 動作確認

1. `https://your-project.web.app` にアクセス
2. Googleログイン
3. チャットが動作することを確認

---

## 本番環境のセキュリティチェックリスト

本番環境にデプロイする前に、以下を確認しましょう。

### 必須チェック項目

- [ ] **Firestoreセキュリティルール**が設定されている
- [ ] **service-account.json**がGitにコミットされていない
- [ ] **.env**ファイルがGitにコミットされていない
- [ ] **ALLOWED_ORIGINS**が本番URLのみになっている
- [ ] Firebase Authenticationの**承認済みドメイン**に本番URLが追加されている

### Firebase 承認済みドメインの設定

1. Firebase Console → Authentication
2. 「Settings」タブ → 「承認済みドメイン」
3. 本番のドメイン（`your-project.web.app`）を追加

```
【なぜ必要？】

承認済みドメインに登録されていないと、
そのドメインからのログインができない。

ローカル開発時の localhost は最初から登録されている。
```

### シークレット管理（推奨）

本番環境では、環境変数を**Secret Manager**で管理することを推奨します。

```
【.envファイルの問題点】

- サーバーにファイルが残る
- 複数人での管理が難しい
- バージョン管理ができない

【Secret Managerのメリット】

- GCPが安全に保管
- アクセス権限を細かく設定
- 変更履歴が残る
```

Secret Managerの設定方法は、公式ドキュメントを参照してください。
https://cloud.google.com/secret-manager/docs

---

## 確認クイズ

<details>
<summary>Q1: Firestoreセキュリティルールで `allow read, write: if false;` と書くと、サーバーからもアクセスできなくなる？</summary>

**A: いいえ**

Admin SDK（サーバー側）はセキュリティルールをバイパスします。
このルールはブラウザからの直接アクセスのみをブロックします。
</details>

<details>
<summary>Q2: 本番デプロイ後に環境変数を変更したら、どうする必要がある？</summary>

**A: 再ビルド＆再デプロイが必要**

特にフロントエンドは、ビルド時に環境変数が埋め込まれるため、
`.env`を変更したら `npm run build` → `firebase deploy` が必要です。
</details>

<details>
<summary>Q3: service-account.json を誤ってGitにコミットしてしまったら？</summary>

**A: 即座に鍵を無効化する**

1. GCP Console → IAMと管理 → サービスアカウント
2. 該当のサービスアカウントを選択
3. 「鍵」タブ → 漏洩した鍵を削除
4. 新しい鍵を作成
5. Gitの履歴からもファイルを削除（git filter-branch等）

**重要**: コミット履歴に残っている限り、鍵は漏洩状態です！
</details>

---

## 次に読むべきドキュメント

- `FLOW_01_チャット送信の流れ.md` - チャット処理の詳細
- `FLOW_02_ログインの流れ.md` - ログイン処理の詳細
- `05_顧客管理の仕組み.md` - マルチテナントの仕組み
