# 顧客管理の仕組み

複数の顧客（会社）にサービスを提供する仕組みを解説します。

---

## 顧客とユーザーの違い

```
顧客（Customer）= 会社
  ├── ユーザーA（山田さん）
  ├── ユーザーB（田中さん）
  └── ユーザーC（佐藤さん）
```

| 概念 | 例 | 説明 |
|------|-----|------|
| 顧客 | 株式会社ACME | サービスを契約している会社 |
| ユーザー | yamada@acme.co.jp | 実際に使う人 |
| 顧客ID | acme-corp | システム上の識別子 |

---

## データの分離

### なぜ分離が必要？

```
A社の社員がB社のデータを見れたら大問題！
→ 顧客ごとにデータを完全に分離する必要がある
```

### どうやって分離している？

Firestoreの階層構造で分離:

```
customers/
├── acme-corp/                 ← A社のデータ
│   ├── name: "株式会社ACME"
│   └── checkpoints/
│       ├── user1_abc123/      ← A社ユーザーの会話
│       └── user2_def456/
│
├── beta-inc/                  ← B社のデータ
│   ├── name: "ベータ株式会社"
│   └── checkpoints/
│       └── user3_ghi789/      ← B社ユーザーの会話
```

A社のユーザーは `customers/acme-corp/` 以下にしかアクセスできない。

---

## Custom Claims とは？

Firebase Authの「カスタム属性」機能。

### イメージ

```
【普通のログイン情報】
- uid: "abc123"
- email: "yamada@acme.co.jp"
- displayName: "山田太郎"

【Custom Claims を追加】
- uid: "abc123"
- email: "yamada@acme.co.jp"
- displayName: "山田太郎"
- customer_id: "acme-corp"  ← これ！
```

### なぜ Custom Claims を使う？

1. IDトークンに含まれる → API呼び出しのたびに取得不要
2. Firebase が管理 → 安全
3. サーバー側でしか設定できない → ユーザーが改ざんできない

---

## 顧客管理の操作

### 管理スクリプト

```bash
cd backend

# 顧客一覧を見る
python scripts/manage_customer.py list

# 新しい顧客を追加
python scripts/manage_customer.py add test-corp "株式会社テスト"

# ユーザーを顧客に紐付け
python scripts/manage_customer.py add-user test-corp yamada@test.co.jp

# 顧客の詳細を見る
python scripts/manage_customer.py show test-corp

# ユーザーの詳細を見る
python scripts/manage_customer.py show-user yamada@test.co.jp
```

### 紐付けの流れ

```
1. 顧客を作成
   python scripts/manage_customer.py add acme-corp "株式会社ACME"

   Firestore:
   └── customers/acme-corp/
       └── name: "株式会社ACME"

2. ユーザーがGoogleログイン
   （まだ customer_id は未設定）

3. ユーザーを顧客に紐付け
   python scripts/manage_customer.py add-user acme-corp yamada@acme.co.jp

   - Firebase Auth の Custom Claims に customer_id を設定
   - Firestore にもバックアップを保存

4. ユーザーが再ログイン
   （新しいIDトークンに customer_id が含まれる）

5. APIを呼び出すと...
   - バックエンドが customer_id を取得
   - 対応する顧客のデータにアクセス
```

---

## コードの解説

### auth.py

```python
def get_user_customer_id(uid: str) -> str:
    """
    Custom Claims から customer_id を取得
    """
    user = auth.get_user(uid)           # Firebase Auth からユーザー情報を取得
    claims = user.custom_claims or {}    # Custom Claims を取得
    return claims.get("customer_id", "default")  # customer_id を返す
```

### firestore_checkpointer.py

```python
def _get_checkpoint_ref(self, thread_id: str):
    """
    顧客別のパスを生成
    """
    return (
        self.db.collection("customers")
        .document(self.customer_id)      # ← 顧客ID
        .collection("checkpoints")
        .document(thread_id)
        .collection("checkpoints")
    )
    # → customers/{customer_id}/checkpoints/{thread_id}/checkpoints/
```

---

## 注意事項

### 1. 再ログインが必要

Custom Claims を設定した後、ユーザーは再ログインが必要。
IDトークンは発行時の情報を持っているため。

### 2. 1ユーザー = 1顧客

現在の設計では、1人のユーザーは1つの顧客にしか所属できない。
複数顧客に所属させたい場合は設計変更が必要。

### 3. デフォルト顧客

customer_id が未設定のユーザーは「default」顧客として扱われる。
本番では default へのアクセスを制限することを推奨。

---

## Firebaseコンソールでの確認

### Custom Claims を確認

Firebase Console → Authentication → Users
→ ユーザーをクリック → カスタム クレーム

### Firestoreのデータを確認

Firebase Console → Firestore Database
→ customers コレクションを展開

---

## まとめ

```
【顧客追加の流れ】

1. manage_customer.py add でFirestoreに顧客を作成

2. ユーザーにGoogleログインしてもらう

3. manage_customer.py add-user で紐付け
   - Custom Claims に customer_id を設定
   - Firestore にバックアップ

4. ユーザーに再ログインしてもらう

5. 完了！ユーザーは顧客別のデータにアクセスできる
```
