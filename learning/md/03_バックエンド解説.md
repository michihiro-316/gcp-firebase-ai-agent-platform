"""
========================================
バックエンド解説（勉強用）
========================================

このファイルは「勉強用」です。
実際のコードは backend/src/ にあります。

【読む順番】
1. main.py の全体構造を理解
2. 認証の流れを理解
3. チャットAPIの流れを理解

========================================
"""


# ========================================
# 1. main.py の構造
# ========================================
"""
main.pyは「入口」です。
すべてのAPIリクエストはここに来ます。

【構造のイメージ】

┌─────────────────────────────────────┐
│            main.py                  │
├─────────────────────────────────────┤
│                                     │
│  /health  → ヘルスチェック           │
│            （サーバーが生きてるか確認）│
│                                     │
│  /chat    → チャットAPI              │
│            （メインの機能）           │
│                                     │
│  /agents  → エージェント一覧          │
│            （使えるAIの一覧）         │
│                                     │
└─────────────────────────────────────┘
"""


# ========================================
# 2. 認証の流れ
# ========================================
"""
認証とは「この人は本物か？」を確認すること。

【なぜ必要？】
- 誰でもAPIを使えたら、悪い人に悪用される
- 顧客ごとにデータを分ける必要がある
- 使いすぎを防ぐ必要がある

【流れ】

1. ユーザーがリクエストを送る
   ↓
   リクエストヘッダーに「IDトークン」が入っている
   （Authorization: Bearer xxxxx）

2. verify_token() でトークンを検証
   ↓
   Firebase Authが「このトークンは本物か」を確認
   偽物なら → エラーを返す

3. is_user_allowed() でアクセス権限を確認
   ↓
   「このメールアドレス/ドメインは許可されているか」
   許可されていない → エラーを返す

4. get_user_customer_id() で顧客IDを取得
   ↓
   【自動振り分け対応】
   - まずCustom Claimsに customer_id があるか確認
   - なければ、メールのドメインから顧客を自動検索
   - 見つかれば自動でCustom Claimsを設定
   これでどの顧客のデータを使うか決まる
"""

# ------ 簡略化したコード例 ------

def authenticate_request_説明版(request):
    """
    リクエストを認証する（説明用の簡略版）
    """
    # ステップ1: ヘッダーからトークンを取り出す
    auth_header = request.headers.get("Authorization", "")
    if not auth_header:
        raise ValueError("トークンがありません")

    # "Bearer xxxxx" という形式かチェック（セキュリティ強化）
    parts = auth_header.split(" ")
    if len(parts) != 2 or parts[0] != "Bearer":
        raise ValueError("認証ヘッダーの形式が不正です")

    id_token = parts[1]
    if not id_token:
        raise ValueError("認証トークンが空です")

    # ステップ2: トークンを検証（Firebase Authが行う）
    # check_revoked=True で無効化されたトークンも拒否
    # → 失敗したらエラー
    user_info = verify_token(id_token, check_revoked=True)

    # ステップ3: このユーザーは許可されている？
    email = user_info.get("email", "")
    if not is_user_allowed(email):
        raise ValueError("このユーザーはアクセスできません")

    # ステップ4: 顧客IDを取得（自動振り分け対応）
    # ・Custom Claimsに既にあればそれを使用
    # ・なければ、メールのドメインから顧客を自動検索
    user_info["customer_id"] = get_user_customer_id(user_info["uid"], email)

    return user_info


# ========================================
# 3. チャットAPIの流れ
# ========================================
"""
/chat エンドポイントの流れ

【リクエスト】
POST /chat
{
    "message": "こんにちは",
    "thread_id": "xxx"  ← 省略可能（省略すると新しい会話）
}

【セキュリティチェック】
- メッセージ長制限: 10,000文字まで（DoS/コスト攻撃対策）
- thread_id形式検証: 英数字、ハイフン、アンダースコアのみ

【流れ】

1. prepare_chat_request() で前準備
   - 認証チェック
   - レート制限チェック（使いすぎ防止）
   - リクエストの中身を確認
   - 入力値検証（メッセージ長、thread_id形式）

2. get_agent() でAIエージェントを取得
   - 顧客ごとに別々のエージェントを使う
   - キャッシュして再利用（毎回作るとコストがかかる）

3. agent.run() でAIに質問
   - ストリーミングで少しずつ返答

4. Server-Sent Events で返す
   - 「data: こん」
   - 「data: にち」
   - 「data: は」
   - 「data: [DONE]」

5. エラー時
   - 詳細はサーバーログに記録
   - クライアントには汎用メッセージを返す（情報漏洩防止）
"""

# ------ 簡略化したコード例 ------

def chat_説明版():
    """
    チャットAPI（説明用の簡略版）
    """
    # ステップ1: 前準備
    agent, message, thread_id, user_id, customer_id = prepare_chat_request()

    # ステップ2: AIに質問してストリーミングで返す
    def generate():
        for chunk in agent.run(message, thread_id):
            # 少しずつ返答を返す
            yield f"data: {chunk}\n\n"

        # 終わりの合図
        yield "data: [DONE]\n\n"

    # Server-Sent Events 形式で返す
    return Response(generate(), mimetype="text/event-stream")


# ========================================
# 4. 重要な概念
# ========================================

# --- async/await とは？ ---
"""
async/await は「非同期処理」のための書き方です。

【なぜ必要？】
AIの返答を待っている間、サーバーが何もできないと困る。
async/await を使うと、待っている間に他の処理ができる。

【イメージ】
普通の処理:
  料理を注文 → 料理ができるまで待つ → 次の客の注文を聞く

非同期処理:
  料理を注文 → （待っている間に）次の客の注文を聞く → 料理ができたら運ぶ
"""

# 非同期関数の例
async def async_example():
    """
    async がついた関数は「非同期関数」
    中で await を使って「待つ」処理を書ける
    """
    # AIの返答を待つ（待っている間、他の処理ができる）
    result = await ai.generate("こんにちは")
    return result


# --- ジェネレーター（yield）とは？ ---
"""
yield は「少しずつ値を返す」ための書き方です。

【なぜ必要？】
AIの返答が長い場合、全部完成するまで待つと遅い。
yield を使うと、できたところから少しずつ返せる。
"""

# ジェネレーターの例
def count_説明():
    """
    yield を使うと、呼び出すたびに次の値を返す
    """
    yield 1  # 1回目の呼び出しで 1 を返す
    yield 2  # 2回目の呼び出しで 2 を返す
    yield 3  # 3回目の呼び出しで 3 を返す

# 使い方
# for num in count_説明():
#     print(num)
# → 1, 2, 3 と表示される


# --- デコレーター（@）とは？ ---
"""
@ から始まる行は「デコレーター」です。
関数に「追加機能」を付けます。

【よく使うデコレーター】

@app.route("/chat", methods=["POST"])
→ この関数は /chat へのPOSTリクエストを処理する

@functions_framework.http
→ この関数はCloud Functionsのエントリーポイント
"""

# デコレーターの例
# @app.route("/health")  ← /health へのリクエストを処理
# def health_check():
#     return {"status": "healthy"}


# ========================================
# 5. 次に読むべきファイル
# ========================================
"""
1. backend/src/main.py
   → 今回説明した内容の本番コード

2. backend/src/common/auth.py
   → 認証処理の詳細（自動振り分け含む）

3. backend/src/agents/_template/agent.py
   → AIエージェントの実装

4. backend/scripts/manage_customer.py
   → 顧客管理コマンド

5. learning/md/04_フロントエンド解説.md
   → 画面側の解説
"""
