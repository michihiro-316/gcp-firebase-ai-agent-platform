<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>04 フロントエンド解説 - GCP AI Agent 設計資料</title>
  <link rel="stylesheet" href="assets/style.css">
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>📚</text></svg>">
</head>
<body>
  <header class="header">
    <a href="index.html" class="header-logo">
      <span>📚</span>
      <span>GCP AI Agent 設計資料</span>
    </a>
    <nav class="header-nav">
      <a href="index.html">ホーム</a>
      <a href="02_全体像.html">全体像</a>
      <a href="https://github.com" target="_blank">GitHub</a>
    </nav>
    <button class="menu-toggle" onclick="toggleSidebar()">
      <span></span>
      <span></span>
      <span></span>
    </button>
  </header>

  <div class="layout">
    <aside class="sidebar" id="sidebar">
      <div class="sidebar-section">
        <div class="sidebar-title">📖 はじめに</div>
        <ul class="sidebar-nav">
          <li><a href="01_はじめに読んでください.html" >はじめに読んでください</a></li>
        </ul>
      </div>

      <div class="sidebar-section">
        <div class="sidebar-title">🏗️ 仕組みを理解</div>
        <ul class="sidebar-nav">
          <li><a href="02_全体像.html" >全体像</a></li>
          <li><a href="03_バックエンド解説.html" >バックエンド解説</a></li>
          <li><a href="04_フロントエンド解説.html" class="active">フロントエンド解説</a></li>
        </ul>
      </div>

      <div class="sidebar-section">
        <div class="sidebar-title">🛠️ セットアップ</div>
        <ul class="sidebar-nav">
          <li><a href="05_セットアップの流れ.html" >セットアップの流れ</a></li>
          <li><a href="06_コマンド解説.html" >コマンド解説</a></li>
        </ul>
      </div>

      <div class="sidebar-section">
        <div class="sidebar-title">🚀 動かす</div>
        <ul class="sidebar-nav">
          <li><a href="07_動かしてみよう.html" >動かしてみよう</a></li>
          <li><a href="08_AIカスタマイズ.html" >AIカスタマイズ</a></li>
        </ul>
      </div>

      <div class="sidebar-section">
        <div class="sidebar-title">🔧 上級編</div>
        <ul class="sidebar-nav">
          <li><a href="10_Gatewayアーキテクチャ.html" >Gatewayアーキテクチャ</a></li>
          <li><a href="14_セキュリティとファイル連携.html" >セキュリティとファイル連携</a></li>
        </ul>
      </div>

      <div class="sidebar-section">
        <div class="sidebar-title">🔄 参考: フロー解説</div>
        <ul class="sidebar-nav">
          <li><a href="11_チャット送信の流れ.html" >チャット送信の流れ</a></li>
          <li><a href="12_ログインの流れ.html" >ログインの流れ</a></li>
          <li><a href="13_セッション管理の流れ.html" >セッション管理の流れ</a></li>
        </ul>
      </div>
    </aside>

    <main class="main">
      <article class="content">
        <h1 id="フロントエンド解説">フロントエンド解説<a class="header-link" href="#フロントエンド解説" title="Permanent link">&para;</a></h1>
<div class="chapter-hero">
<span class="emoji">🎨</span>
<h1>フロントエンド解説</h1>
<p class="subtitle">「え？Reactってレゴブロックみたいなもの？」<br>「そう！画面のパーツを組み合わせて作るんだ！」</p>
</div>

<hr />
<h2 id="この章で学ぶこと">この章で学ぶこと<a class="header-link" href="#この章で学ぶこと" title="Permanent link">&para;</a></h2>
<div class="goal-box">
<h3>📚 学習目標</h3>
<ol>
<li>Reactの基本概念（コンポーネント、JSX）</li>
<li>useState と useEffect の仕組み</li>
<li>カスタムフックの作り方と使い方</li>
<li>認証処理の流れ（useAuth.ts）</li>
<li>チャット処理の流れ（useChat.ts）</li>
<li>セッション管理の仕組み（useSessions.ts）</li>
<li>API通信（api.ts）</li>
<li>TypeScriptの型システム</li>
</ol>
<p><strong>⏱️ 想定学習時間: 45分</strong></p>
</div>

<hr />
<h2 id="使っている技術">使っている技術<a class="header-link" href="#使っている技術" title="Permanent link">&para;</a></h2>
<table>
<thead>
<tr>
<th>技術</th>
<th>役割</th>
<th>なぜ使う？</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>React</strong></td>
<td>UIを作るライブラリ</td>
<td>コンポーネントで画面を組み立てられる</td>
</tr>
<tr>
<td><strong>TypeScript</strong></td>
<td>型のあるJavaScript</td>
<td>間違いを事前に防げる</td>
</tr>
<tr>
<td><strong>Vite</strong></td>
<td>開発サーバー・ビルドツール</td>
<td>超高速！変更が即座に反映</td>
</tr>
<tr>
<td><strong>Firebase SDK</strong></td>
<td>Firebase連携</td>
<td>認証やデータベースを簡単に使える</td>
</tr>
</tbody>
</table>
<hr />
<h2 id="ファイル間の呼び出しの流れ全体像">ファイル間の呼び出しの流れ（全体像）<a class="header-link" href="#ファイル間の呼び出しの流れ全体像" title="Permanent link">&para;</a></h2>
<div class="info-box">
<div class="box-title">🔗 チャット送信時のコード実行順序</div>
<div class="box-content">

<strong>ユーザーがメッセージを送信すると、以下の順番でコードが実行されます:</strong>

<pre>
【フロントエンド（ブラウザで実行）】

main.tsx                           ← アプリ起動（エントリーポイント）
    │
    └──▶ App.tsx                   ← 画面の土台
            │
            ├──▶ useAuth.ts        ← ログイン状態の管理
            │       └──▶ firebase.ts   ← Firebase接続
            │
            ├──▶ useSessions.ts    ← セッション管理（localStorage保存）
            │
            └──▶ useChat.ts        ← チャットロジック
                    │
                    └──▶ api.ts    ← HTTP通信（★ここでバックエンドに接続）
                            │
════════════════════════════╬══════════════════════════════════════════
                            │
                            ▼  fetch('/chat', { Authorization: Bearer xxx })
【バックエンド（サーバーで実行）】

                         main.py   ← リクエスト受信
                            │
                            └──▶ auth.py    ← トークン検証
                                    │
                                    └──▶ agent.py   ← AI処理
                                            │
                                            ▼
                                        Vertex AI (Gemini)
</pre>

</div>
</div>

<div class="tip-box">
<div class="box-title">💡 ポイント</div>
<div class="box-content">

<table>
<tr><th>ファイル</th><th>役割</th><th>直接呼び出すファイル</th></tr>
<tr><td><code>main.tsx</code></td><td>アプリ起動</td><td>App.tsx</td></tr>
<tr><td><code>App.tsx</code></td><td>画面の土台</td><td>useAuth, useChat, useSessions</td></tr>
<tr><td><code>useChat.ts</code></td><td>チャットロジック</td><td>api.ts</td></tr>
<tr><td><code>api.ts</code></td><td>サーバー通信</td><td><strong>バックエンドへ HTTP 通信</strong></td></tr>
</table>

<ul>
<li><strong>App.tsx は api.ts を直接使わない</strong> → useChat 経由で間接的に使用</li>
<li><strong>フロントとバックは別プログラム</strong> → HTTP通信（インターネット経由）で接続</li>
<li><strong>認証トークン</strong> → api.ts で生成し、バックエンドの auth.py で検証</li>
</ul>

</div>
</div>

<hr />
<details>
<summary><strong>🐍 Pythonエンジニア向け: アロー関数の基礎</strong>（クリックで展開）</summary>

Reactのコードには `() => { }` という書き方が頻繁に出てきます。
**最初に理解しておくと、この先がラクになります！**

<div class="info-box">
<h3>📝 アロー関数 = Pythonの lambda（無名関数）の進化版</h3>

<strong>基本構文:</strong>

<pre>
() => { ... }
↑    ↑   ↑
①   ②   ③

① () = 引数（なければ空のカッコ）
② => = 「これが関数ですよ」の印（アロー）
③ { } = 関数の中身
</pre>

<strong>Pythonとの比較:</strong>

<pre><code class="python"># Python の関数定義
def say_hello():
    print("Hello")

# Python の lambda（1行のみ）
say_hello = lambda: print("Hello")
</code></pre>

<pre><code class="javascript">// JavaScript の関数定義（従来）
function sayHello() {
  console.log("Hello");
}

// JavaScript のアロー関数（現代的）
const sayHello = () => {
  console.log("Hello");
};
</code></pre>

<strong>引数がある場合:</strong>

<pre><code class="python"># Python
def add(a, b):
    return a + b

add_lambda = lambda a, b: a + b
</code></pre>

<pre><code class="javascript">// JavaScript（アロー関数）
const add = (a, b) => {
  return a + b;
};

// 1行なら省略可能
const add = (a, b) => a + b;
</code></pre>

</div>

<div class="tip-box">
<h3>💡 よく見るパターン</h3>

<strong>パターン1: イベントハンドラ</strong>
<pre><code class="tsx">&lt;button onClick={() =&gt; { console.log("クリック！"); }}&gt;
  ボタン
&lt;/button&gt;
</code></pre>

<strong>パターン2: 配列の処理</strong>
<pre><code class="javascript">// Python: [x * 2 for x in numbers]
// JavaScript:
numbers.map((x) => x * 2)
</code></pre>

<strong>パターン3: 関数を返す関数</strong>
<pre><code class="javascript">// アロー関数を return で返す
return () => {
  // この中身は「今」実行されない
  // 後で誰かが呼び出すと実行される
};
</code></pre>

<strong>パターン4: 別の関数の引数として渡す（コールバック）</strong>
<pre><code class="javascript">// 関数を引数として渡すパターン
onAuthStateChanged(auth, (user) => {
  setUser(user);
});
</code></pre>
→ <strong>詳しくは「<a href="#6-useauthts---認証フックの完全解説">6. useAuth.ts - 認証フックの完全解説</a>」で図解付きで説明しています！</strong>

</div>

<div class="warning-box">
<h3>⚠️ 超重要: <code>inner</code> と <code>inner()</code> の違い</h3>

<strong>これ、初心者がつまずく最大のポイントです！</strong>

<pre><code class="python">def outer():
    def inner():
        print("後で実行")

    return inner    # ← カッコなし = 関数そのものを返す
    # return inner()  ← カッコあり = 関数を実行して、その結果を返す
</code></pre>

<strong>図で理解:</strong>

<pre>
inner   ← 関数そのもの（まだ実行されていない）
         「後で実行してね」という約束を渡す

inner() ← 関数を実行した結果
         今すぐ「後で実行」と表示される
         返り値は None（print は何も返さないから）
</pre>

<strong>具体例で比較:</strong>


<div class="codehilite"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">outer</span><span class="p">():</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">inner</span><span class="p">():</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;実行された！&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="mi">42</span>

    <span class="k">return</span> <span class="n">inner</span>   <span class="c1"># カッコなし</span>

<span class="c1"># 使う側</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">outer</span><span class="p">()</span>   <span class="c1"># result には inner関数が入る</span>
<span class="nb">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>      <span class="c1"># → &lt;function inner at 0x...&gt;（関数オブジェクト）</span>
<span class="nb">print</span><span class="p">(</span><span class="n">result</span><span class="p">())</span>    <span class="c1"># → 実行された！ → 42（ここで初めて実行）</span>
</code></pre></div>




<div class="codehilite"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">outer</span><span class="p">():</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">inner</span><span class="p">():</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;実行された！&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="mi">42</span>

    <span class="k">return</span> <span class="n">inner</span><span class="p">()</span>  <span class="c1"># カッコあり ← ここで実行されてしまう！</span>

<span class="c1"># 使う側</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">outer</span><span class="p">()</span>   <span class="c1"># → 「実行された！」が表示される</span>
<span class="nb">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>      <span class="c1"># → 42（inner() の戻り値）</span>
</code></pre></div>



<strong>JavaScript でも同じ:</strong>


<div class="codehilite"><pre><span></span><code><span class="c1">// カッコなし = 関数を返す（useEffectではこれが正解）</span>
<span class="k">return</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">clearInterval</span><span class="p">(</span><span class="nx">timer</span><span class="p">);</span><span class="w"> </span><span class="p">}</span>

<span class="c1">// カッコあり = 今すぐ実行して、その結果（undefined）を返す</span>
<span class="k">return</span><span class="w"> </span><span class="p">(()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">clearInterval</span><span class="p">(</span><span class="nx">timer</span><span class="p">);</span><span class="w"> </span><span class="p">})()</span>
<span class="c1">//                                      ↑↑</span>
<span class="c1">//                         この () で即実行してしまう！</span>
</code></pre></div>



<table>
<tr><th>書き方</th><th>何が起きる？</th><th>useEffectでは？</th></tr>
<tr><td><code>return inner</code></td><td>関数を返す</td><td>✅ 正解！Reactが後で呼ぶ</td></tr>
<tr><td><code>return inner()</code></td><td>今すぐ実行し、結果を返す</td><td>❌ 即実行される</td></tr>
</table>

</div>

</details>

<details>
<summary><strong>🐍 Pythonエンジニア向け: TypeScriptの型システム</strong>（クリックで展開）</summary>

TypeScriptはJavaScriptに「型」を追加した言語です。
間違いを事前に防げる！

### 基本的な型


<div class="codehilite"><pre><span></span><code><span class="c1">// プリミティブ型</span>
<span class="kd">const</span><span class="w"> </span><span class="nx">name</span><span class="o">:</span><span class="w"> </span><span class="kt">string</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">&quot;太郎&quot;</span><span class="p">;</span>
<span class="kd">const</span><span class="w"> </span><span class="nx">age</span><span class="o">:</span><span class="w"> </span><span class="kt">number</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">25</span><span class="p">;</span>
<span class="kd">const</span><span class="w"> </span><span class="nx">isActive</span><span class="o">:</span><span class="w"> </span><span class="kt">boolean</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">true</span><span class="p">;</span>

<span class="c1">// 配列</span>
<span class="kd">const</span><span class="w"> </span><span class="nx">numbers</span><span class="o">:</span><span class="w"> </span><span class="kt">number</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mf">1</span><span class="p">,</span><span class="w"> </span><span class="mf">2</span><span class="p">,</span><span class="w"> </span><span class="mf">3</span><span class="p">];</span>
<span class="kd">const</span><span class="w"> </span><span class="nx">names</span><span class="o">:</span><span class="w"> </span><span class="kt">string</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="s2">&quot;Alice&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;Bob&quot;</span><span class="p">];</span>

<span class="c1">// オブジェクト型</span>
<span class="kr">type</span><span class="w"> </span><span class="nx">User</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">id</span><span class="o">:</span><span class="w"> </span><span class="kt">string</span><span class="p">;</span>
<span class="w">  </span><span class="nx">name</span><span class="o">:</span><span class="w"> </span><span class="kt">string</span><span class="p">;</span>
<span class="w">  </span><span class="nx">email</span><span class="o">:</span><span class="w"> </span><span class="kt">string</span><span class="p">;</span>
<span class="p">};</span>

<span class="kd">const</span><span class="w"> </span><span class="nx">user</span><span class="o">:</span><span class="w"> </span><span class="kt">User</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">id</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;1&quot;</span><span class="p">,</span>
<span class="w">  </span><span class="nx">name</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;太郎&quot;</span><span class="p">,</span>
<span class="w">  </span><span class="nx">email</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;taro@example.com&quot;</span><span class="p">,</span>
<span class="p">};</span>

<span class="c1">// user.age = 25;  // ❌ エラー！User型にageはない</span>
</code></pre></div>



### interface と type


<div class="codehilite"><pre><span></span><code><span class="c1">// interface: オブジェクトの形を定義</span>
<span class="kd">interface</span><span class="w"> </span><span class="nx">Message</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">id</span><span class="o">:</span><span class="w"> </span><span class="kt">string</span><span class="p">;</span>
<span class="w">  </span><span class="nx">role</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;user&#39;</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="s1">&#39;assistant&#39;</span><span class="p">;</span><span class="w">  </span><span class="c1">// リテラル型（この2つだけ許可）</span>
<span class="w">  </span><span class="nx">content</span><span class="o">:</span><span class="w"> </span><span class="kt">string</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// type: 任意の型を定義</span>
<span class="kr">type</span><span class="w"> </span><span class="nx">MessageRole</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">&#39;user&#39;</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="s1">&#39;assistant&#39;</span><span class="p">;</span>

<span class="c1">// どちらを使う？</span>
<span class="c1">// → 基本的にどちらでもOK</span>
<span class="c1">// → オブジェクトは interface が一般的</span>
<span class="c1">// → 複雑な型や Union は type が便利</span>
</code></pre></div>



### Union型とOptional


<div class="codehilite"><pre><span></span><code><span class="c1">// Union型: 複数の型のどれか</span>
<span class="kr">type</span><span class="w"> </span><span class="nx">Status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">&#39;loading&#39;</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="s1">&#39;success&#39;</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="s1">&#39;error&#39;</span><span class="p">;</span>

<span class="kd">let</span><span class="w"> </span><span class="nx">status</span><span class="o">:</span><span class="w"> </span><span class="kt">Status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">&#39;loading&#39;</span><span class="p">;</span>
<span class="nx">status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">&#39;success&#39;</span><span class="p">;</span><span class="w">  </span><span class="c1">// ✅ OK</span>
<span class="c1">// status = &#39;pending&#39;;  // ❌ エラー！</span>

<span class="c1">// Optional（省略可能）</span>
<span class="kd">interface</span><span class="w"> </span><span class="nx">User</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">id</span><span class="o">:</span><span class="w"> </span><span class="kt">string</span><span class="p">;</span>
<span class="w">  </span><span class="nx">name</span><span class="o">:</span><span class="w"> </span><span class="kt">string</span><span class="p">;</span>
<span class="w">  </span><span class="nx">email?</span><span class="o">:</span><span class="w"> </span><span class="kt">string</span><span class="p">;</span><span class="w">  </span><span class="c1">// ? で省略可能に</span>
<span class="p">}</span>

<span class="kd">const</span><span class="w"> </span><span class="nx">user1</span><span class="o">:</span><span class="w"> </span><span class="kt">User</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">id</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;1&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">name</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;太郎&quot;</span><span class="w"> </span><span class="p">};</span><span class="w">  </span><span class="c1">// ✅ emailなしでもOK</span>
<span class="kd">const</span><span class="w"> </span><span class="nx">user2</span><span class="o">:</span><span class="w"> </span><span class="kt">User</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">id</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;2&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">name</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;花子&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">email</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;hanako@example.com&quot;</span><span class="w"> </span><span class="p">};</span><span class="w">  </span><span class="c1">// ✅</span>
</code></pre></div>



### ジェネリクス


<div class="codehilite"><pre><span></span><code><span class="c1">// ジェネリクス: 型を引数のように渡せる</span>
<span class="kd">function</span><span class="w"> </span><span class="nx">useState</span><span class="p">&lt;</span><span class="nt">T</span><span class="p">&gt;(</span><span class="nx">initialValue</span><span class="o">:</span><span class="w"> </span><span class="kt">T</span><span class="p">)</span><span class="o">:</span><span class="w"> </span><span class="p">[</span><span class="nx">T</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="nx">value</span><span class="o">:</span><span class="w"> </span><span class="kt">T</span><span class="p">)</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="ow">void</span><span class="p">]</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// ...</span>
<span class="p">}</span>

<span class="c1">// 使うとき</span>
<span class="kd">const</span><span class="w"> </span><span class="p">[</span><span class="nx">count</span><span class="p">,</span><span class="w"> </span><span class="nx">setCount</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">useState</span><span class="p">&lt;</span><span class="nt">number</span><span class="p">&gt;(</span><span class="mf">0</span><span class="p">);</span>
<span class="kd">const</span><span class="w"> </span><span class="p">[</span><span class="nx">name</span><span class="p">,</span><span class="w"> </span><span class="nx">setName</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">useState</span><span class="p">&lt;</span><span class="nt">string</span><span class="p">&gt;(</span><span class="s2">&quot;太郎&quot;</span><span class="p">);</span>
<span class="kd">const</span><span class="w"> </span><span class="p">[</span><span class="nx">user</span><span class="p">,</span><span class="w"> </span><span class="nx">setUser</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">useState</span><span class="p">&lt;</span><span class="nt">User</span><span class="w"> </span><span class="err">|</span><span class="w"> </span><span class="na">null</span><span class="p">&gt;(</span><span class="kc">null</span><span class="p">);</span>

<span class="c1">// &lt;T&gt; は「型引数」</span>
<span class="c1">// 呼び出し側が具体的な型を指定できる</span>
</code></pre></div>



<div class="tip-box">
<h3>💡 TypeScript のメリット</h3>
<ol>
<li><strong>補完が効く</strong><br>user. と打つと id, name, email が候補に出る！</li>
<li><strong>間違いを事前に発見</strong><br>message.rolr と打つとエラー（role のtypo）</li>
<li><strong>リファクタリングが安全</strong><br>関数名や型を変えると、影響箇所が全て分かる</li>
<li><strong>ドキュメント代わり</strong><br>型定義を見れば、何が必要か分かる</li>
</ol>
<p>⚠️ 注意: 実行時には型情報は消える<br>
→ 実行時エラーは防げない（あくまで開発時のチェック）</p>
</div>

</details>

<hr />
<div class="tip-box">
<div class="box-title">📐 TypeScript/JavaScript のコード順序（一般的な規約）</div>
<div class="box-content">

<strong>推奨される順序：</strong>
<ol>
<li><strong>インポート</strong> - 外部モジュールの読み込み</li>
<li><strong>型/インターフェース</strong> - 型定義（<code>interface</code>, <code>type</code>）</li>
<li><strong>定数</strong> - 変更しない値（<code>const</code>）</li>
<li><strong>ヘルパー関数</strong> - 内部で使う補助関数</li>
<li><strong>メイン関数/export</strong> - 主要な機能</li>
</ol>

<p>この規約はPythonのPEP8と同様、可読性を高めるための慣習です。<br>
本ドキュメントのコード例はこの規約に従っています。</p>

</div>
</div>

<hr />
<h2 id="ファイルの拡張子を理解しよう">ファイルの拡張子を理解しよう<a class="header-link" href="#ファイルの拡張子を理解しよう" title="Permanent link">&para;</a></h2>
<div class="info-box">
<h3>📝 拡張子の意味</h3>
<table>
<tr><th>拡張子</th><th>意味</th><th>用途</th></tr>
<tr><td><strong>.js</strong></td><td>JavaScript</td><td>普通のJavaScriptファイル</td></tr>
<tr><td><strong>.ts</strong></td><td>TypeScript</td><td>型付きJavaScript（HTMLを含まない）</td></tr>
<tr><td><strong>.jsx</strong></td><td>JavaScript + JSX</td><td>React用（HTMLっぽい記法を含む）</td></tr>
<tr><td><strong>.tsx</strong></td><td>TypeScript + JSX</td><td>React用＋型付き（<strong>このプロジェクトの主役</strong>）</td></tr>
</table>
<p><strong>【.tsx のポイント】</strong></p>
<pre>
// .ts ファイル（HTMLなし）
function add(a: number, b: number): number {
  return a + b;
}

// .tsx ファイル（HTMLあり = JSX）
function Button(): JSX.Element {
  return &lt;button&gt;クリック&lt;/button&gt;;  // ← これがJSX
}
</pre>
<p>💡 <strong>使い分け:</strong></p>
<ul>
<li>UIを含む（画面パーツ）→ <code>.tsx</code></li>
<li>UIを含まない（ロジックのみ）→ <code>.ts</code></li>
</ul>
</div>

<hr />
<h2 id="プロジェクト構成の全体像">プロジェクト構成の全体像<a class="header-link" href="#プロジェクト構成の全体像" title="Permanent link">&para;</a></h2>
<div class="architecture-box">
<h3>🏗️ Reactプロジェクトの構成</h3>
<pre>
frontend/
├── index.html           ← ★ HTMLの土台（1回だけ読み込まれる）
├── src/
│   ├── main.tsx         ← ★ Reactの起動スクリプト
│   ├── App.tsx          ← ★ メインコンポーネント
│   └── components/      ← 各種UIパーツ
├── .env                 ← 環境変数（APIキーなど）
└── vite.config.ts       ← Viteの設定
</pre>
</div>

<div class="warning-box">
<h3>⚠️ 超重要：どのファイルに何を書く？</h3>
<div class="box-content">

<p><strong>【index.html】全ページ共通で1回だけ読み込むもの</strong></p>
<ul>
<li>Google Tag Manager (GTM)</li>
<li>Google Analytics</li>
<li>外部CSS/フォント（Google Fontsなど）</li>
<li><code>&lt;title&gt;</code> や <code>&lt;meta&gt;</code> タグ</li>
<li>favicon の設定</li>
</ul>

<pre><code class="language-html">&lt;!-- index.html の例 --&gt;
&lt;!DOCTYPE html&gt;
&lt;html lang="ja"&gt;
&lt;head&gt;
  &lt;!-- ↓ 全ページ共通で1回だけ読み込むもの --&gt;
  &lt;meta charset="UTF-8" /&gt;
  &lt;title&gt;AIチャット&lt;/title&gt;
  &lt;link rel="icon" href="/favicon.ico" /&gt;

  &lt;!-- GTM（Google Tag Manager）--&gt;
  &lt;script&gt;(function(w,d,s,l,i){...})(window,document,'script','dataLayer','GTM-XXXX');&lt;/script&gt;

  &lt;!-- Google Fonts --&gt;
  &lt;link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP&amp;display=swap" rel="stylesheet"&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;!-- ↓ Reactがここにコンポーネントを描画する --&gt;
  &lt;div id="root"&gt;&lt;/div&gt;

  &lt;!-- ↓ main.tsx を読み込んでReactを起動 --&gt;
  &lt;script type="module" src="/src/main.tsx"&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<div class="info-box">
<h3>🤔 なぜ .tsx ファイルを直接読み込める？</h3>
<p>本来ブラウザは <code>.tsx</code>（TypeScript + React）を読めません。<br>
これを可能にしているのが <strong>Vite（ビルドツール）</strong> です。</p>
<pre>
あなたのコード           Vite            ブラウザ
  (TypeScript)    →    (翻訳)    →    (JavaScript)
  (React JSX)     →    (翻訳)    →    (HTML + JS)
</pre>
<p><code>npm run dev</code> で Vite が起動し、翻訳しながら localhost:5173 で配信してくれます。</p>
<p>👉 詳しくは <a href="./05_セットアップの流れ.html#npm-install-npm-run-dev-とは">セットアップの流れ「npm install / npm run dev とは」</a> を参照</p>
</div>

<p><strong>【main.tsx】Reactを起動するだけ</strong></p>
<ul>
<li><code>index.html</code> の <code>#root</code> にReactアプリを埋め込む</li>
<li>基本的に変更不要</li>
</ul>

<pre><code class="language-tsx">// main.tsx
import React from 'react'
import ReactDOM from 'react-dom/client'
import App from './App'

ReactDOM.createRoot(document.getElementById('root')!).render(
  &lt;React.StrictMode&gt;
    &lt;App /&gt;  {/* ← ここからReactの世界が始まる */}
  &lt;/React.StrictMode&gt;
)
</code></pre>

<p><strong>【App.tsx 以下】画面の中身</strong></p>
<ul>
<li>ログイン状態による表示切り替え</li>
<li>チャット画面</li>
<li>ヘッダー、フッターなどのUI</li>
<li>動的に変わる部分はすべてここ</li>
</ul>

</div>
</div>

<div class="flow-box">
<h3>🔄 読み込まれる順番</h3>
<pre>
ブラウザ
  │
  ↓ ① index.html を読む
  │
  ├─▶ &lt;head&gt; の中身を処理
  │     ・GTM スクリプト実行
  │     ・CSS/フォント読み込み
  │
  ├─▶ &lt;body&gt; の中身を処理
  │     ・#root という空の div を作成
  │
  ↓ ② main.tsx を読む
  │
  ├─▶ React を起動
  │     ・#root に App コンポーネントを描画
  │
  ↓ ③ App.tsx が描画される
  │
  └─▶ ユーザーの操作に応じて画面が更新
        ・ログイン → ChatScreen
        ・メッセージ送信 → 画面更新
</pre>
<p><strong>ポイント:</strong> index.html は「器」、React は「中身」を担当</p>
</div>

<hr />
<h2 id="ファイル構成詳細">ファイル構成（詳細）<a class="header-link" href="#ファイル構成詳細" title="Permanent link">&para;</a></h2>
<div class="codehilite"><pre><span></span><code>frontend/src/
├── App.tsx              ← 🎯 メインコンポーネント（ここから始まる）
├── main.tsx             ← エントリーポイント（Reactの起動）
├── hooks/               ← 🎣 カスタムフック（ロジックを再利用）
│   ├── useAuth.ts       ← ログイン処理（UIなし → .ts）
│   ├── useChat.ts       ← チャット処理（UIなし → .ts）
│   └── useSessions.ts   ← セッション管理（UIなし → .ts）
├── services/            ← 外部サービス連携
│   ├── firebase.ts      ← Firebase初期化（UIなし → .ts）
│   └── api.ts           ← APIクライアント（UIなし → .ts）
├── components/          ← UIパーツ
│   ├── ChatScreen.tsx   ← チャット画面（UIあり → .tsx）
│   └── LoginScreen.tsx  ← ログイン画面（UIあり → .tsx）
└── renderers/           ← 【上級者向け】チャット表示カスタマイズ
</code></pre></div>

<div class="tip-box">
<h3>💡 学習のポイント</h3>
<p>まず理解すべきファイル（優先順位順）:</p>
<ol>
<li><strong>App.tsx</strong> ← 全体の流れを把握</li>
<li><strong>useAuth.ts</strong> ← 認証の仕組み</li>
<li><strong>useChat.ts</strong> ← チャットの仕組み</li>
<li><strong>useSessions.ts</strong> ← セッション管理</li>
<li><strong>api.ts</strong> ← API通信の仕組み</li>
</ol>
<p>renderers/ は上級者向け。最初はスキップしてOK！</p>
</div>

<hr />
<h2 id="1-reactの基本概念">1. Reactの基本概念<a class="header-link" href="#1-reactの基本概念" title="Permanent link">&para;</a></h2>
<h3 id="コンポーネントとは">コンポーネントとは？<a class="header-link" href="#コンポーネントとは" title="Permanent link">&para;</a></h3>
<div class="architecture-box">
<h3>🧱 コンポーネント = 画面のパーツ（レゴブロック）</h3>
<div style="border: 3px solid #fbbf24; border-radius: 8px; padding: 16px; background: #1e293b;">
  <div style="color: #fbbf24; font-weight: bold; margin-bottom: 12px;">App（親コンポーネント）</div>
  <div style="display: flex; gap: 16px; align-items: flex-start;">
    <!-- LoginScreen -->
    <div style="border: 2px solid #94a3b8; border-radius: 6px; padding: 12px; flex: 1; background: #334155;">
      <div style="color: #94a3b8; font-weight: bold; margin-bottom: 8px;">LoginScreen</div>
      <div style="border: 2px solid #64748b; border-radius: 4px; padding: 8px; display: inline-block; background: #475569;">
        <code style="color: #fbbf24; font-weight: bold;">LoginButton</code>
      </div>
    </div>
    <!-- または -->
    <div style="color: #94a3b8; font-weight: bold; align-self: center;">または</div>
    <!-- ChatScreen -->
    <div style="border: 2px solid #94a3b8; border-radius: 6px; padding: 12px; flex: 1; background: #334155;">
      <div style="color: #94a3b8; font-weight: bold; margin-bottom: 8px;">ChatScreen</div>
      <div style="border: 2px solid #64748b; border-radius: 4px; padding: 8px; background: #475569;">
        <div style="margin-bottom: 4px;"><code style="color: #fbbf24; font-weight: bold;">SessionList</code></div>
        <div style="margin-bottom: 4px;"><code style="color: #fbbf24; font-weight: bold;">MessageList</code></div>
        <div><code style="color: #fbbf24; font-weight: bold;">InputField</code></div>
      </div>
    </div>
  </div>
</div>
<p>コンポーネントを組み合わせて画面全体を作る！</p>
</div>

<h3 id="jsxjavascript--html">JSX（JavaScript + HTML）<a class="header-link" href="#jsxjavascript--html" title="Permanent link">&para;</a></h3>
<p>ReactではJSXという記法を使います。<br />
JavaScript の中に HTML っぽく書ける！</p>
<div class="codehilite"><pre><span></span><code><span class="c1">// ボタンコンポーネントの例</span>
<span class="kd">function</span><span class="w"> </span><span class="nx">MyButton</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// JavaScript の中に HTML っぽく書ける！</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="p">&lt;</span><span class="nt">button</span><span class="p">&gt;</span><span class="nx">クリック</span><span class="p">&lt;/</span><span class="nt">button</span><span class="p">&gt;;</span>
<span class="p">}</span>

<span class="c1">// 使う側</span>
<span class="kd">function</span><span class="w"> </span><span class="nx">App</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="p">(</span>
<span class="w">    </span><span class="p">&lt;</span><span class="nt">div</span><span class="p">&gt;</span>
<span class="w">      </span><span class="p">&lt;</span><span class="nt">h1</span><span class="p">&gt;</span><span class="nx">こんにちは</span><span class="p">&lt;/</span><span class="nt">h1</span><span class="p">&gt;</span>
<span class="w">      </span><span class="p">&lt;</span><span class="nt">MyButton</span><span class="w"> </span><span class="p">/&gt;</span><span class="w">  </span><span class="p">{</span><span class="cm">/* ← 自作コンポーネントを使う */</span><span class="p">}</span>
<span class="w">    </span><span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
<span class="w">  </span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>

<div class="info-box">
<h3>📝 JSXの特徴</h3>
<ul>
<li>✅ HTML っぽく書ける（でも実は JavaScript）</li>
<li>✅ {} の中に JavaScript を書ける</li>
<li>✅ 自作コンポーネントは &lt;MyComponent /&gt; のように使う</li>
<li>✅ class は className と書く（JSの予約語だから）</li>
</ul>
<p><strong>例:</strong></p>
<pre>const name = "太郎";
return &lt;h1&gt;こんにちは、{name}さん！&lt;/h1&gt;;
// → "こんにちは、太郎さん！" と表示される</pre>
</div>

<hr />
<h2 id="2-usestate---状態管理の基本">2. useState - 状態管理の基本<a class="header-link" href="#2-usestate---状態管理の基本" title="Permanent link">&para;</a></h2>
<h3 id="なぜ-state-が必要なのか">なぜ state が必要なのか？<a class="header-link" href="#なぜ-state-が必要なのか" title="Permanent link">&para;</a></h3>
<div class="warning-box">
<h3>普通の変数では画面が更新されない</h3>
<div class="box-content">

Reactで最初につまずくポイントがここです。
普通のプログラミングでは変数を更新すれば値が変わりますが、**Reactでは画面が更新されません**。

<strong>問題のあるコード:</strong>

<div class="codehilite"><pre><span></span><code><span class="kd">function</span><span class="w"> </span><span class="nx">Counter</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="nx">count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0</span><span class="p">;</span><span class="w">  </span><span class="c1">// 普通の変数</span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="p">(</span>
<span class="w">    </span><span class="p">&lt;</span><span class="nt">div</span><span class="p">&gt;</span>
<span class="w">      </span><span class="p">&lt;</span><span class="nt">p</span><span class="p">&gt;</span><span class="nx">カウント</span><span class="o">:</span><span class="w"> </span><span class="p">{</span><span class="nx">count</span><span class="p">}&lt;/</span><span class="nt">p</span><span class="p">&gt;</span>
<span class="w">      </span><span class="p">&lt;</span><span class="nt">button</span><span class="w"> </span><span class="na">onClick</span><span class="o">=</span><span class="p">{()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">count</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mf">1</span><span class="p">;</span><span class="w"> </span><span class="p">}}&gt;</span>
<span class="w">        </span><span class="o">+</span><span class="mf">1</span>
<span class="w">      </span><span class="p">&lt;/</span><span class="nt">button</span><span class="p">&gt;</span>
<span class="w">    </span><span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
<span class="w">  </span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>



<strong>何が起きる？</strong>
<pre>
ボタンをクリック
    ↓
count = 1 になる（変数は更新される）
    ↓
でも画面は「カウント: 0」のまま！ ← なぜ？
</pre>

<strong>理由: Reactは「値が変わった」ことを知らない</strong>

普通の変数を変えても、Reactには何も通知されません。
Reactが画面を更新するには「今から値が変わるよ！」と教える必要があります。

</div>
</div>

<div class="info-box">
<h3>state = 「Reactに監視されている特別な変数」</h3>

<pre>
【普通の変数】
let count = 0;
count = 1;        ← Reactは気づかない → 画面そのまま

【state（useState）】
const [count, setCount] = useState(0);
setCount(1);      ← Reactに通知される → 画面が更新される！
</pre>

<p><strong>state を使う理由:</strong></p>
<ol>
<li><strong>画面を自動更新</strong>: state が変わると React が画面を再描画</li>
<li><strong>値を保持</strong>: 再描画されても値が消えない（普通の変数は毎回初期化される）</li>
<li><strong>React が追跡</strong>: いつ・どこで値が変わったかを React が把握できる</li>
</ol>

</div>

<h3 id="usestate-とは">useState とは？<a class="header-link" href="#usestate-とは" title="Permanent link">&para;</a></h3>
<p>コンポーネント内で「状態（データ）」を持つための仕組み。<br />
状態が変わると、画面が自動で再描画される！</p>
<div class="codehilite"><pre><span></span><code><span class="k">import</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">useState</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="kr">from</span><span class="w"> </span><span class="s1">&#39;react&#39;</span><span class="p">;</span>

<span class="kd">function</span><span class="w"> </span><span class="nx">Counter</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// ┌─────────────────────────────────────────────────────────────────┐</span>
<span class="w">  </span><span class="c1">// │ useState(初期値) の戻り値:                                       │</span>
<span class="w">  </span><span class="c1">// │   [0] 現在の値（count）                                          │</span>
<span class="w">  </span><span class="c1">// │   [1] 値を更新する関数（setCount）                                │</span>
<span class="w">  </span><span class="c1">// └─────────────────────────────────────────────────────────────────┘</span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="p">[</span><span class="nx">count</span><span class="p">,</span><span class="w"> </span><span class="nx">setCount</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">useState</span><span class="p">(</span><span class="mf">0</span><span class="p">);</span><span class="w">  </span><span class="c1">// 初期値は 0</span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="p">(</span>
<span class="w">    </span><span class="p">&lt;</span><span class="nt">div</span><span class="p">&gt;</span>
<span class="w">      </span><span class="p">&lt;</span><span class="nt">p</span><span class="p">&gt;</span><span class="nx">カウント</span><span class="o">:</span><span class="w"> </span><span class="p">{</span><span class="nx">count</span><span class="p">}&lt;/</span><span class="nt">p</span><span class="p">&gt;</span>
<span class="w">      </span><span class="p">&lt;</span><span class="nt">button</span><span class="w"> </span><span class="na">onClick</span><span class="o">=</span><span class="p">{()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="nx">setCount</span><span class="p">(</span><span class="nx">count</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mf">1</span><span class="p">)}&gt;</span>
<span class="w">        </span><span class="o">+</span><span class="mf">1</span>
<span class="w">      </span><span class="p">&lt;/</span><span class="nt">button</span><span class="p">&gt;</span>
<span class="w">    </span><span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
<span class="w">  </span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>

<div class="flow-box">
<h3>🔄 useState の動作</h3>
<ol>
<li><strong>最初のレンダリング</strong><br>count = 0<br>画面: 「カウント: 0」</li>
<li><strong>ボタンをクリック</strong><br>setCount(0 + 1) が呼ばれる</li>
<li><strong>React が再レンダリング</strong><br>count = 1<br>画面: 「カウント: 1」 ← 自動で更新！</li>
</ol>
<p>⚠️ 直接 count = 1 と書いても画面は更新されない！<br>必ず setCount() を使う！</p>
</div>

<h3 id="配列の分割代入">配列の分割代入<a class="header-link" href="#配列の分割代入" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><code><span class="c1">// これ何？と思った人へ</span>
<span class="kd">const</span><span class="w"> </span><span class="p">[</span><span class="nx">count</span><span class="p">,</span><span class="w"> </span><span class="nx">setCount</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">useState</span><span class="p">(</span><span class="mf">0</span><span class="p">);</span>

<span class="c1">// ↑ は以下と同じ意味</span>
<span class="kd">const</span><span class="w"> </span><span class="nx">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">useState</span><span class="p">(</span><span class="mf">0</span><span class="p">);</span><span class="w">      </span><span class="c1">// [0, 関数] が返ってくる</span>
<span class="kd">const</span><span class="w"> </span><span class="nx">count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">result</span><span class="p">[</span><span class="mf">0</span><span class="p">];</span><span class="w">         </span><span class="c1">// 現在の値</span>
<span class="kd">const</span><span class="w"> </span><span class="nx">setCount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">result</span><span class="p">[</span><span class="mf">1</span><span class="p">];</span><span class="w">      </span><span class="c1">// 更新関数</span>

<span class="c1">// 「配列の分割代入」という JavaScript の機能</span>
<span class="c1">// 配列の要素を変数に展開できる</span>
<span class="kd">const</span><span class="w"> </span><span class="p">[</span><span class="nx">first</span><span class="p">,</span><span class="w"> </span><span class="nx">second</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mf">1</span><span class="p">,</span><span class="w"> </span><span class="mf">2</span><span class="p">];</span><span class="w">  </span><span class="c1">// first = 1, second = 2</span>
</code></pre></div>

<h3 id="オブジェクトの分割代入カスタムフックで頻出">オブジェクトの分割代入（カスタムフックで頻出）<a class="header-link" href="#オブジェクトの分割代入カスタムフックで頻出" title="Permanent link">&para;</a></h3>
<p>配列だけでなく、<strong>オブジェクト（dict）</strong> からも値を取り出せます。<br />
カスタムフック（useAuth, useChat など）はこちらを使います。</p>
<div class="codehilite"><pre><span></span><code><span class="c1">// useChat が返すオブジェクト</span>
<span class="p">{</span>
<span class="w">  </span><span class="nx">messages</span><span class="o">:</span><span class="w"> </span><span class="p">[...],</span>
<span class="w">  </span><span class="nx">isLoading</span><span class="o">:</span><span class="w"> </span><span class="kt">true</span><span class="p">,</span>
<span class="w">  </span><span class="nx">error</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;何かエラー&quot;</span><span class="p">,</span>
<span class="w">  </span><span class="nx">sendMessage</span><span class="o">:</span><span class="w"> </span><span class="p">(</span><span class="nx">関数</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// オブジェクトの分割代入で取り出す</span>
<span class="kd">const</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">messages</span><span class="p">,</span><span class="w"> </span><span class="nx">isLoading</span><span class="p">,</span><span class="w"> </span><span class="nx">error</span><span class="p">,</span><span class="w"> </span><span class="nx">sendMessage</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">useChat</span><span class="p">(...)</span>
</code></pre></div>

<div class="warning-box">
<h3>⚠️ {} の有無で意味が変わる！</h3>
<div class="box-content">


<div class="codehilite"><pre><span></span><code><span class="c1">// ① {} なし = オブジェクト全体を受け取る</span>
<span class="kd">const</span><span class="w"> </span><span class="nx">chatState</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">useChat</span><span class="p">(...)</span>
<span class="nx">chatState</span><span class="p">.</span><span class="nx">messages</span><span class="w">    </span><span class="c1">// ✅ OK</span>
<span class="nx">chatState</span><span class="p">.</span><span class="nx">isLoading</span><span class="w">   </span><span class="c1">// ✅ OK</span>
<span class="nx">chatState</span><span class="p">.</span><span class="nx">test</span><span class="w">        </span><span class="c1">// ⚠️ undefined（存在しないキー）</span>

<span class="c1">// ② {} あり = キー名を指定して取り出す</span>
<span class="kd">const</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">messages</span><span class="p">,</span><span class="w"> </span><span class="nx">isLoading</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">useChat</span><span class="p">(...)</span>
<span class="nx">messages</span><span class="w">              </span><span class="c1">// ✅ OK（配列）</span>
<span class="nx">isLoading</span><span class="w">             </span><span class="c1">// ✅ OK（true/false）</span>
<span class="nx">chatState</span><span class="w">             </span><span class="c1">// ❌ 使えない（定義していない）</span>

<span class="c1">// ③ 存在しないキー名を書くと...</span>
<span class="kd">const</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">test</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">useChat</span><span class="p">(...)</span>
<span class="nx">test</span><span class="w">                  </span><span class="c1">// ⚠️ undefined（エラーにはならない）</span>
<span class="nx">test</span><span class="p">.</span><span class="nx">messages</span><span class="w">         </span><span class="c1">// ❌ エラー！（undefined に .messages はできない）</span>
</code></pre></div>



**ポイント**: `{}` を使う場合は、**オブジェクト内に存在するキー名** を書く必要がある！

</div>
</div>

<div class="info-box">
<h3>📝 Python で書くと</h3>
<pre>
# Python の場合（dict から取り出す）
result = use_chat(...)
messages = result["messages"]
is_loading = result["isLoading"]
error = result["error"]
send_message = result["sendMessage"]

# JavaScript の分割代入は、上の4行を1行で書ける！
</pre>
</div>

<h3 id="別名で取り出すリネーム">別名で取り出す（リネーム）<a class="header-link" href="#別名で取り出すリネーム" title="Permanent link">&para;</a></h3>
<p><strong>同じ名前のキーが衝突するとき</strong>、別名を付けて取り出せます。</p>
<div class="codehilite"><pre><span></span><code><span class="c1">// 問題: useAuth も useChat も error を返す → 名前が被る！</span>
<span class="kd">const</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">error</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">useAuth</span><span class="p">()</span><span class="w">   </span><span class="c1">// 認証エラー</span>
<span class="kd">const</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">error</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">useChat</span><span class="p">()</span><span class="w">   </span><span class="c1">// チャットエラー ← エラー！</span>

<span class="c1">// 解決: 別名を付ける</span>
<span class="kd">const</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">error</span><span class="o">:</span><span class="w"> </span><span class="kt">authError</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">useAuth</span><span class="p">()</span><span class="w">   </span><span class="c1">// authError という変数に</span>
<span class="kd">const</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">error</span><span class="o">:</span><span class="w"> </span><span class="kt">chatError</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">useChat</span><span class="p">()</span><span class="w">   </span><span class="c1">// chatError という変数に</span>
</code></pre></div>

<div class="tip-box">
<h3>💡 SQL の AS と同じ！</h3>
<pre>
-- SQL
SELECT error AS chatError FROM ...
--     ↑元     ↑別名

// JavaScript（順番が逆だけど同じ意味）
const { error: chatError } = useChat(...)
//      ↑元    ↑別名
</pre>
<table>
<tr><th>言語</th><th>記法</th><th>意味</th></tr>
<tr><td>SQL</td><td><code>error AS chatError</code></td><td>error を chatError という名前で取り出す</td></tr>
<tr><td>JavaScript</td><td><code>{ error: chatError }</code></td><td>error を chatError という名前で取り出す</td></tr>
<tr><td>Python</td><td><code>chat_error = result["error"]</code></td><td>dict の "error" キーの値を chat_error に代入</td></tr>
</table>
</div>

<h3 id="usestateからカスタムフックへ---分割代入の発展">useStateからカスタムフックへ - 分割代入の発展<a class="header-link" href="#usestateからカスタムフックへ---分割代入の発展" title="Permanent link">&para;</a></h3>
<div class="info-box">
<h3>🔑 useStateを組み合わせてカスタムフックを作る</h3>

<p><code>useState</code> は配列を返し、カスタムフックは複数の <code>useState</code> をまとめてオブジェクトで返します。</p>

<table>
<tr><th>種類</th><th>取り出し方</th><th>使う場面</th></tr>
<tr><td><strong>配列</strong></td><td>順番で決まる</td><td>useState（[値, 更新関数]）</td></tr>
<tr><td><strong>オブジェクト</strong></td><td>名前で決まる</td><td>カスタムフック（useAuth, useChat など）</td></tr>
</table>

<pre>
// useAuth の内部（イメージ）
function useAuth() {
  const [user, setUser] = useState(null)       // ← useState（配列）
  const [loading, setLoading] = useState(true) // ← useState（配列）
  const [error, setError] = useState(null)     // ← useState（配列）

  // これらをまとめてオブジェクトで返す
  return { user, loading, error, loginWithGoogle, logout }
}

// 使う側: オブジェクトの分割代入
const { user, loading } = useAuth()
</pre>

<p>💡 カスタムフックは「複数のuseStateをまとめて使いやすくしたもの」と考えるとわかりやすい！</p>

</div>

<h3 id="setcountはどこで定義した超よくある質問">「setCount」はどこで定義した？（超よくある質問）<a class="header-link" href="#setcountはどこで定義した超よくある質問" title="Permanent link">&para;</a></h3>
<div class="warning-box">
<h3>❓ 「setCount って自分で作ってないのに、なぜ使える？」</h3>
<div class="box-content">

<strong>答え: <code>useState</code> が内部で作って返してくれる</strong>


<div class="codehilite"><pre><span></span><code><span class="kd">const</span><span class="w"> </span><span class="p">[</span><span class="nx">count</span><span class="p">,</span><span class="w"> </span><span class="nx">setCount</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">useState</span><span class="p">(</span><span class="mf">0</span><span class="p">);</span>
<span class="c1">//            ↑ これは useState が作った関数</span>
</code></pre></div>



自分で `function setCount() {...}` と書いたわけではない！
`useState` を呼ぶと、React が以下を返してくれる：

<ol>
<li><strong>現在の値</strong>（<code>count</code>）</li>
<li><strong>その値を更新する関数</strong>（<code>setCount</code>）</li>
</ol>

<pre>
useState(0) が返すもの:
┌─────────────────────────────────────────┐
│  [0] → 現在の値（最初は初期値の 0）       │
│  [1] → 更新関数（React が用意してくれる） │
└─────────────────────────────────────────┘
</pre>

<strong>ポイント</strong>: <code>setCount</code> を呼ぶと、Reactは：
1. 新しい値を内部に保存
2. コンポーネントを再レンダリング（画面更新）

</div>
</div>

<h3 id="初期値と現在値の違い混乱しやすい">初期値と現在値の違い（混乱しやすい）<a class="header-link" href="#初期値と現在値の違い混乱しやすい" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><code><span class="kd">const</span><span class="w"> </span><span class="p">[</span><span class="nx">count</span><span class="p">,</span><span class="w"> </span><span class="nx">setCount</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">useState</span><span class="p">(</span><span class="mf">0</span><span class="p">);</span>
<span class="c1">//                                 ↑ 初期値（最初の1回だけ使う）</span>
<span class="c1">//           ↑ 現在の値（常に変化しうる）</span>
</code></pre></div>

<div class="info-box">
<h3>📝 初期値 vs 現在値</h3>
<table>
<tr><th>用語</th><th>意味</th><th>例</th></tr>
<tr><td><strong>初期値</strong></td><td>useState の引数。最初のレンダリング時だけ使う</td><td><code>useState(0)</code> の <code>0</code></td></tr>
<tr><td><strong>現在値</strong></td><td>今のstate。更新のたびに変わる</td><td><code>count</code>（0→1→2→...）</td></tr>
</table>
<p>💡 2回目以降のレンダリングでは、初期値 <code>0</code> は無視される</p>
</div>

<h3 id="セッター関数の使い方---値を直接渡すだけでok">セッター関数の使い方 - 値を直接渡すだけでOK！<a class="header-link" href="#セッター関数の使い方---値を直接渡すだけでok" title="Permanent link">&para;</a></h3>
<div class="tip-box">
<h3>💡 セッター関数には「値を直接渡す」のが基本！</h3>
<div class="box-content">


<div class="codehilite"><pre><span></span><code><span class="kd">const</span><span class="w"> </span><span class="p">[</span><span class="nx">user</span><span class="p">,</span><span class="w"> </span><span class="nx">setUser</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">useState</span><span class="p">(</span><span class="kc">null</span><span class="p">);</span>
<span class="kd">const</span><span class="w"> </span><span class="p">[</span><span class="nx">loading</span><span class="p">,</span><span class="w"> </span><span class="nx">setLoading</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">useState</span><span class="p">(</span><span class="kc">true</span><span class="p">);</span>

<span class="c1">// ✅ 値を直接渡す（これが基本！）</span>
<span class="nx">setUser</span><span class="p">(</span><span class="nx">newUser</span><span class="p">);</span><span class="w">      </span><span class="c1">// newUser をそのままセット</span>
<span class="nx">setLoading</span><span class="p">(</span><span class="kc">false</span><span class="p">);</span><span class="w">     </span><span class="c1">// false をそのままセット</span>
<span class="nx">setUser</span><span class="p">(</span><span class="kc">null</span><span class="p">);</span><span class="w">         </span><span class="c1">// null をセット</span>
</code></pre></div>



<strong>Python との比較:</strong>

<div class="codehilite"><pre><span></span><code><span class="c1"># Python（普通の変数）</span>
<span class="n">user</span> <span class="o">=</span> <span class="n">new_user</span>       <span class="c1"># 代入で更新</span>

<span class="c1"># React（useState）</span>
<span class="n">setUser</span><span class="p">(</span><span class="n">new_user</span><span class="p">)</span>     <span class="c1"># セッター関数で更新</span>
</code></pre></div>



<strong>なぜ普通の代入 <code>user = xxx</code> じゃダメ？</strong>

普通の代入だと React が変更に気づけない。<code>setUser()</code> を使うことで「値が変わった！」と React に通知され、画面が再描画される。

</div>
</div>

<div class="info-box">
<h3>📝 セッター関数の2つの書き方</h3>
<table>
<tr><th>書き方</th><th>例</th><th>いつ使う？</th></tr>
<tr><td><strong>値を直接渡す</strong></td><td><code>setUser(user)</code></td><td>新しい値がわかっているとき（基本はこれ！）</td></tr>
<tr><td><strong>関数を渡す</strong></td><td><code>setCount(prev => prev + 1)</code></td><td>前の値を使って計算するとき</td></tr>
</table>
</div>

<h3 id="関数型更新prev--連続更新で必須">関数型更新（prev）- 連続更新で必須！<a class="header-link" href="#関数型更新prev--連続更新で必須" title="Permanent link">&para;</a></h3>
<div class="warning-box">
<h3>⚠️ 連続で setState すると、期待通りに動かない？</h3>
<div class="box-content">

<strong>問題のあるコード:</strong>

<div class="codehilite"><pre><span></span><code><span class="kd">const</span><span class="w"> </span><span class="p">[</span><span class="nx">count</span><span class="p">,</span><span class="w"> </span><span class="nx">setCount</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">useState</span><span class="p">(</span><span class="mf">0</span><span class="p">);</span>

<span class="kd">function</span><span class="w"> </span><span class="nx">handleClick</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">setCount</span><span class="p">(</span><span class="nx">count</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mf">1</span><span class="p">);</span><span class="w">  </span><span class="c1">// count=0 なので 0+1=1</span>
<span class="w">  </span><span class="nx">setCount</span><span class="p">(</span><span class="nx">count</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mf">1</span><span class="p">);</span><span class="w">  </span><span class="c1">// count=0 なので 0+1=1</span>
<span class="w">  </span><span class="nx">setCount</span><span class="p">(</span><span class="nx">count</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mf">1</span><span class="p">);</span><span class="w">  </span><span class="c1">// count=0 なので 0+1=1</span>
<span class="w">  </span><span class="c1">// 結果: count は 1 になる（3じゃない！）</span>
<span class="p">}</span>
</code></pre></div>



<strong>なぜ？</strong> <code>setCount</code> は非同期で、<code>count</code> はまだ古い値のまま

<strong>解決: 関数型更新（prev）を使う</strong>

<div class="codehilite"><pre><span></span><code><span class="kd">function</span><span class="w"> </span><span class="nx">handleClick</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">setCount</span><span class="p">(</span><span class="nx">prev</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="nx">prev</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mf">1</span><span class="p">);</span><span class="w">  </span><span class="c1">// prev=0 → 1</span>
<span class="w">  </span><span class="nx">setCount</span><span class="p">(</span><span class="nx">prev</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="nx">prev</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mf">1</span><span class="p">);</span><span class="w">  </span><span class="c1">// prev=1 → 2</span>
<span class="w">  </span><span class="nx">setCount</span><span class="p">(</span><span class="nx">prev</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="nx">prev</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mf">1</span><span class="p">);</span><span class="w">  </span><span class="c1">// prev=2 → 3</span>
<span class="w">  </span><span class="c1">// 結果: count は 3 になる！✅</span>
<span class="p">}</span>
</code></pre></div>



</div>
</div>

<div class="info-box">
<h3>🔑 prev の正体</h3>
<p><strong>prev は「過去の値」ではなく「更新直前の最新値」</strong></p>
<pre>
setCount(prev => prev + 1)
         ↑
         これは「更新が適用される直前の state」

時系列:
  1回目: prev=0 → 0+1=1 を返す → state=1
  2回目: prev=1 → 1+1=2 を返す → state=2
  3回目: prev=2 → 2+1=3 を返す → state=3
</pre>
<p><strong>いつ関数型を使う？</strong></p>
<ul>
<li>✅ 連続で更新するとき</li>
<li>✅ 現在の値を元に計算するとき</li>
<li>✅ 非同期処理の中で更新するとき</li>
</ul>
</div>

<h3 id="配列-state-の更新超重要">配列 state の更新（超重要！）<a class="header-link" href="#配列-state-の更新超重要" title="Permanent link">&para;</a></h3>
<p>実際のアプリでは、配列（リスト）を state で管理することが多い。<br />
<strong>破壊的変更（push等）はNG！必ずコピーして新しい配列を作る</strong></p>
<div class="architecture-box">
<h3>📦 配列 state の更新テンプレート</h3>

<strong>セットアップ:</strong>

<div class="codehilite"><pre><span></span><code><span class="kd">const</span><span class="w"> </span><span class="p">[</span><span class="nx">items</span><span class="p">,</span><span class="w"> </span><span class="nx">setItems</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">useState</span><span class="p">([</span>
<span class="w">  </span><span class="p">{</span><span class="w"> </span><span class="nx">id</span><span class="o">:</span><span class="w"> </span><span class="kt">1</span><span class="p">,</span><span class="w"> </span><span class="nx">name</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;りんご&quot;</span><span class="w"> </span><span class="p">},</span>
<span class="w">  </span><span class="p">{</span><span class="w"> </span><span class="nx">id</span><span class="o">:</span><span class="w"> </span><span class="kt">2</span><span class="p">,</span><span class="w"> </span><span class="nx">name</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;バナナ&quot;</span><span class="w"> </span><span class="p">},</span>
<span class="p">]);</span>
</code></pre></div>



<strong>① 追加（末尾に追加）</strong>

<div class="codehilite"><pre><span></span><code><span class="kd">const</span><span class="w"> </span><span class="nx">newItem</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">id</span><span class="o">:</span><span class="w"> </span><span class="kt">3</span><span class="p">,</span><span class="w"> </span><span class="nx">name</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;みかん&quot;</span><span class="w"> </span><span class="p">};</span>
<span class="nx">setItems</span><span class="p">(</span><span class="nx">prev</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">[...</span><span class="nx">prev</span><span class="p">,</span><span class="w"> </span><span class="nx">newItem</span><span class="p">]);</span>
<span class="c1">// 結果: [りんご, バナナ, みかん]</span>
</code></pre></div>



<strong>② 削除（特定のIDを削除）</strong>

<div class="codehilite"><pre><span></span><code><span class="nx">setItems</span><span class="p">(</span><span class="nx">prev</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="nx">prev</span><span class="p">.</span><span class="nx">filter</span><span class="p">(</span><span class="nx">item</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="nx">item</span><span class="p">.</span><span class="nx">id</span><span class="w"> </span><span class="o">!==</span><span class="w"> </span><span class="mf">2</span><span class="p">));</span>
<span class="c1">// 結果: [りんご, みかん]  ← id:2 のバナナが消えた</span>
</code></pre></div>



<strong>③ 更新（特定のアイテムを変更）</strong>

<div class="codehilite"><pre><span></span><code><span class="nx">setItems</span><span class="p">(</span><span class="nx">prev</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="nx">prev</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">item</span><span class="w"> </span><span class="p">=&gt;</span>
<span class="w">  </span><span class="nx">item</span><span class="p">.</span><span class="nx">id</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="mf">1</span>
<span class="w">    </span><span class="o">?</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="nx">item</span><span class="p">,</span><span class="w"> </span><span class="nx">name</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;青りんご&quot;</span><span class="w"> </span><span class="p">}</span><span class="w">  </span><span class="c1">// id:1 だけ変更</span>
<span class="w">    </span><span class="o">:</span><span class="w"> </span><span class="nx">item</span><span class="w">                           </span><span class="c1">// それ以外はそのまま</span>
<span class="p">));</span>
<span class="c1">// 結果: [青りんご, バナナ, みかん]</span>
</code></pre></div>



</div>

<div class="warning-box">
<h3>❌ やってはいけない（破壊的変更）</h3>
<div class="box-content">


<div class="codehilite"><pre><span></span><code><span class="c1">// ❌ NG: push は元の配列を変更する</span>
<span class="nx">items</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">newItem</span><span class="p">);</span>
<span class="nx">setItems</span><span class="p">(</span><span class="nx">items</span><span class="p">);</span><span class="w">  </span><span class="c1">// Reactは「同じ配列」と判断して再描画しない</span>

<span class="c1">// ❌ NG: 直接代入</span>
<span class="nx">items</span><span class="p">[</span><span class="mf">0</span><span class="p">].</span><span class="nx">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">&quot;青りんご&quot;</span><span class="p">;</span>
<span class="nx">setItems</span><span class="p">(</span><span class="nx">items</span><span class="p">);</span><span class="w">  </span><span class="c1">// 同じく再描画されない</span>
</code></pre></div>



<strong>なぜNG？</strong>
Reactは「配列の参照（アドレス）」が変わったかで再描画を判断する。
<code>push</code> や直接代入は参照が同じままなので、Reactは変化に気づかない。

<strong>✅ 正解: スプレッド構文で新しい配列を作る</strong>

<div class="codehilite"><pre><span></span><code><span class="nx">setItems</span><span class="p">(</span><span class="nx">prev</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">[...</span><span class="nx">prev</span><span class="p">,</span><span class="w"> </span><span class="nx">newItem</span><span class="p">]);</span><span class="w">  </span><span class="c1">// 新しい配列を作成</span>
</code></pre></div>



</div>
</div>

<h3 id="オブジェクト-state-の更新">オブジェクト state の更新<a class="header-link" href="#オブジェクト-state-の更新" title="Permanent link">&para;</a></h3>
<p>オブジェクト（連想配列/dict）も配列と同じ原則：<strong>コピーして一部を変える</strong></p>
<div class="architecture-box">
<h3>🔧 オブジェクト state の更新テンプレート</h3>

<strong>セットアップ:</strong>

<div class="codehilite"><pre><span></span><code><span class="kd">const</span><span class="w"> </span><span class="p">[</span><span class="nx">user</span><span class="p">,</span><span class="w"> </span><span class="nx">setUser</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">useState</span><span class="p">({</span>
<span class="w">  </span><span class="nx">name</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;太郎&quot;</span><span class="p">,</span>
<span class="w">  </span><span class="nx">age</span><span class="o">:</span><span class="w"> </span><span class="kt">25</span><span class="p">,</span>
<span class="w">  </span><span class="nx">email</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;taro@example.com&quot;</span>
<span class="p">});</span>
</code></pre></div>



<strong>① 一部だけ更新</strong>

<div class="codehilite"><pre><span></span><code><span class="nx">setUser</span><span class="p">(</span><span class="nx">prev</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">({</span>
<span class="w">  </span><span class="p">...</span><span class="nx">prev</span><span class="p">,</span><span class="w">           </span><span class="c1">// 既存のプロパティをコピー</span>
<span class="w">  </span><span class="nx">name</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;花子&quot;</span><span class="w">       </span><span class="c1">// name だけ上書き</span>
<span class="p">}));</span>
<span class="c1">// 結果: { name: &quot;花子&quot;, age: 25, email: &quot;taro@example.com&quot; }</span>
</code></pre></div>



<strong>② ネストしたオブジェクトの更新</strong>

<div class="codehilite"><pre><span></span><code><span class="kd">const</span><span class="w"> </span><span class="p">[</span><span class="nx">user</span><span class="p">,</span><span class="w"> </span><span class="nx">setUser</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">useState</span><span class="p">({</span>
<span class="w">  </span><span class="nx">name</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;太郎&quot;</span><span class="p">,</span>
<span class="w">  </span><span class="nx">profile</span><span class="o">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">age</span><span class="o">:</span><span class="w"> </span><span class="kt">25</span><span class="p">,</span>
<span class="w">    </span><span class="nx">city</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;東京&quot;</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">});</span>

<span class="c1">// profile.age だけ更新</span>
<span class="nx">setUser</span><span class="p">(</span><span class="nx">prev</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">({</span>
<span class="w">  </span><span class="p">...</span><span class="nx">prev</span><span class="p">,</span>
<span class="w">  </span><span class="nx">profile</span><span class="o">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">...</span><span class="nx">prev</span><span class="p">.</span><span class="nx">profile</span><span class="p">,</span><span class="w">  </span><span class="c1">// profile の中身もコピー</span>
<span class="w">    </span><span class="nx">age</span><span class="o">:</span><span class="w"> </span><span class="kt">26</span><span class="w">           </span><span class="c1">// age だけ上書き</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}));</span>
</code></pre></div>



</div>

<div class="warning-box">
<h3>❌ よくある間違い</h3>
<div class="box-content">


<div class="codehilite"><pre><span></span><code><span class="c1">// ❌ NG: 他のプロパティが消える</span>
<span class="nx">setUser</span><span class="p">({</span><span class="w"> </span><span class="nx">name</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;花子&quot;</span><span class="w"> </span><span class="p">});</span>
<span class="c1">// 結果: { name: &quot;花子&quot; }  ← age, email が消えた！</span>

<span class="c1">// ✅ OK: スプレッドで既存をコピー</span>
<span class="nx">setUser</span><span class="p">(</span><span class="nx">prev</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">({</span><span class="w"> </span><span class="p">...</span><span class="nx">prev</span><span class="p">,</span><span class="w"> </span><span class="nx">name</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;花子&quot;</span><span class="w"> </span><span class="p">}));</span>
<span class="c1">// 結果: { name: &quot;花子&quot;, age: 25, email: &quot;taro@example.com&quot; }</span>
</code></pre></div>



</div>
</div>

<hr />
<h2 id="25-フォーム入力controlled-component">2.5 フォーム入力（controlled component）<a class="header-link" href="#25-フォーム入力controlled-component" title="Permanent link">&para;</a></h2>
<p>フォームの入力欄を state で管理する方法。<br />
設定画面や入力フォームで必須のパターン！</p>
<h3 id="基本-テキスト入力">基本: テキスト入力<a class="header-link" href="#基本-テキスト入力" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><code><span class="kd">function</span><span class="w"> </span><span class="nx">InputForm</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="p">[</span><span class="nx">text</span><span class="p">,</span><span class="w"> </span><span class="nx">setText</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">useState</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">);</span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="p">(</span>
<span class="w">    </span><span class="p">&lt;</span><span class="nt">div</span><span class="p">&gt;</span>
<span class="w">      </span><span class="p">&lt;</span><span class="nt">input</span>
<span class="w">        </span><span class="na">type</span><span class="o">=</span><span class="s">&quot;text&quot;</span>
<span class="w">        </span><span class="na">value</span><span class="o">=</span><span class="p">{</span><span class="nx">text</span><span class="p">}</span><span class="w">                           </span><span class="err">//</span><span class="w"> </span><span class="na">①</span><span class="w"> </span><span class="na">表示は</span><span class="w"> </span><span class="na">state</span><span class="w"> </span><span class="na">が正</span>
<span class="w">        </span><span class="na">onChange</span><span class="o">=</span><span class="p">{(</span><span class="nx">e</span><span class="p">)</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="nx">setText</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">target</span><span class="p">.</span><span class="nx">value</span><span class="p">)}</span><span class="w">  </span><span class="err">//</span><span class="w"> </span><span class="na">②</span><span class="w"> </span><span class="na">入力したら</span><span class="w"> </span><span class="na">state</span><span class="w"> </span><span class="na">更新</span>
<span class="w">      </span><span class="p">/&gt;</span>
<span class="w">      </span><span class="p">&lt;</span><span class="nt">p</span><span class="p">&gt;</span><span class="nx">入力内容</span><span class="o">:</span><span class="w"> </span><span class="p">{</span><span class="nx">text</span><span class="p">}&lt;/</span><span class="nt">p</span><span class="p">&gt;</span>
<span class="w">    </span><span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
<span class="w">  </span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>

<div class="flow-box">
<h3>🔄 controlled component の動き</h3>
<pre>
ユーザーが「あ」と入力
    ↓
onChange 発火 → setText("あ")
    ↓
state が "あ" に更新
    ↓
React が再レンダリング
    ↓
input の value="あ" で表示
</pre>
<p><strong>ポイント:</strong> state が「唯一の情報源（Single Source of Truth）」</p>
</div>

<h3 id="実践例-todoリストに追加">実践例: TODOリストに追加<a class="header-link" href="#実践例-todoリストに追加" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><code><span class="kd">function</span><span class="w"> </span><span class="nx">TodoApp</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="p">[</span><span class="nx">text</span><span class="p">,</span><span class="w"> </span><span class="nx">setText</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">useState</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">);</span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="p">[</span><span class="nx">todos</span><span class="p">,</span><span class="w"> </span><span class="nx">setTodos</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">useState</span><span class="p">&lt;</span><span class="nt">string</span><span class="err">[]</span><span class="p">&gt;([]);</span>

<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="nx">handleAdd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="nx">text</span><span class="p">.</span><span class="nx">trim</span><span class="p">())</span><span class="w"> </span><span class="k">return</span><span class="p">;</span><span class="w">  </span><span class="c1">// 空文字は追加しない</span>

<span class="w">    </span><span class="nx">setTodos</span><span class="p">(</span><span class="nx">prev</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">[...</span><span class="nx">prev</span><span class="p">,</span><span class="w"> </span><span class="nx">text</span><span class="p">]);</span><span class="w">  </span><span class="c1">// リストに追加</span>
<span class="w">    </span><span class="nx">setText</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">);</span><span class="w">                         </span><span class="c1">// 入力欄をクリア</span>
<span class="w">  </span><span class="p">};</span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="p">(</span>
<span class="w">    </span><span class="p">&lt;</span><span class="nt">div</span><span class="p">&gt;</span>
<span class="w">      </span><span class="p">&lt;</span><span class="nt">input</span>
<span class="w">        </span><span class="na">value</span><span class="o">=</span><span class="p">{</span><span class="nx">text</span><span class="p">}</span>
<span class="w">        </span><span class="na">onChange</span><span class="o">=</span><span class="p">{(</span><span class="nx">e</span><span class="p">)</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="nx">setText</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">target</span><span class="p">.</span><span class="nx">value</span><span class="p">)}</span>
<span class="w">        </span><span class="na">placeholder</span><span class="o">=</span><span class="s">&quot;やることを入力&quot;</span>
<span class="w">      </span><span class="p">/&gt;</span>
<span class="w">      </span><span class="p">&lt;</span><span class="nt">button</span><span class="w"> </span><span class="na">onClick</span><span class="o">=</span><span class="p">{</span><span class="nx">handleAdd</span><span class="p">}&gt;</span><span class="nx">追加</span><span class="p">&lt;/</span><span class="nt">button</span><span class="p">&gt;</span>

<span class="w">      </span><span class="p">&lt;</span><span class="nt">ul</span><span class="p">&gt;</span>
<span class="w">        </span><span class="p">{</span><span class="nx">todos</span><span class="p">.</span><span class="nx">map</span><span class="p">((</span><span class="nx">todo</span><span class="p">,</span><span class="w"> </span><span class="nx">index</span><span class="p">)</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">(</span>
<span class="w">          </span><span class="p">&lt;</span><span class="nt">li</span><span class="w"> </span><span class="na">key</span><span class="o">=</span><span class="p">{</span><span class="nx">index</span><span class="p">}&gt;{</span><span class="nx">todo</span><span class="p">}&lt;/</span><span class="nt">li</span><span class="p">&gt;</span>
<span class="w">        </span><span class="p">))}</span>
<span class="w">      </span><span class="p">&lt;/</span><span class="nt">ul</span><span class="p">&gt;</span>
<span class="w">    </span><span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
<span class="w">  </span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>

<div class="tip-box">
<h3>💡 フォームのポイントまとめ</h3>
<ul>
<li><strong>value={state}</strong>: 表示内容は state が決める</li>
<li><strong>onChange</strong>: 入力のたびに state を更新</li>
<li><strong>送信後は setText("")</strong>: 入力欄をクリア</li>
<li><strong>trim() でチェック</strong>: 空白だけの入力を防ぐ</li>
</ul>
</div>

<hr />
<h2 id="3-useeffect---副作用の処理">3. useEffect - 副作用の処理<a class="header-link" href="#3-useeffect---副作用の処理" title="Permanent link">&para;</a></h2>
<h3 id="まず副作用って何">まず「副作用」って何？<a class="header-link" href="#まず副作用って何" title="Permanent link">&para;</a></h3>
<div class="info-box">
<h3>🤔 副作用（Side Effect）とは</h3>
<p><strong>副作用 = 画面の描画以外の処理</strong></p>
<table>
<tr><th>画面描画（本業）</th><th>副作用（本業以外）</th></tr>
<tr><td>文字を表示する</td><td>サーバーからデータを取る</td></tr>
<tr><td>ボタンを表示する</td><td>ローカルストレージに保存</td></tr>
<tr><td>リストを表示する</td><td>タイマーを設定する</td></tr>
<tr><td>色を変える</td><td>イベントリスナーを登録</td></tr>
</table>
<p>💡 Reactコンポーネントの本業は「画面を描くこと」。<br>
それ以外の処理はすべて「副作用」と呼ぶ</p>
</div>

<h3 id="なぜ-useeffect-が必要なのか">なぜ useEffect が必要なのか？<a class="header-link" href="#なぜ-useeffect-が必要なのか" title="Permanent link">&para;</a></h3>
<div class="warning-box">
<h3>⚠️ useEffect なしで API を呼ぶとどうなる？</h3>
<div class="box-content">


<div class="codehilite"><pre><span></span><code><span class="c1">// ❌ 悪い例: useEffect なしで API を呼ぶ</span>
<span class="kd">function</span><span class="w"> </span><span class="nx">UserProfile</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="p">[</span><span class="nx">user</span><span class="p">,</span><span class="w"> </span><span class="nx">setUser</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">useState</span><span class="p">(</span><span class="kc">null</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// ここに書くと...</span>
<span class="w">  </span><span class="nx">fetch</span><span class="p">(</span><span class="s1">&#39;/api/user&#39;</span><span class="p">).</span><span class="nx">then</span><span class="p">(</span><span class="nx">data</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="nx">setUser</span><span class="p">(</span><span class="nx">data</span><span class="p">));</span><span class="w">  </span><span class="c1">// 無限ループ！</span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="p">&lt;</span><span class="nt">div</span><span class="p">&gt;{</span><span class="nx">user</span><span class="o">?</span><span class="p">.</span><span class="nx">name</span><span class="p">}&lt;/</span><span class="nt">div</span><span class="p">&gt;;</span>
<span class="p">}</span>
</code></pre></div>



<strong>何が起きる？</strong>
<pre>
① コンポーネント実行 → fetch() 呼ばれる
② setUser() で state 更新 → 再レンダリング発生
③ コンポーネント再実行 → fetch() また呼ばれる
④ setUser() で state 更新 → 再レンダリング発生
⑤ 無限ループ！！！💥
</pre>

<strong>useEffect を使う理由:</strong>
「画面が表示されたときに1回だけ」実行したいから

</div>
</div>

<h3 id="useeffect-の基本形">useEffect の基本形<a class="header-link" href="#useeffect-の基本形" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><code><span class="nx">useEffect</span><span class="p">(()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// ここに「やりたい処理」を書く</span>
<span class="p">},</span><span class="w"> </span><span class="p">[]);</span><span class="w">  </span><span class="c1">// ← これは「依存配列」</span>
</code></pre></div>

<div class="flow-box">
<h3>📝 useEffect の書き方</h3>
<pre>
useEffect(
  () => { ... },    ← 第1引数: 実行したい処理（関数）
  []                ← 第2引数: 依存配列（いつ実行するか）
);

依存配列の意味:
  []      → 最初の1回だけ実行（画面が表示されたとき）
  [userId] → userId が変わるたびに実行
  なし    → 毎回実行（ほぼ使わない）
</pre>
</div>

<h3 id="先に-promise-を理解しよう">先に Promise を理解しよう<a class="header-link" href="#先に-promise-を理解しよう" title="Permanent link">&para;</a></h3>
<p>useEffect の中で <code>fetch().then()</code> を使うので、先に Promise を理解しましょう。</p>
<div class="info-box">
<h3>⏳ Promise とは「約束」</h3>
<p><strong>Promise = 「あとで結果を教えるよ」という約束</strong></p>
<pre>
【レストランで例えると】

店員:「料理ができたらお呼びしますね」← これが Promise
    ↓
（あなたは待つ）
    ↓
店員:「できました！」← Promise が解決（resolve）
    ↓
あなた: 料理を受け取る ← .then() で結果を受け取る
</pre>
<p>サーバーとの通信は時間がかかるので「あとで結果を教える」仕組みが必要</p>
</div>

<h3 id="fetch-とは">fetch とは？<a class="header-link" href="#fetch-とは" title="Permanent link">&para;</a></h3>
<p><code>fetch</code> は <strong>バックエンドAPI にリクエストを送る関数</strong>です。</p>
<div class="codehilite"><pre><span></span><code><span class="c1">// このプロジェクトでの使用例</span>
<span class="nx">fetch</span><span class="p">(</span><span class="s1">&#39;/api/chat&#39;</span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">method</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;POST&#39;</span><span class="p">,</span><span class="w"> </span><span class="nx">body</span><span class="o">:</span><span class="w"> </span><span class="kt">JSON.stringify</span><span class="p">({</span><span class="w"> </span><span class="nx">message</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;こんにちは&#39;</span><span class="w"> </span><span class="p">})</span><span class="w"> </span><span class="p">})</span>
<span class="c1">//     ↑ Backend の API      ↑ AIにメッセージを送信</span>
</code></pre></div>

<p>フロントエンド（ブラウザ）→ バックエンド（サーバー）への通信に使います。</p>
<h3 id="promise-の返り値">Promise の返り値<a class="header-link" href="#promise-の返り値" title="Permanent link">&para;</a></h3>
<p><code>fetch</code> などの通信関数を呼ぶと、<strong>すぐには結果が返ってこない</strong>のがポイントです。</p>
<div class="codehilite"><pre><span></span><code><span class="c1">// ❌ こう書いても、result には Promise オブジェクトが入るだけ</span>
<span class="kd">const</span><span class="w"> </span><span class="nx">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">fetch</span><span class="p">(</span><span class="s1">&#39;/api/user&#39;</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">result</span><span class="p">);</span><span class="w">  </span><span class="c1">// Promise { &lt;pending&gt; } ← まだ結果がない！</span>

<span class="c1">// ✅ 結果を受け取るには .then() を使う</span>
<span class="nx">fetch</span><span class="p">(</span><span class="s1">&#39;/api/user&#39;</span><span class="p">).</span><span class="nx">then</span><span class="p">(</span><span class="nx">response</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">response</span><span class="p">);</span><span class="w">  </span><span class="c1">// ← ここで初めて結果が使える！</span>
<span class="p">});</span>
</code></pre></div>

<div class="warning-box">
<h3>⚠️ 初心者がハマるポイント</h3>
<p>Promise を返す関数（fetch など）は、<strong>呼んだ瞬間には結果が返ってこない</strong>。<br>
結果を使うには <code>.then()</code> の中で受け取る必要がある！</p>
</div>

<h3 id="then-の書き方">.then() の書き方<a class="header-link" href="#then-の書き方" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><code><span class="c1">// fetch() は Promise を返す</span>
<span class="nx">fetch</span><span class="p">(</span><span class="s1">&#39;/api/user&#39;</span><span class="p">)</span><span class="w">      </span><span class="c1">// ① サーバーにリクエスト送信（時間かかる）</span>
<span class="w">  </span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">response</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">   </span><span class="c1">// ② レスポンスが返ってきたら実行</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nx">response</span><span class="p">.</span><span class="nx">json</span><span class="p">();</span><span class="w">  </span><span class="c1">// JSON に変換（これも Promise）</span>
<span class="w">  </span><span class="p">})</span>
<span class="w">  </span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">data</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">       </span><span class="c1">// ③ JSON 変換が終わったら実行</span>
<span class="w">    </span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">data</span><span class="p">);</span><span class="w">  </span><span class="c1">// { name: &quot;太郎&quot;, age: 25 }</span>
<span class="w">  </span><span class="p">});</span>
</code></pre></div>

<div class="tip-box">
<h3>💡 引数名は自由につけてOK！</h3>
<p><code>.then(response => ...)</code> の <code>response</code> は<strong>ただの変数名</strong>です。好きな名前をつけられます。</p>
<pre>
// どれも同じ動作！
.then(response => { ... })  // よく使われる名前
.then(res => { ... })       // 省略形
.then(r => { ... })         // 短い名前
.then(なんでもOK => { ... }) // 日本語でも動く（非推奨）
</pre>
<p>ただし、<strong>何が入ってくるか分かりやすい名前</strong>をつけるのがベスト！<br>
fetch の結果なら <code>response</code>、JSONデータなら <code>data</code> など。</p>
</div>

<div class="flow-box">
<h3>🔄 .then() の処理の流れ</h3>
<pre>
fetch('/api/user')  ← サーバーにリクエスト（1〜2秒かかる）
        │
        │  待っている間、他の処理は続く
        ↓
    .then(response => ...)  ← レスポンス到着！ここが実行される
        │
        ↓
    .then(data => ...)  ← 次の処理

💡 ポイント: .then() は「終わったら次へ」を繋げていく
</pre>
</div>

<h3 id="useeffect--fetch-の完全な例">useEffect + fetch の完全な例<a class="header-link" href="#useeffect--fetch-の完全な例" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><code><span class="k">import</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">useState</span><span class="p">,</span><span class="w"> </span><span class="nx">useEffect</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="kr">from</span><span class="w"> </span><span class="s1">&#39;react&#39;</span><span class="p">;</span>

<span class="kd">function</span><span class="w"> </span><span class="nx">UserProfile</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="p">[</span><span class="nx">user</span><span class="p">,</span><span class="w"> </span><span class="nx">setUser</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">useState</span><span class="p">(</span><span class="kc">null</span><span class="p">);</span>

<span class="w">  </span><span class="nx">useEffect</span><span class="p">(()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// 画面が表示されたときに1回だけ実行</span>
<span class="w">    </span><span class="nx">fetch</span><span class="p">(</span><span class="s1">&#39;/api/user&#39;</span><span class="p">)</span>
<span class="w">      </span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">response</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="nx">response</span><span class="p">.</span><span class="nx">json</span><span class="p">())</span><span class="w">  </span><span class="c1">// JSON に変換</span>
<span class="w">      </span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">data</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nx">setUser</span><span class="p">(</span><span class="nx">data</span><span class="p">);</span><span class="w">  </span><span class="c1">// state を更新</span>
<span class="w">      </span><span class="p">});</span>
<span class="w">  </span><span class="p">},</span><span class="w"> </span><span class="p">[]);</span><span class="w">  </span><span class="c1">// [] = 最初の1回だけ</span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="p">&lt;</span><span class="nt">div</span><span class="p">&gt;{</span><span class="nx">user</span><span class="o">?</span><span class="p">.</span><span class="nx">name</span><span class="p">}&lt;/</span><span class="nt">div</span><span class="p">&gt;;</span>
<span class="p">}</span>
</code></pre></div>

<div class="architecture-box">
<h3>🔍 このコードを1行ずつ解説</h3>
<pre>
const [user, setUser] = useState(null);
       ↑         ↑              ↑
    現在値   更新関数      初期値（まだデータない）

useEffect(() => {
    ↑
  「画面が表示されたら実行して」という指示

  fetch('/api/user')
    ↑
  サーバーに「ユーザー情報ちょうだい」と依頼

    .then(response => response.json())
      │                    ↑
      │       返ってきたデータを JSON 形式に変換
      │
      │  📦 ここで返される値（JavaScript オブジェクト）が
      │     次の .then() の data に渡される！
      ↓
    .then(data => {
      setUser(data);  ← state を更新 → 画面が再描画される
    });

🔗 .then() チェーンのデータの流れ:

fetch('/api/user')
    │
    │ 返り値: Response オブジェクト（まだ JSON じゃない）
    ↓
.then(response => response.json())
    │
    │ 返り値: { name: "太郎", age: 25 }（JavaScript オブジェクト）
    │        ※ JSON文字列 → オブジェクトに変換済み
    ↓
.then(data => setUser(data))
    │
    │ data = { name: "太郎", age: 25 } ← 上の返り値がそのまま来る！
    │ これを setUser() に渡して state を更新
    ↓
  完了！画面が再描画される

}, []);
   ↑
 空配列 = 最初の1回だけ実行

return <div>{user?.name}</div>;
             ↑
           user が null の間は何も表示しない
           user にデータが入ったら名前を表示
</pre>
</div>

<h3 id="usestate-と-useeffect-はセットで使う">useState と useEffect はセットで使う<a class="header-link" href="#usestate-と-useeffect-はセットで使う" title="Permanent link">&para;</a></h3>
<div class="architecture-box">
<h3>ここまでのまとめ: 2つのフックは基本セットで使う</h3>
<div class="box-content">

<p>ここまで見てきたように、<strong>useState と useEffect は基本的にセットで使います。</strong><br>
単独で使うケースは少なく、「データを保持する useState」と「処理を実行する useEffect」を組み合わせることで初めて意味のある機能になります。</p>

<p><strong>【なぜセットで使う？】</strong></p>
<table>
<tr><th>useState だけ</th><th>useEffect だけ</th><th>両方組み合わせ</th></tr>
<tr><td>データを持てるが、<br>いつ取得するか決められない</td><td>処理を実行できるが、<br>結果を保存できない</td><td>「いつ」「何を」「どこに保存」<br>すべてコントロール可能！</td></tr>
</table>

<p><strong>【よくあるパターン】</strong></p>
<ol>
<li><strong>画面表示時にデータ取得</strong>: useEffect で API 呼び出し → useState で保存 → 画面に表示</li>
<li><strong>state 変更で別処理を実行</strong>: useState の値が変わったら → useEffect で別の API を呼ぶ</li>
<li><strong>画面が消えたら後片付け</strong>: useEffect のクリーンアップでタイマー停止など</li>
</ol>

<p>💡 この「useState + useEffect のセット」を再利用しやすくまとめたものが、次に学ぶ「カスタムフック」です！</p>

</div>
</div>

<h3 id="username-の意味オプショナルチェーン">user?.name の意味（オプショナルチェーン）<a class="header-link" href="#username-の意味オプショナルチェーン" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><code><span class="c1">// user?.name は以下と同じ意味</span>
<span class="nx">user</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="nx">user.name</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">undefined</span>

<span class="c1">// もし user が null や undefined だったら、</span>
<span class="c1">// .name にアクセスせず undefined を返す</span>
<span class="c1">// → エラーにならない！</span>
</code></pre></div>

<h3 id="asyncawait-で書き直すより読みやすい">async/await で書き直す（より読みやすい）<a class="header-link" href="#asyncawait-で書き直すより読みやすい" title="Permanent link">&para;</a></h3>
<p><code>.then()</code> の代わりに <code>async/await</code> を使うと読みやすくなります。</p>
<div class="codehilite"><pre><span></span><code><span class="nx">useEffect</span><span class="p">(()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// 内部で async 関数を定義して即実行</span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="nx">fetchData</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">async</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">const</span><span class="w"> </span><span class="nx">response</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">await</span><span class="w"> </span><span class="nx">fetch</span><span class="p">(</span><span class="s1">&#39;/api/user&#39;</span><span class="p">);</span><span class="w">  </span><span class="c1">// 待つ</span>
<span class="w">    </span><span class="kd">const</span><span class="w"> </span><span class="nx">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">await</span><span class="w"> </span><span class="nx">response</span><span class="p">.</span><span class="nx">json</span><span class="p">();</span><span class="w">         </span><span class="c1">// 待つ</span>
<span class="w">    </span><span class="nx">setUser</span><span class="p">(</span><span class="nx">data</span><span class="p">);</span>
<span class="w">  </span><span class="p">};</span>

<span class="w">  </span><span class="nx">fetchData</span><span class="p">();</span><span class="w">  </span><span class="c1">// 実行</span>
<span class="p">},</span><span class="w"> </span><span class="p">[]);</span>
</code></pre></div>

<div class="tip-box">
<h3>💡 .then() と async/await は同じこと</h3>
<pre>
【.then() 版】
fetch('/api/user')
  .then(response => response.json())
  .then(data => setUser(data));

【async/await 版】
const response = await fetch('/api/user');
const data = await response.json();
setUser(data);

どちらも「終わるまで待つ」を表現している
async/await の方が「上から順に読める」ので読みやすい
</pre>
</div>

<h3 id="依存配列のパターン">依存配列のパターン<a class="header-link" href="#依存配列のパターン" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><code><span class="c1">// パターン1: 最初の1回だけ実行（一番よく使う）</span>
<span class="nx">useEffect</span><span class="p">(()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">&quot;画面が表示されたときに1回だけ&quot;</span><span class="p">);</span>
<span class="p">},</span><span class="w"> </span><span class="p">[]);</span><span class="w">  </span><span class="c1">// 空配列 = 1回だけ</span>

<span class="c1">// パターン2: 特定の値が変わったら実行</span>
<span class="nx">useEffect</span><span class="p">(()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">&quot;userId が変わったから、データを取り直す&quot;</span><span class="p">);</span>
<span class="w">  </span><span class="nx">fetchUserData</span><span class="p">(</span><span class="nx">userId</span><span class="p">);</span>
<span class="p">},</span><span class="w"> </span><span class="p">[</span><span class="nx">userId</span><span class="p">]);</span><span class="w">  </span><span class="c1">// userId が変わるたびに実行</span>

<span class="c1">// パターン3: 毎回実行（ほぼ使わない）</span>
<span class="nx">useEffect</span><span class="p">(()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">&quot;レンダリングのたびに実行&quot;</span><span class="p">);</span>
<span class="p">});</span><span class="w">  </span><span class="c1">// 依存配列なし = 毎回</span>

<span class="c1">// パターン4: クリーンアップ関数付き（後で詳しく解説）</span>
<span class="nx">useEffect</span><span class="p">(()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="nx">timer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">setInterval</span><span class="p">(()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;tick&#39;</span><span class="p">),</span><span class="w"> </span><span class="mf">1000</span><span class="p">);</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">clearInterval</span><span class="p">(</span><span class="nx">timer</span><span class="p">);</span><span class="w"> </span><span class="p">};</span>
<span class="p">},</span><span class="w"> </span><span class="p">[]);</span>
</code></pre></div>

<div class="info-box">
<h3>🎯 useEffect のライフサイクル（重要！）</h3>
<p>コンポーネントの一生:</p>
<pre>
[マウント] ─────→ [更新] ─────→ [更新] ─────→ [アンマウント]
    ↓                ↓            ↓                ↓
useEffect        依存配列の     依存配列の      クリーンアップ
実行             値が変わった   値が変わった      関数実行
                 ら再実行       ら再実行
</pre>
<ul>
<li><strong>マウント</strong> = 画面に表示されたとき</li>
<li><strong>アンマウント</strong> = 画面から消えたとき（別ページに移動など）</li>
<li><strong>クリーンアップ</strong> = タイマー停止、イベント解除など後片付け</li>
</ul>
<p><strong>💡 <code>return</code> で関数を返すと、React が「画面から消えるとき」に自動で呼び出してくれる！</strong></p>
</div>

<div class="warning-box">
<h3>🧹 クリーンアップ関数とは？（超重要！）</h3>
<div class="box-content">

<strong>クリーンアップ = 後片付け</strong>

useEffect の中で「return で関数を返す」と、その関数が「後片付け処理」になります。

<pre><code class="tsx">useEffect(() => {
  // ① 画面表示時に実行される処理
  const timer = setInterval(...);

  // ② return で「後片付け処理」を登録
  return () => {
    clearInterval(timer);  // 画面が消えるときに実行される
  };
}, []);
</code></pre>

<strong>なぜ return なのか？</strong>

<pre>
【普通の return】
function add(a, b) {
  return a + b;  // 計算結果を返す
}

【useEffect の return】
useEffect(() => {
  ...
  return () => { ... };  // 「後で実行してほしい関数」を返す
});
</pre>

useEffect の return は「Reactへの依頼」です：
<ul>
<li>「この関数を受け取っておいて」</li>
<li>「画面が消えるときに呼び出してね」</li>
</ul>

<strong>図解: return で関数を渡す仕組み</strong>

<pre>
【画面表示時】
useEffect(() => {
  const timer = setInterval(...);
  return () => { clearInterval(timer); };
});
        ↓
React: 「OK、この関数を保存しておくね」
        ↓
React が内部で関数を保持

【画面が消えるとき】
React: 「保存しておいた関数を実行！」
        ↓
() => { clearInterval(timer); }  ← 実行される！
        ↓
タイマーが停止される ✅
</pre>

<strong>ポイント: <code>return</code> の後ろはカッコなし！</strong>

<pre>
return () => { clearInterval(timer); }   ✅ 関数を返す（正解）
       ↑
       関数そのものを渡す

return clearInterval(timer)              ❌ 今すぐ実行してしまう
       ↑
       関数を「呼び出した結果」を返す
</pre>

💡 詳しくは上の「<a href="#-pythonエンジニア向け-アロー関数の基礎">アロー関数の基礎</a>」の <code>inner</code> と <code>inner()</code> の違いを参照！

</div>
</div>

<hr />
<details>
<summary><strong>☕ ブレイクタイム: パターン4を徹底解説</strong>（クリックで展開）</summary>

パターン4が難しいと感じる人が多いので、ここで丁寧に解説します。

**まず、コードの構造を分解してみましょう:**


<div class="codehilite"><pre><span></span><code><span class="nx">useEffect</span><span class="p">(</span><span class="w">           </span><span class="c1">// ← useEffect を呼び出す</span>
<span class="w">  </span><span class="p">()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">            </span><span class="c1">// ← 第1引数: 関数（エフェクト本体）</span>
<span class="w">    </span><span class="c1">// ここが「画面表示時」に実行される部分</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">   </span><span class="c1">// ← クリーンアップ関数を返す</span>
<span class="w">      </span><span class="c1">// ここが「画面から消える時」に実行される部分</span>
<span class="w">    </span><span class="p">};</span>
<span class="w">  </span><span class="p">},</span>
<span class="w">  </span><span class="p">[]</span><span class="w">                 </span><span class="c1">// ← 第2引数: 依存配列（空 = 初回のみ）</span>
<span class="p">);</span>
</code></pre></div>



**図で見ると:**

<div style="background: #1e293b; border-radius: 8px; padding: 20px; font-family: monospace; color: #e2e8f0; display: flex; align-items: flex-start; gap: 8px;">
  <div style="color: #94a3b8;">useEffect(</div>
  <div style="border: 2px solid #64748b; border-radius: 6px; padding: 12px; flex: 1;">
    <div style="color: #f8fafc;">() =&gt; {</div>
    <div style="padding-left: 20px; margin: 8px 0;">
      <div style="color: #94a3b8;">① 画面表示時の処理</div>
      <div style="color: #f8fafc;">const timer = setInterval(...);</div>
    </div>
    <div style="padding-left: 20px; margin-top: 12px;">
      <div style="color: #f8fafc;">return () =&gt; {</div>
      <div style="padding-left: 20px;">
        <div style="color: #94a3b8;">② 画面消去時の処理</div>
        <div style="color: #f8fafc;">clearInterval(timer);</div>
      </div>
      <div style="color: #f8fafc;">};</div>
    </div>
    <div style="color: #f8fafc; margin-top: 8px;">}</div>
  </div>
  <div style="color: #94a3b8;">, []);</div>
  <div style="margin-left: 12px; font-size: 0.9em;">
    <div style="color: #fbbf24; margin-bottom: 40px;">← 関数を「定義」している<br>　（実行ではない！）</div>
    <div style="color: #fbbf24;">← 関数を返す<br>　（まだ実行しない！）</div>
  </div>
</div>

<div class="warning-box">
<h3>⚠️ 「() => {}」が紛らわしい理由</h3>

<strong>Q: <code>() =&gt; { clearInterval(timer); }</code> って、実行してるんじゃないの？</strong>

A: <strong>いいえ！これは「関数を定義している」だけです。</strong>

`() => {}` は「実行している」ように見えますが、実は「関数を作っている」だけ。
関数を実行するには、関数自体の後ろに `()` をつける必要があります。

<pre>
【比較してみよう】

clearInterval;           ← ❌ 実行されない（関数の参照だけ）
clearInterval(timer);    ← ✅ 実行される（引数付きで呼び出し）

() => { clearInterval(timer); }      ← ❌ 関数を「定義」しているだけ
(() => { clearInterval(timer); })()  ← ✅ 関数を定義して「即実行」（IIFE）
                                ↑↑
                     この () で実行！

💡 つまり (() => { clearInterval(timer); })() は
   clearInterval(timer); と同じ結果になる！
   （わざわざ関数で包んで即実行 = 直接実行と等価）
</pre>

<strong>つまり:</strong>

<table>
<tr><th>書き方</th><th>何をしている？</th><th>実行タイミング</th></tr>
<tr><td><code>clearInterval(timer)</code></td><td>関数を呼び出す</td><td><strong>今すぐ</strong>実行</td></tr>
<tr><td><code>() =&gt; { clearInterval(timer); }</code></td><td>関数を作る</td><td><strong>まだ</strong>実行されない</td></tr>
<tr><td><code>return () =&gt; { ... }</code></td><td>関数を作って返す</td><td><strong>後で</strong>誰かが呼ぶと実行</td></tr>
</table>

<strong>だから useEffect の return は:</strong>


<div class="codehilite"><pre><span></span><code><span class="k">return</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">clearInterval</span><span class="p">(</span><span class="nx">timer</span><span class="p">);</span><span class="w"> </span><span class="p">};</span>
<span class="c1">//     ↑</span>
<span class="c1">//     「実行の仕方」を返している（関数を返す）</span>
<span class="c1">//     「実行した結果」を返しているわけではない！</span>
</code></pre></div>



Reactはこの「実行の仕方」を受け取って保存し、画面が消えるときに呼び出します。

💡 <strong>詳しくは上の「<a href="#-pythonエンジニア向け-アロー関数の基礎">アロー関数の基礎</a>」を参照！</strong>

</div>

---

**実際のタイマーの例:**


<div class="codehilite"><pre><span></span><code><span class="nx">useEffect</span><span class="p">(()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// ① 画面表示時: タイマー開始</span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="nx">timer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">setInterval</span><span class="p">(()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">fetchNewMessages</span><span class="p">();</span><span class="w">  </span><span class="c1">// 1秒ごとに新着確認</span>
<span class="w">  </span><span class="p">},</span><span class="w"> </span><span class="mf">1000</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// ② 画面消去時: タイマー停止</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">clearInterval</span><span class="p">(</span><span class="nx">timer</span><span class="p">);</span>
<span class="w">  </span><span class="p">};</span>
<span class="p">},</span><span class="w"> </span><span class="p">[]);</span>
</code></pre></div>



<div class="warning-box">
<h3>⚠️ よくある疑問: setInterval は「完了」しないの？</h3>

<strong>Q: setInterval が動き続けるなら、次の行（return）に到達しないのでは？</strong>

A: <strong>いいえ、到達します！</strong> setInterval は <strong>非同期</strong> だからです。

<pre>
【誤解しやすいイメージ】（❌ 間違い）

const timer = setInterval(...);  ← ここで1秒待機...?
return () => { ... };            ← setIntervalが終わるまで到達しない...?
</pre>

<pre>
【実際の動き】（✅ 正解）

const timer = setInterval(...);  ← 「予約だけ」して即座に次へ進む！
return () => { ... };            ← すぐにここに到達する！
</pre>

<strong>setInterval は「内部でwhileループで待機」しているわけではありません。</strong>

<table>
<tr><th>イメージ</th><th>実際の動作</th></tr>
<tr><td>❌ whileループで待つ<br>（ブロッキング）</td><td>✅ 予約だけして即座に戻る<br>（ノンブロッキング）</td></tr>
<tr><td>❌ setInterval完了まで待機</td><td>✅ ブラウザのタイマーに「後で呼んで」と依頼するだけ</td></tr>
</table>

</div>

**時系列で見ると:**

<pre>
ユーザーがチャット画面を開く
    ↓
useEffect の関数が実行される
    ↓
① const timer = setInterval(...)
   → ブラウザ:「1秒ごとに呼ぶね」と予約（即座に完了）
    ↓
② return () => { clearInterval(timer); }
   → クリーンアップ関数をReactに渡す（即座に完了）
    ↓
useEffect 完了！（ここまで一瞬）
    ↓
〜〜〜 バックグラウンドでタイマーが動く 〜〜〜
    ↓
1秒後: fetchNewMessages() 実行
2秒後: fetchNewMessages() 実行
3秒後: fetchNewMessages() 実行
... （ずっと続く）
    ↓
ユーザーが設定画面に移動
    ↓
Reactが return の関数を実行
    ↓
clearInterval(timer) でタイマー停止
    ↓
もう fetchNewMessages() は呼ばれない ✅
</pre>

</details>

<h3 id="実践例-ローディング状態の管理">実践例: ローディング状態の管理<a class="header-link" href="#実践例-ローディング状態の管理" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><code><span class="kd">function</span><span class="w"> </span><span class="nx">UserProfile</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="p">[</span><span class="nx">user</span><span class="p">,</span><span class="w"> </span><span class="nx">setUser</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">useState</span><span class="p">(</span><span class="kc">null</span><span class="p">);</span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="p">[</span><span class="nx">loading</span><span class="p">,</span><span class="w"> </span><span class="nx">setLoading</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">useState</span><span class="p">(</span><span class="kc">true</span><span class="p">);</span><span class="w">   </span><span class="c1">// ローディング中か？（true = 読み込み中）</span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="p">[</span><span class="nx">error</span><span class="p">,</span><span class="w"> </span><span class="nx">setError</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">useState</span><span class="p">(</span><span class="kc">null</span><span class="p">);</span><span class="w">       </span><span class="c1">// エラーメッセージ（なければ null）</span>

<span class="w">  </span><span class="nx">useEffect</span><span class="p">(()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">fetch</span><span class="p">(</span><span class="s1">&#39;/api/user&#39;</span><span class="p">)</span>
<span class="w">      </span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">response</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// response.ok = HTTPステータスが 200-299 なら true</span>
<span class="w">        </span><span class="c1">// !response.ok = 失敗（404, 500 など）なら true</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="nx">response</span><span class="p">.</span><span class="nx">ok</span><span class="p">)</span><span class="w"> </span><span class="k">throw</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="ne">Error</span><span class="p">(</span><span class="s1">&#39;取得失敗&#39;</span><span class="p">);</span><span class="w">  </span><span class="c1">// ← エラーを投げて .catch へ飛ばす</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nx">response</span><span class="p">.</span><span class="nx">json</span><span class="p">();</span><span class="w">  </span><span class="c1">// JSONをパースして次の .then へ</span>
<span class="w">      </span><span class="p">})</span>
<span class="w">      </span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">data</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nx">setUser</span><span class="p">(</span><span class="nx">data</span><span class="p">);</span>
<span class="w">        </span><span class="nx">setLoading</span><span class="p">(</span><span class="kc">false</span><span class="p">);</span><span class="w">  </span><span class="c1">// ローディング終了（false = もう読み込み中じゃない）</span>
<span class="w">      </span><span class="p">})</span>
<span class="w">      </span><span class="p">.</span><span class="k">catch</span><span class="p">(</span><span class="nx">err</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// ↑ の throw や、通信エラーがここに来る</span>
<span class="w">        </span><span class="nx">setError</span><span class="p">(</span><span class="nx">err</span><span class="p">.</span><span class="nx">message</span><span class="p">);</span><span class="w">  </span><span class="c1">// err.message = &quot;取得失敗&quot; など</span>
<span class="w">        </span><span class="nx">setLoading</span><span class="p">(</span><span class="kc">false</span><span class="p">);</span><span class="w">      </span><span class="c1">// エラーでも読み込みは終了</span>
<span class="w">      </span><span class="p">});</span>
<span class="w">  </span><span class="p">},</span><span class="w"> </span><span class="p">[]);</span>

<span class="w">  </span><span class="c1">// 状態に応じて表示を切り替え</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">loading</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="p">&lt;</span><span class="nt">div</span><span class="p">&gt;</span><span class="nx">読み込み中</span><span class="p">...&lt;/</span><span class="nt">div</span><span class="p">&gt;;</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">error</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="p">&lt;</span><span class="nt">div</span><span class="p">&gt;</span><span class="nx">エラー</span><span class="o">:</span><span class="w"> </span><span class="p">{</span><span class="nx">error</span><span class="p">}&lt;/</span><span class="nt">div</span><span class="p">&gt;;</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="p">&lt;</span><span class="nt">div</span><span class="p">&gt;{</span><span class="nx">user</span><span class="p">.</span><span class="nx">name</span><span class="p">}&lt;/</span><span class="nt">div</span><span class="p">&gt;;</span>
<span class="p">}</span>
</code></pre></div>

<div class="tip-box">
<h3>💡 loading = true は「読み込み中」という意味</h3>

<strong>Q: 「ローディング中をtrueにする」って変じゃない？</strong>

A: これは<strong>フラグ（旗）</strong>の考え方です。

<pre>
loading = true   → 「ローディング中フラグが立っている」→ 読み込み中
loading = false  → 「ローディング中フラグが下りている」→ 読み込み完了
</pre>

<strong>実際の開発でもこの書き方が標準です：</strong>
<ul>
<li><code>isLoading</code> や <code>loading</code> という名前で「〜中かどうか」を表す</li>
<li><code>true</code> = その状態である、<code>false</code> = その状態ではない</li>
</ul>

<pre><code class="tsx">// よく見るパターン
const [isLoading, setIsLoading] = useState(true);   // 読み込み中？
const [isOpen, setIsOpen] = useState(false);        // モーダルが開いている？
const [isSubmitting, setIsSubmitting] = useState(false);  // 送信中？
</code></pre>

</div>

<hr />
<h2 id="4-カスタムフック---ロジックの再利用">4. カスタムフック - ロジックの再利用<a class="header-link" href="#4-カスタムフック---ロジックの再利用" title="Permanent link">&para;</a></h2>
<div class="architecture-box">
<h3>ここまでの流れ: useState → useEffect → カスタムフック</h3>
<div class="box-content">

<p><strong>Step 1: useState で状態を持つ</strong></p>
<pre><code class="typescript">const [user, setUser] = useState(null);
const [loading, setLoading] = useState(true);
const [error, setError] = useState(null);</code></pre>

<p><strong>Step 2: useEffect で画面表示時にAPIを呼ぶ</strong></p>
<pre><code class="typescript">useEffect(() => {
  fetchUser()
    .then(data => {
      setUser(data);
      setLoading(false);
    })
    .catch(err => {
      setError(err);
      setLoading(false);
    });
}, []);</code></pre>

<p style="margin-top: 20px;"><strong>❌ 問題: 同じコードを何度も書くことになる！</strong></p>

<p>例えば「ユーザー情報」が必要な画面が複数あると...</p>

<pre><code class="typescript">// プロフィール画面
function ProfilePage() {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    fetchUser().then(data => { setUser(data); setLoading(false); })
      .catch(err => { setError(err); setLoading(false); });
  }, []);

  // ... 画面の表示処理
}

// 設定画面
function SettingsPage() {
  const [user, setUser] = useState(null);       // ← また同じ3行...
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {                              // ← また同じ処理...
    fetchUser().then(data => { setUser(data); setLoading(false); })
      .catch(err => { setError(err); setLoading(false); });
  }, []);

  // ... 画面の表示処理
}

// チャット画面でも同じコードが必要...</code></pre>

<p style="text-align:center; font-size:1.2em; margin: 20px 0;">↓ <strong>これを解決するのがカスタムフック！</strong></p>

<p><strong>Step 3: カスタムフックでまとめる</strong></p>
<pre><code class="typescript">// 「ユーザー認証」のロジックを1箇所にまとめる
function useAuth() {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    fetchUser()
      .then(data => { setUser(data); setLoading(false); })
      .catch(err => { setError(err); setLoading(false); });
  }, []);

  return { user, loading, error };  // ← まとめて返す
}</code></pre>

<p style="text-align:center; font-size:1.2em; margin: 20px 0;">↓ <strong>使う側はたった1行！</strong></p>

<pre><code class="typescript">// プロフィール画面
function ProfilePage() {
  const { user, loading, error } = useAuth();  // ← これだけ！
  // ... 画面の表示処理
}

// 設定画面
function SettingsPage() {
  const { user, loading, error } = useAuth();  // ← これだけ！
  // ... 画面の表示処理
}</code></pre>

<table style="margin-top: 20px;">
<tr><th>カスタムフックなし</th><th>カスタムフックあり</th></tr>
<tr><td>画面ごとに10行以上のコード</td><td>たった1行</td></tr>
<tr><td>修正があれば全画面を直す</td><td>useAuth.ts を1箇所直すだけ</td></tr>
<tr><td>コピペでバグが生まれやすい</td><td>ロジックが1箇所にまとまって安全</td></tr>
</table>

</div>
</div>

<h3 id="カスタムフックとは">カスタムフックとは？<a class="header-link" href="#カスタムフックとは" title="Permanent link">&para;</a></h3>
<p><code>use</code> で始まる関数。useState や useEffect を組み合わせて、<br />
<strong>よく使う処理をまとめて、分かりやすい名前をつける</strong>ことができます。</p>
<h3 id="ステップ1-まずデフォルト引数を理解しよう">ステップ1: まずデフォルト引数を理解しよう<a class="header-link" href="#ステップ1-まずデフォルト引数を理解しよう" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><code><span class="kd">function</span><span class="w"> </span><span class="nx">useCounter</span><span class="p">(</span><span class="nx">initialValue</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="c1">//                              ↑</span>
<span class="c1">//              「引数が渡されなかったら 0 を使う」という意味</span>
</code></pre></div>

<table>
<thead>
<tr>
<th>呼び出し方</th>
<th>initialValue の値</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>useCounter()</code></td>
<td><code>0</code>（デフォルト）</td>
</tr>
<tr>
<td><code>useCounter(5)</code></td>
<td><code>5</code></td>
</tr>
<tr>
<td><code>useCounter(100)</code></td>
<td><code>100</code></td>
</tr>
</tbody>
</table>
<h3 id="ステップ2-カスタムフックの中身を理解しよう">ステップ2: カスタムフックの中身を理解しよう<a class="header-link" href="#ステップ2-カスタムフックの中身を理解しよう" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><code><span class="kd">function</span><span class="w"> </span><span class="nx">useCounter</span><span class="p">(</span><span class="nx">initialValue</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// ① useState で状態を作る</span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="p">[</span><span class="nx">count</span><span class="p">,</span><span class="w"> </span><span class="nx">setCount</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">useState</span><span class="p">(</span><span class="nx">initialValue</span><span class="p">);</span>
<span class="w">  </span><span class="c1">//     ↑</span>
<span class="w">  </span><span class="c1">//     count は「現在の数値」（0, 1, 2...）← 関数ではなく値！</span>

<span class="w">  </span><span class="c1">// ② setCount を「使いやすくラップした関数」を作る</span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="nx">increment</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="nx">setCount</span><span class="p">(</span><span class="nx">count</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mf">1</span><span class="p">);</span><span class="w">  </span><span class="c1">// +1 専用</span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="nx">decrement</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="nx">setCount</span><span class="p">(</span><span class="nx">count</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mf">1</span><span class="p">);</span><span class="w">  </span><span class="c1">// -1 専用</span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="nx">reset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="nx">setCount</span><span class="p">(</span><span class="nx">initialValue</span><span class="p">);</span><span class="w">   </span><span class="c1">// リセット専用</span>

<span class="w">  </span><span class="c1">// ③ 値と関数をまとめて返す</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">count</span><span class="p">,</span><span class="w"> </span><span class="nx">increment</span><span class="p">,</span><span class="w"> </span><span class="nx">decrement</span><span class="p">,</span><span class="w"> </span><span class="nx">reset</span><span class="w"> </span><span class="p">};</span>
<span class="p">}</span>
</code></pre></div>

<div class="info-box">
<h3>💡 なぜ increment, decrement, reset を作るの？</h3>
<p><code>setCount</code> を直接使うこともできますが、ラップ関数を作ると便利です。</p>
<pre>
setCount（React の基本機能）
    │
    ├─→ increment = () => setCount(count + 1)  ← +1専用に強化
    │
    ├─→ decrement = () => setCount(count - 1)  ← -1専用に強化
    │
    └─→ reset = () => setCount(initialValue)   ← リセット専用に強化
</pre>
<p><strong>メリット:</strong> 使う側が「+1って何だっけ？」と考えなくていい。<code>increment</code> という意味のある名前で呼べる！</p>
</div>

<h3 id="ステップ3-返り値を理解しよう">ステップ3: 返り値を理解しよう<a class="header-link" href="#ステップ3-返り値を理解しよう" title="Permanent link">&para;</a></h3>
<p><code>return { count, increment, decrement, reset }</code> で返しているものを整理：</p>
<table>
<thead>
<tr>
<th>名前</th>
<th>型</th>
<th>中身の例</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>count</code></td>
<td><strong>数値</strong></td>
<td><code>0</code>, <code>1</code>, <code>2</code>...</td>
</tr>
<tr>
<td><code>increment</code></td>
<td><strong>関数</strong></td>
<td><code>() =&gt; setCount(count + 1)</code></td>
</tr>
<tr>
<td><code>decrement</code></td>
<td><strong>関数</strong></td>
<td><code>() =&gt; setCount(count - 1)</code></td>
</tr>
<tr>
<td><code>reset</code></td>
<td><strong>関数</strong></td>
<td><code>() =&gt; setCount(initialValue)</code></td>
</tr>
</tbody>
</table>
<div class="warning-box">
<h3>⚠️ 注意: count は関数ではなく「値」！</h3>
<p><code>increment</code>, <code>decrement</code>, <code>reset</code> は関数ですが、<code>count</code> は<strong>ただの数値</strong>です。</p>
</div>

<h3 id="ステップ4-使う側を理解しよう分割代入">ステップ4: 使う側を理解しよう（分割代入）<a class="header-link" href="#ステップ4-使う側を理解しよう分割代入" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><code><span class="kd">const</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">count</span><span class="p">,</span><span class="w"> </span><span class="nx">increment</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">useCounter</span><span class="p">(</span><span class="mf">0</span><span class="p">);</span>
</code></pre></div>

<p>これは<strong>分割代入</strong>という書き方です。以下と同じ意味：</p>
<div class="codehilite"><pre><span></span><code><span class="c1">// ステップ1: useCounter(0) を呼ぶと、オブジェクトが返ってくる</span>
<span class="kd">const</span><span class="w"> </span><span class="nx">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">useCounter</span><span class="p">(</span><span class="mf">0</span><span class="p">);</span>
<span class="c1">// result = { count: 0, increment: [関数], decrement: [関数], reset: [関数] }</span>

<span class="c1">// ステップ2: 必要なものだけ取り出す</span>
<span class="kd">const</span><span class="w"> </span><span class="nx">count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">result</span><span class="p">.</span><span class="nx">count</span><span class="p">;</span><span class="w">           </span><span class="c1">// 0</span>
<span class="kd">const</span><span class="w"> </span><span class="nx">increment</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">result</span><span class="p">.</span><span class="nx">increment</span><span class="p">;</span><span class="w">   </span><span class="c1">// +1する関数</span>
</code></pre></div>

<p>この2ステップを <strong>1行で書ける</strong> のが分割代入：</p>
<div class="codehilite"><pre><span></span><code><span class="kd">const</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">count</span><span class="p">,</span><span class="w"> </span><span class="nx">increment</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">useCounter</span><span class="p">(</span><span class="mf">0</span><span class="p">);</span>
<span class="c1">//      ↑      ↑</span>
<span class="c1">//      必要なものだけ名前で取り出す（decrement, reset は使わないから書かない）</span>
</code></pre></div>

<h3 id="ステップ5-実際に使ってみよう">ステップ5: 実際に使ってみよう<a class="header-link" href="#ステップ5-実際に使ってみよう" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><code><span class="c1">// 使う側A</span>
<span class="kd">function</span><span class="w"> </span><span class="nx">ComponentA</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">count</span><span class="p">,</span><span class="w"> </span><span class="nx">increment</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">useCounter</span><span class="p">(</span><span class="mf">0</span><span class="p">);</span>
<span class="w">  </span><span class="c1">//             ↑ decrement, reset は使わないから取り出さない</span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="p">&lt;</span><span class="nt">button</span><span class="w"> </span><span class="na">onClick</span><span class="o">=</span><span class="p">{</span><span class="nx">increment</span><span class="p">}&gt;{</span><span class="nx">count</span><span class="p">}&lt;/</span><span class="nt">button</span><span class="p">&gt;;</span>
<span class="w">  </span><span class="c1">//              ↑ 関数          ↑ 値（数値）</span>
<span class="p">}</span>

<span class="c1">// 使う側B</span>
<span class="kd">function</span><span class="w"> </span><span class="nx">ComponentB</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">count</span><span class="p">,</span><span class="w"> </span><span class="nx">increment</span><span class="p">,</span><span class="w"> </span><span class="nx">reset</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">useCounter</span><span class="p">(</span><span class="mf">100</span><span class="p">);</span>
<span class="w">  </span><span class="c1">//                        ↑ reset も使うから取り出す</span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="p">(</span>
<span class="w">    </span><span class="p">&lt;</span><span class="nt">div</span><span class="p">&gt;</span>
<span class="w">      </span><span class="p">&lt;</span><span class="nt">span</span><span class="p">&gt;{</span><span class="nx">count</span><span class="p">}&lt;/</span><span class="nt">span</span><span class="p">&gt;</span><span class="w">           </span><span class="p">{</span><span class="cm">/* ← 値をそのまま表示 */</span><span class="p">}</span>
<span class="w">      </span><span class="p">&lt;</span><span class="nt">button</span><span class="w"> </span><span class="na">onClick</span><span class="o">=</span><span class="p">{</span><span class="nx">increment</span><span class="p">}&gt;</span><span class="o">+</span><span class="p">&lt;/</span><span class="nt">button</span><span class="p">&gt;</span><span class="w">  </span><span class="p">{</span><span class="cm">/* ← 関数を実行 */</span><span class="p">}</span>
<span class="w">      </span><span class="p">&lt;</span><span class="nt">button</span><span class="w"> </span><span class="na">onClick</span><span class="o">=</span><span class="p">{</span><span class="nx">reset</span><span class="p">}&gt;</span><span class="nx">リセット</span><span class="p">&lt;/</span><span class="nt">button</span><span class="p">&gt;</span>
<span class="w">    </span><span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
<span class="w">  </span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>

<div class="tip-box">
<h3>✨ カスタムフックのメリット</h3>
<ol>
<li><strong>ロジックの再利用</strong><br>同じ処理を複数のコンポーネントで使い回せる</li>
<li><strong>コンポーネントがスッキリ</strong><br>複雑なロジックをフックに分離 → コンポーネントは表示に専念</li>
<li><strong>分かりやすい名前</strong><br><code>setCount(count + 1)</code> より <code>increment</code> の方が意図が明確</li>
</ol>
<p>⚠️ ルール:</p>
<ul>
<li>名前は必ず use で始める（例: useAuth, useChat）</li>
<li>フックはトップレベルでのみ呼び出す（if文の中はダメ）</li>
</ul>
</div>

<hr />
<h2 id="5-apptsx---アプリのメインコンポーネント">5. App.tsx - アプリのメインコンポーネント<a class="header-link" href="#5-apptsx---アプリのメインコンポーネント" title="Permanent link">&para;</a></h2>
<p>このアプリの「親玉」。全体の流れを管理します。</p>
<h3 id="まずインポートを理解しよう">まずインポートを理解しよう<a class="header-link" href="#まずインポートを理解しよう" title="Permanent link">&para;</a></h3>
<p>App.tsx の冒頭で、必要な部品をインポートしています。</p>
<div class="info-box">
<div class="box-title">📦 インポートの全体像</div>
<div class="box-content">


<div class="codehilite"><pre><span></span><code><span class="c1">// 📦 画面コンポーネント（UIの部品）</span>
<span class="k">import</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">ChatScreen</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="kr">from</span><span class="w"> </span><span class="s1">&#39;./components/ChatScreen&#39;</span><span class="w">   </span><span class="c1">// チャット画面</span>
<span class="k">import</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">LoginScreen</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="kr">from</span><span class="w"> </span><span class="s1">&#39;./components/LoginScreen&#39;</span><span class="w"> </span><span class="c1">// ログイン画面</span>

<span class="c1">// 🔧 カスタムフック（useState + useEffect をまとめたもの）</span>
<span class="k">import</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">useAuth</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="kr">from</span><span class="w"> </span><span class="s1">&#39;./hooks/useAuth&#39;</span><span class="w">         </span><span class="c1">// 認証ロジック</span>
<span class="k">import</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">useChat</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="kr">from</span><span class="w"> </span><span class="s1">&#39;./hooks/useChat&#39;</span><span class="w">         </span><span class="c1">// チャットロジック</span>
<span class="k">import</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">useSessions</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="kr">from</span><span class="w"> </span><span class="s1">&#39;./hooks/useSessions&#39;</span><span class="w"> </span><span class="c1">// セッション管理ロジック</span>
</code></pre></div>



</div>
</div>

<table>
<tr><th>インポート</th><th>種類</th><th>中身</th></tr>
<tr>
  <td><code>ChatScreen</code></td>
  <td>コンポーネント</td>
  <td>チャット画面のUI（見た目）を定義</td>
</tr>
<tr>
  <td><code>LoginScreen</code></td>
  <td>コンポーネント</td>
  <td>ログイン画面のUI（見た目）を定義</td>
</tr>
<tr>
  <td><code>useAuth</code></td>
  <td><strong>カスタムフック</strong></td>
  <td>useState + useEffect で認証状態を管理<br>（user, loading, login, logout など）</td>
</tr>
<tr>
  <td><code>useChat</code></td>
  <td><strong>カスタムフック</strong></td>
  <td>useState + useEffect でチャットを管理<br>（messages, sendMessage など）</td>
</tr>
<tr>
  <td><code>useSessions</code></td>
  <td><strong>カスタムフック</strong></td>
  <td>useState で複数セッションを管理<br>（sessions, createSession など）</td>
</tr>
</table>

<div class="tip-box">
<div class="box-title">💡 ポイント</div>
<div class="box-content">
<code>use</code> で始まる関数はカスタムフック。前のセクションで学んだ「useState + useEffect をまとめたもの」です！
</div>
</div>

<h3 id="完全なコードコメント付き">完全なコード（コメント付き）<a class="header-link" href="#完全なコードコメント付き" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><code><span class="cm">/**</span>
<span class="cm"> * App.tsx - フロントエンドのメインコンポーネント</span>
<span class="cm"> *</span>
<span class="cm"> * 役割:</span>
<span class="cm"> *   - 未ログイン → LoginScreen を表示</span>
<span class="cm"> *   - ログイン済 → ChatScreen を表示</span>
<span class="cm"> */</span>
<span class="k">import</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">ChatScreen</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="kr">from</span><span class="w"> </span><span class="s1">&#39;./components/ChatScreen&#39;</span>
<span class="k">import</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">LoginScreen</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="kr">from</span><span class="w"> </span><span class="s1">&#39;./components/LoginScreen&#39;</span>
<span class="k">import</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">useAuth</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="kr">from</span><span class="w"> </span><span class="s1">&#39;./hooks/useAuth&#39;</span>
<span class="k">import</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">useChat</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="kr">from</span><span class="w"> </span><span class="s1">&#39;./hooks/useChat&#39;</span>
<span class="k">import</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">useSessions</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="kr">from</span><span class="w"> </span><span class="s1">&#39;./hooks/useSessions&#39;</span>

<span class="cm">/**</span>
<span class="cm"> * デバッグモード: 開発環境でのみ有効</span>
<span class="cm"> * - true: 認証をスキップしてチャット画面を表示（画面確認用）</span>
<span class="cm"> * - false: 通常の認証フローを使用</span>
<span class="cm"> */</span>
<span class="kd">const</span><span class="w"> </span><span class="nx">DEBUG_SHOW_CHAT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">import</span><span class="p">.</span><span class="nx">meta</span><span class="p">.</span><span class="nx">env</span><span class="p">.</span><span class="nx">DEV</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="k">import</span><span class="p">.</span><span class="nx">meta</span><span class="p">.</span><span class="nx">env</span><span class="p">.</span><span class="nx">VITE_DEBUG_MODE</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="s1">&#39;true&#39;</span>

<span class="kd">function</span><span class="w"> </span><span class="nx">App</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// ───────────────────────────────────────────────────────────────</span>
<span class="w">  </span><span class="c1">// カスタムフックを使って状態を取得</span>
<span class="w">  </span><span class="c1">// ───────────────────────────────────────────────────────────────</span>

<span class="w">  </span><span class="c1">// 認証状態（ユーザー情報、ログイン関数など）</span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">user</span><span class="p">,</span><span class="w"> </span><span class="nx">loading</span><span class="p">,</span><span class="w"> </span><span class="nx">error</span><span class="o">:</span><span class="w"> </span><span class="kt">authError</span><span class="p">,</span><span class="w"> </span><span class="nx">loginWithGoogle</span><span class="p">,</span><span class="w"> </span><span class="nx">logout</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">useAuth</span><span class="p">()</span>

<span class="w">  </span><span class="c1">// セッション管理（複数の会話を管理）</span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">sessions</span><span class="p">,</span><span class="w">              </span><span class="c1">// セッション一覧</span>
<span class="w">    </span><span class="nx">activeSession</span><span class="p">,</span><span class="w">         </span><span class="c1">// 現在選択中のセッション</span>
<span class="w">    </span><span class="nx">activeSessionId</span><span class="p">,</span><span class="w">       </span><span class="c1">// 現在のセッションID</span>
<span class="w">    </span><span class="nx">createSession</span><span class="p">,</span><span class="w">         </span><span class="c1">// 新規セッション作成</span>
<span class="w">    </span><span class="nx">switchSession</span><span class="p">,</span><span class="w">         </span><span class="c1">// セッション切り替え</span>
<span class="w">    </span><span class="nx">closeSession</span><span class="p">,</span><span class="w">          </span><span class="c1">// セッション削除</span>
<span class="w">    </span><span class="nx">updateSessionMessages</span><span class="p">,</span><span class="w"> </span><span class="c1">// メッセージ更新</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">useSessions</span><span class="p">()</span>

<span class="w">  </span><span class="c1">// チャット状態（メッセージ、送信関数など）</span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">messages</span><span class="p">,</span><span class="w"> </span><span class="nx">isLoading</span><span class="p">,</span><span class="w"> </span><span class="nx">error</span><span class="o">:</span><span class="w"> </span><span class="kt">chatError</span><span class="p">,</span><span class="w"> </span><span class="nx">sendMessage</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">useChat</span><span class="p">({</span>
<span class="w">    </span><span class="nx">activeSession</span><span class="p">,</span>
<span class="w">    </span><span class="nx">onMessagesUpdate</span><span class="o">:</span><span class="w"> </span><span class="kt">updateSessionMessages</span><span class="p">,</span>
<span class="w">  </span><span class="p">})</span>

<span class="w">  </span><span class="c1">// ───────────────────────────────────────────────────────────────</span>
<span class="w">  </span><span class="c1">// 条件分岐で表示する画面を決定</span>
<span class="w">  </span><span class="c1">// ───────────────────────────────────────────────────────────────</span>

<span class="w">  </span><span class="c1">// ローディング中（認証状態の確認中）</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">loading</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="o">!</span><span class="nx">DEBUG_SHOW_CHAT</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="p">(</span>
<span class="w">      </span><span class="p">&lt;</span><span class="nt">div</span><span class="w"> </span><span class="na">className</span><span class="o">=</span><span class="s">&quot;loading-screen&quot;</span><span class="p">&gt;</span>
<span class="w">        </span><span class="p">&lt;</span><span class="nt">div</span><span class="w"> </span><span class="na">className</span><span class="o">=</span><span class="s">&quot;spinner&quot;</span><span class="w"> </span><span class="p">/&gt;</span>
<span class="w">        </span><span class="p">&lt;</span><span class="nt">p</span><span class="p">&gt;</span><span class="nx">読み込み中</span><span class="p">...&lt;/</span><span class="nt">p</span><span class="p">&gt;</span>
<span class="w">      </span><span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
<span class="w">    </span><span class="p">)</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="c1">// 未ログイン → ログイン画面を表示</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="nx">user</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="o">!</span><span class="nx">DEBUG_SHOW_CHAT</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="p">&lt;</span><span class="nt">LoginScreen</span><span class="w"> </span><span class="na">onLogin</span><span class="o">=</span><span class="p">{</span><span class="nx">loginWithGoogle</span><span class="p">}</span><span class="w"> </span><span class="na">error</span><span class="o">=</span><span class="p">{</span><span class="nx">authError</span><span class="p">}</span><span class="w"> </span><span class="p">/&gt;</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="c1">// ログイン済み → チャット画面を表示</span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="nx">displayUser</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">user</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">email</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;demo@example.com&#39;</span><span class="p">,</span><span class="w"> </span><span class="nx">displayName</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;Demo User&#39;</span><span class="w"> </span><span class="p">}</span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="p">(</span>
<span class="w">    </span><span class="p">&lt;</span><span class="nt">ChatScreen</span>
<span class="w">      </span><span class="na">user</span><span class="o">=</span><span class="p">{</span><span class="nx">displayUser</span><span class="p">}</span>
<span class="w">      </span><span class="na">messages</span><span class="o">=</span><span class="p">{</span><span class="nx">messages</span><span class="p">}</span>
<span class="w">      </span><span class="na">isLoading</span><span class="o">=</span><span class="p">{</span><span class="nx">isLoading</span><span class="p">}</span>
<span class="w">      </span><span class="na">error</span><span class="o">=</span><span class="p">{</span><span class="nx">chatError</span><span class="p">}</span>
<span class="w">      </span><span class="na">onSendMessage</span><span class="o">=</span><span class="p">{</span><span class="nx">sendMessage</span><span class="p">}</span>
<span class="w">      </span><span class="na">onLogout</span><span class="o">=</span><span class="p">{</span><span class="nx">logout</span><span class="p">}</span>
<span class="w">      </span><span class="na">sessions</span><span class="o">=</span><span class="p">{</span><span class="nx">sessions</span><span class="p">}</span>
<span class="w">      </span><span class="na">activeSessionId</span><span class="o">=</span><span class="p">{</span><span class="nx">activeSessionId</span><span class="p">}</span>
<span class="w">      </span><span class="na">onSelectSession</span><span class="o">=</span><span class="p">{</span><span class="nx">switchSession</span><span class="p">}</span>
<span class="w">      </span><span class="na">onNewSession</span><span class="o">=</span><span class="p">{</span><span class="nx">createSession</span><span class="p">}</span>
<span class="w">      </span><span class="na">onCloseSession</span><span class="o">=</span><span class="p">{</span><span class="nx">closeSession</span><span class="p">}</span>
<span class="w">    </span><span class="p">/&gt;</span>
<span class="w">  </span><span class="p">)</span>
<span class="p">}</span>

<span class="k">export</span><span class="w"> </span><span class="k">default</span><span class="w"> </span><span class="nx">App</span>
</code></pre></div>

<div class="flow-box">
<h3>🔍 App.tsx の処理フロー</h3>
<div style="display: flex; flex-direction: column; align-items: center; gap: 8px;">
<div style="background: #3b82f6; color: white; padding: 12px 24px; border-radius: 8px; font-weight: bold;">App 起動</div>
<div style="font-size: 1.5em; color: #3b82f6;">▼</div>
</div>
<div style="display: flex; align-items: center; gap: 16px; margin: 16px 0; flex-wrap: wrap;">
<div style="background: #fbbf24; color: #1e293b; padding: 12px 20px; border-radius: 8px; text-align: center; min-width: 120px;">
<div style="font-weight: bold;">loading?</div>
<div style="font-size: 0.9em;">true</div>
</div>
<div style="font-size: 1.5em; color: #fbbf24;">→</div>
<div style="background: #fef3c7; border: 2px solid #fbbf24; padding: 12px 20px; border-radius: 8px; flex: 1; min-width: 200px;">ローディング画面表示（スピナー）</div>
</div>
<div style="display: flex; flex-direction: column; align-items: center; gap: 8px;">
<div style="color: #6b7280; font-size: 0.9em;">↓ false</div>
</div>
<div style="display: flex; align-items: center; gap: 16px; margin: 16px 0; flex-wrap: wrap;">
<div style="background: #f87171; color: white; padding: 12px 20px; border-radius: 8px; text-align: center; min-width: 120px;">
<div style="font-weight: bold;">user?</div>
<div style="font-size: 0.9em;">null</div>
</div>
<div style="font-size: 1.5em; color: #f87171;">→</div>
<div style="background: #fee2e2; border: 2px solid #f87171; padding: 12px 20px; border-radius: 8px; flex: 1; min-width: 200px;"><strong>LoginScreen</strong>（ログイン画面）</div>
</div>
<div style="display: flex; flex-direction: column; align-items: center; gap: 8px;">
<div style="color: #6b7280; font-size: 0.9em;">↓ user あり</div>
</div>
<div style="background: #10b981; color: white; padding: 16px 24px; border-radius: 8px; margin-top: 16px;">
<div style="font-weight: bold; font-size: 1.1em; margin-bottom: 8px;">ChatScreen（チャット画面）</div>
<ul style="margin: 0; padding-left: 20px;"><li>セッション一覧</li><li>メッセージ表示</li><li>入力フォーム</li></ul>
</div>
</div>

<hr />
<h2 id="6-useauthts---認証フックの完全解説">6. useAuth.ts - 認証フックの完全解説<a class="header-link" href="#6-useauthts---認証フックの完全解説" title="Permanent link">&para;</a></h2>
<h3 id="インポート部分の解説">インポート部分の解説<a class="header-link" href="#インポート部分の解説" title="Permanent link">&para;</a></h3>
<div class="info-box">
<div class="box-title">📦 インポートの全体像</div>
<div class="box-content">


<div class="codehilite"><pre><span></span><code><span class="c1">// ファイル: frontend/src/hooks/useAuth.ts</span>

<span class="c1">// React のフック（状態管理・副作用処理）</span>
<span class="k">import</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">useState</span><span class="p">,</span><span class="w"> </span><span class="nx">useEffect</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="kr">from</span><span class="w"> </span><span class="s1">&#39;react&#39;</span>

<span class="c1">// Firebase の認証機能</span>
<span class="k">import</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">User</span><span class="p">,</span><span class="w"> </span><span class="nx">signInWithPopup</span><span class="p">,</span><span class="w"> </span><span class="nx">signOut</span><span class="p">,</span><span class="w"> </span><span class="nx">onAuthStateChanged</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="kr">from</span><span class="w"> </span><span class="s1">&#39;firebase/auth&#39;</span>

<span class="c1">// 自分で作った Firebase 初期化モジュール</span>
<span class="k">import</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">auth</span><span class="p">,</span><span class="w"> </span><span class="nx">googleProvider</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="kr">from</span><span class="w"> </span><span class="s1">&#39;../services/firebase&#39;</span>
</code></pre></div>



</div>
</div>

<table>
<tr><th>インポート</th><th>種類</th><th>中身</th></tr>
<tr>
  <td><code>useState</code></td>
  <td>React フック</td>
  <td>状態（変数）を管理する</td>
</tr>
<tr>
  <td><code>useEffect</code></td>
  <td>React フック</td>
  <td>副作用（監視・通信など）を実行する</td>
</tr>
<tr>
  <td><code>User</code></td>
  <td>Firebase 型</td>
  <td>ユーザー情報の型定義</td>
</tr>
<tr>
  <td><code>signInWithPopup</code></td>
  <td>Firebase 関数</td>
  <td>ポップアップでログイン画面を表示</td>
</tr>
<tr>
  <td><code>signOut</code></td>
  <td>Firebase 関数</td>
  <td>ログアウト処理</td>
</tr>
<tr>
  <td><code>onAuthStateChanged</code></td>
  <td>Firebase 関数</td>
  <td>認証状態の変化を監視（重要！）</td>
</tr>
<tr>
  <td><code>auth</code></td>
  <td>自作モジュール</td>
  <td>Firebase 認証インスタンス</td>
</tr>
<tr>
  <td><code>googleProvider</code></td>
  <td>自作モジュール</td>
  <td>Google ログイン用プロバイダー</td>
</tr>
</table>

<div class="tip-box">
<div class="box-title">📂 相対パスの読み方</div>
<div class="box-content">


<div class="codehilite"><pre><span></span><code><span class="err">現在地</span><span class="o">:</span><span class="w"> </span><span class="n">frontend</span><span class="sr">/src/hooks/</span><span class="n">useAuth</span><span class="o">.</span><span class="na">ts</span>
<span class="w">                        </span><span class="err">└──</span><span class="w"> </span><span class="n">hooks</span><span class="w"> </span><span class="err">フォルダにいる</span>
<span class="o">../</span><span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="err">つ上（</span><span class="n">frontend</span><span class="sr">/src/</span><span class="err">）</span>
<span class="o">../</span><span class="n">services</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="err">つ上の</span><span class="w"> </span><span class="n">services</span><span class="w"> </span><span class="err">フォルダ（</span><span class="n">frontend</span><span class="sr">/src/services/</span><span class="err">）</span>
<span class="o">../</span><span class="n">services</span><span class="o">/</span><span class="n">firebase</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="err">その中の</span><span class="w"> </span><span class="n">firebase</span><span class="o">.</span><span class="na">ts</span>
</code></pre></div>



</div>
</div>

<h3 id="完全なコード">完全なコード<a class="header-link" href="#完全なコード" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><code><span class="k">export</span><span class="w"> </span><span class="kd">function</span><span class="w"> </span><span class="nx">useAuth</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// ───────────────────────────────────────────────────────────────</span>
<span class="w">  </span><span class="c1">// 状態の定義</span>
<span class="w">  </span><span class="c1">// ───────────────────────────────────────────────────────────────</span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="p">[</span><span class="nx">user</span><span class="p">,</span><span class="w"> </span><span class="nx">setUser</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">useState</span><span class="p">&lt;</span><span class="nt">User</span><span class="w"> </span><span class="err">|</span><span class="w"> </span><span class="na">null</span><span class="p">&gt;(</span><span class="kc">null</span><span class="p">)</span><span class="w">      </span><span class="c1">// ログイン中のユーザー</span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="p">[</span><span class="nx">loading</span><span class="p">,</span><span class="w"> </span><span class="nx">setLoading</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">useState</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span><span class="w">              </span><span class="c1">// 読み込み中フラグ</span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="p">[</span><span class="nx">error</span><span class="p">,</span><span class="w"> </span><span class="nx">setError</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">useState</span><span class="p">&lt;</span><span class="nt">string</span><span class="w"> </span><span class="err">|</span><span class="w"> </span><span class="na">null</span><span class="p">&gt;(</span><span class="kc">null</span><span class="p">)</span><span class="w">   </span><span class="c1">// エラーメッセージ</span>

<span class="w">  </span><span class="c1">// ───────────────────────────────────────────────────────────────</span>
<span class="w">  </span><span class="c1">// 認証状態の監視（重要！）</span>
<span class="w">  </span><span class="c1">// ───────────────────────────────────────────────────────────────</span>
<span class="w">  </span><span class="nx">useEffect</span><span class="p">(()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// onAuthStateChanged: 認証状態が変わったら呼ばれるコールバック</span>
<span class="w">    </span><span class="kd">const</span><span class="w"> </span><span class="nx">unsubscribe</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">onAuthStateChanged</span><span class="p">(</span><span class="nx">auth</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="nx">user</span><span class="p">)</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="nx">setUser</span><span class="p">(</span><span class="nx">user</span><span class="p">)</span><span class="w">       </span><span class="c1">// ユーザー情報をセット（null = 未ログイン）</span>
<span class="w">      </span><span class="nx">setLoading</span><span class="p">(</span><span class="kc">false</span><span class="p">)</span><span class="w">   </span><span class="c1">// 読み込み完了</span>
<span class="w">    </span><span class="p">})</span>

<span class="w">    </span><span class="c1">// クリーンアップ: 画面が消えるとき監視を解除</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nx">unsubscribe</span>
<span class="w">  </span><span class="p">},</span><span class="w"> </span><span class="p">[])</span>

<span class="w">  </span><span class="c1">// ───────────────────────────────────────────────────────────────</span>
<span class="w">  </span><span class="c1">// Googleでログイン</span>
<span class="w">  </span><span class="c1">// ───────────────────────────────────────────────────────────────</span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="nx">loginWithGoogle</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">async</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">setError</span><span class="p">(</span><span class="kc">null</span><span class="p">)</span><span class="w">  </span><span class="c1">// エラーをクリア</span>
<span class="w">    </span><span class="k">try</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="c1">// signInWithPopup: ポップアップでGoogleログイン画面を表示</span>
<span class="w">      </span><span class="k">await</span><span class="w"> </span><span class="nx">signInWithPopup</span><span class="p">(</span><span class="nx">auth</span><span class="p">,</span><span class="w"> </span><span class="nx">googleProvider</span><span class="p">)</span>
<span class="w">      </span><span class="c1">// ログイン成功 → onAuthStateChanged が自動で呼ばれる</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">catch</span><span class="w"> </span><span class="p">(</span><span class="nx">err</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="nx">setError</span><span class="p">(</span><span class="s1">&#39;ログインに失敗しました&#39;</span><span class="p">)</span>
<span class="w">      </span><span class="nx">console</span><span class="p">.</span><span class="nx">error</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="c1">// ───────────────────────────────────────────────────────────────</span>
<span class="w">  </span><span class="c1">// ログアウト</span>
<span class="w">  </span><span class="c1">// ───────────────────────────────────────────────────────────────</span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="nx">logout</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">async</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">try</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">await</span><span class="w"> </span><span class="nx">signOut</span><span class="p">(</span><span class="nx">auth</span><span class="p">)</span>
<span class="w">      </span><span class="c1">// ログアウト成功 → onAuthStateChanged が自動で呼ばれる</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">catch</span><span class="w"> </span><span class="p">(</span><span class="nx">err</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="nx">setError</span><span class="p">(</span><span class="s1">&#39;ログアウトに失敗しました&#39;</span><span class="p">)</span>
<span class="w">      </span><span class="nx">console</span><span class="p">.</span><span class="nx">error</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="c1">// ───────────────────────────────────────────────────────────────</span>
<span class="w">  </span><span class="c1">// 戻り値</span>
<span class="w">  </span><span class="c1">// ───────────────────────────────────────────────────────────────</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">user</span><span class="p">,</span><span class="w">                     </span><span class="c1">// Userオブジェクト or null</span>
<span class="w">    </span><span class="nx">loading</span><span class="p">,</span><span class="w">                  </span><span class="c1">// 認証確認中か</span>
<span class="w">    </span><span class="nx">error</span><span class="p">,</span><span class="w">                    </span><span class="c1">// エラーメッセージ</span>
<span class="w">    </span><span class="nx">loginWithGoogle</span><span class="p">,</span><span class="w">          </span><span class="c1">// ログイン関数</span>
<span class="w">    </span><span class="nx">logout</span><span class="p">,</span><span class="w">                   </span><span class="c1">// ログアウト関数</span>
<span class="w">    </span><span class="nx">isLoggedIn</span><span class="o">:</span><span class="w"> </span><span class="o">!!</span><span class="nx">user</span><span class="p">,</span><span class="w">       </span><span class="c1">// ログイン済みか（boolean）</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>

<details>
<summary><strong>📖 コールバック関数って何？（クリックで展開）</strong></summary>

<div class="info-box" style="margin-top: 16px;">
<div class="box-title">コールバック関数 = 「後で呼んでね」と渡す関数</div>
<div class="box-content">

上のコードで一番わかりづらいのがここ：

<pre><code class="tsx">onAuthStateChanged(auth, (user) => {
  setUser(user)
  setLoading(false)
})</code></pre>

<strong>構造を図解：</strong>

<pre><code>onAuthStateChanged( auth , (user) => { ... } )
                     ↑            ↑
                  第1引数      第2引数
                 (Firebase)  (コールバック関数)
                             「認証変わったら
                              この処理やってね」</code></pre>

<strong>イメージ：</strong>

<pre><code>あなた: 「Firebase さん、認証状態変わったら教えてね」

Firebase: 「OK、変わったら (user) => {...} を呼ぶね」

    〜〜〜 時間経過 〜〜〜

Firebase: 「ログインされたよ！」
         → (user) => { setUser(user); setLoading(false) } を実行</code></pre>

<strong>ポイント：</strong>
<ul>
<li>第2引数は「関数を渡している」だけ（値を返すわけではない）</li>
<li><code>setUser(user)</code> と <code>setLoading(false)</code> は関数内で実行される「命令」</li>
<li>GAS の <code>forEach</code> に関数を渡すのと同じパターン</li>
</ul>

</div>
</div>

<div class="tip-box">
<h3>💡 名前付き関数で書き直すと？</h3>

<pre><code class="tsx">// パターンA: アロー関数を直接渡す（実際のコード）
onAuthStateChanged(auth, (user) => {
  setUser(user);
  setLoading(false);
});

// パターンB: 同じことを「名前付き関数」で書いた場合
function handleAuthChange(user) {
  setUser(user);
  setLoading(false);
}
onAuthStateChanged(auth, handleAuthChange);
</code></pre>

<strong>どちらも同じ動作！</strong> パターンAは「関数をその場で作って渡す」方法です。

</div>

</details>

<h3 id="onauthstatechanged-の仕組み">onAuthStateChanged の仕組み<a class="header-link" href="#onauthstatechanged-の仕組み" title="Permanent link">&para;</a></h3>
<div class="flow-box">
<h3>🔐 onAuthStateChanged の動作</h3>
<p><strong>【パターン1: ログイン】</strong></p>
<pre>
[ユーザー] ──▶ [Googleログイン] ──▶ [Firebase]
                                        │
                                        ▼
[useAuth] ◀── onAuthStateChanged(user) ─┘
    │
    ▼
setUser(user) → 画面更新
</pre>
<p><strong>【パターン2: ページリロード】</strong></p>
<pre>
[ブラウザ] ──▶ [ページ読み込み]
                   │
                   ▼
[Firebase] ── ローカルストレージから認証情報を復元
    │
    ▼
[useAuth] ◀── onAuthStateChanged(user)
    │
    ▼
自動的にログイン状態が復元！
</pre>
<p><strong>【ポイント】</strong><br>
Firebase が認証状態を localStorage に保存してくれる<br>
→ ページを閉じても、再訪問時に自動ログイン！</p>
</div>

<hr />
<h2 id="7-usechatts---チャットフックの完全解説">7. useChat.ts - チャットフックの完全解説<a class="header-link" href="#7-usechatts---チャットフックの完全解説" title="Permanent link">&para;</a></h2>
<div class="info-box">
<div class="box-title">🎯 なぜ useChat が必要？</div>
<div class="box-content">

<strong>問題</strong>: チャット画面には管理すべきものがたくさんある
<ul>
<li>メッセージ一覧（<code>messages</code>）</li>
<li>送信中かどうか（<code>isLoading</code>）</li>
<li>エラー状態（<code>error</code>）</li>
<li>スレッドID（<code>threadId</code>）</li>
</ul>

<p>これを ChatScreen.tsx や App.tsx に直接書くと：</p>
<ul>
<li>コードが長くなる（500行超え）</li>
<li>同じロジックを複数の場所で書く羽目になる</li>
<li>テストしにくい</li>
</ul>

<strong>解決</strong>: <code>useChat</code> に「チャットに必要な状態と操作」をまとめる

<pre><code>// 使う側はシンプル
const { messages, isLoading, sendMessage } = useChat(...)

// ボタンを押したら
&lt;button onClick={() =&gt; sendMessage('こんにちは')}&gt;送信&lt;/button&gt;

// 画面に表示
{messages.map(m =&gt; &lt;div&gt;{m.content}&lt;/div&gt;)}
</code></pre>

<p>→ 「どうやってメッセージを送るか」の詳細は useChat の中に隠蔽されている</p>

</div>
</div>

<div class="info-box">
<div class="box-title">🔗 useSessions との連携</div>
<div class="box-content">

<strong>2つのフックの役割分担</strong>

<table>
<tr><th>フック</th><th>役割</th><th>担当</th></tr>
<tr><td><code>useChat</code></td><td>画面表示</td><td>「今」のメッセージを管理</td></tr>
<tr><td><code>useSessions</code></td><td>データ保存</td><td>ローカルストレージへの永続化</td></tr>
</table>

<strong>橋渡しの仕組み</strong>

<div style="display: flex; justify-content: center; align-items: center; gap: 20px; margin: 20px 0; padding: 20px; background: #f8f9fa; border-radius: 8px;">
  <div style="text-align: center; font-weight: bold; padding: 10px 20px; background: #e3f2fd; border-radius: 8px;">useSessions<br><span style="font-size: 0.8em; font-weight: normal;">（データ保存）</span></div>
  <div style="display: flex; flex-direction: column; gap: 15px;">
    <div style="display: flex; align-items: center; gap: 10px;">
      <code style="background: #fff3e0; padding: 4px 8px; border-radius: 4px;">activeSession</code>
      <span style="font-size: 1.5em;">→</span>
      <span style="font-size: 0.9em;">「このセッションを表示して」</span>
    </div>
    <div style="display: flex; align-items: center; gap: 10px;">
      <code style="background: #e8f5e9; padding: 4px 8px; border-radius: 4px;">onMessagesUpdate</code>
      <span style="font-size: 1.5em;">←</span>
      <span style="font-size: 0.9em;">「メッセージ更新したから保存して」</span>
    </div>
  </div>
  <div style="text-align: center; font-weight: bold; padding: 10px 20px; background: #fce4ec; border-radius: 8px;">useChat<br><span style="font-size: 0.8em; font-weight: normal;">（画面表示）</span></div>
</div>

<p>App.tsx でこの2つのフックを接続しています（詳細は「8. useSessions.ts」を参照）。</p>

</div>
</div>

<details>
<summary><strong>📋 useChat.ts の変数・インターフェース一覧（クリックで展開）</strong></summary>

<div style="padding: 16px;">

<p>このファイルには似た名前がたくさん出てきます。迷ったらここを確認してください。</p>

<h4>インターフェース（型定義）</h4>
<table>
<tr><th>名前</th><th>役割</th><th>どこで使う？</th></tr>
<tr><td><code>Message</code></td><td>1つのメッセージの型（id, role, content）</td><td>メッセージ配列の要素</td></tr>
<tr><td><code>UseChatOptions</code></td><td>useChat に渡す設定の型（↓で詳細説明）</td><td>useChat 関数の引数</td></tr>
</table>

<div class="tip-box" style="margin: 16px 0;">
<strong>💡 useChat と UseChatOptions の見分け方</strong>
<table>
<tr><th>名前</th><th>先頭</th><th>種類</th></tr>
<tr><td><code>useChat</code></td><td>小文字 <code>use</code></td><td>関数（カスタムフック）</td></tr>
<tr><td><code>UseChatOptions</code></td><td>大文字 <code>Use</code></td><td>インターフェース（型定義）</td></tr>
</table>
<p>React の慣習: <code>useXxx</code> → フック、<code>UseXxxOptions</code> → そのフックに渡す引数の型</p>
</div>

<h4>UseChatOptions の中身（useChat に渡す設定）</h4>
<p><strong>なぜ「Options」という名前？</strong><br>
React のカスタムフックでは、引数の型を <code>UseXxxOptions</code> と名付ける慣習があります。<br>
「オプション＝任意」ではなく「外部から渡す設定一式」という意味です。</p>
<table>
<tr><th>プロパティ</th><th>型</th><th>役割</th></tr>
<tr><td><code>activeSession</code></td><td><code>ChatSession | null</code></td><td>「今どのセッションを表示する？」を useChat に教える</td></tr>
<tr><td><code>onMessagesUpdate</code></td><td><code>(sessionId, messages, threadId) =&gt; void</code></td><td>「メッセージが変わったらこの関数を呼んでね」というコールバック</td></tr>
</table>
<p><strong>実際の呼び出し例（App.tsx）:</strong></p>
<pre><code>const { messages, sendMessage } = useChat({
  activeSession,                          // ← useSessions から取得
  onMessagesUpdate: updateSessionMessages // ← useSessions の関数を渡す
})</code></pre>
<p>→ useChat と useSessions が<strong>連携</strong>するために、App.tsx が橋渡しをしている</p>

<h4>useState で管理する状態</h4>
<table>
<tr><th>変数名</th><th>型</th><th>役割</th><th>初期値</th></tr>
<tr><td><code>messages</code></td><td><code>Message[]</code></td><td>画面に表示するメッセージ一覧</td><td>セッションから復元 or <code>[]</code></td></tr>
<tr><td><code>threadId</code></td><td><code>string | null</code></td><td>バックエンドとの会話ID</td><td>セッションから復元 or <code>null</code></td></tr>
<tr><td><code>isLoading</code></td><td><code>boolean</code></td><td>送信中かどうか</td><td><code>false</code></td></tr>
<tr><td><code>error</code></td><td><code>string | null</code></td><td>エラーメッセージ</td><td><code>null</code></td></tr>
</table>

<h4>関数</h4>
<table>
<tr><th>関数名</th><th>役割</th><th>呼ばれるタイミング</th></tr>
<tr><td><code>generateUniqueId()</code></td><td>ユニークなIDを生成</td><td>メッセージ作成時</td></tr>
<tr><td><code>sendMessage(content)</code></td><td>メッセージを送信</td><td>ユーザーが送信ボタンを押した時</td></tr>
</table>

<h4>useChat が返すオブジェクト</h4>
<pre><code>return {
  messages,    // Message[] - メッセージ一覧
  isLoading,   // boolean - 送信中？
  error,       // string | null - エラー
  sendMessage, // (content: string) => void - 送信関数
  threadId,    // string | null - 会話ID
}</code></pre>

<h4>似た名前の区別（コード例付き）</h4>
<p>実際のコードでどこに出てくるか見てみましょう：</p>
<pre><code>// 【型定義】Message = メッセージの「設計図」
interface Message {
  id: string
  role: 'user' | 'assistant'
  content: string
}

// 【変数】messages = Message型の配列（実際のデータ）
const [messages, setMessages] = useState&lt;Message[]&gt;([])

// 【変数】userMessage = ユーザーが送った1つのメッセージ
const userMessage: Message = {
  id: generateUniqueId(),
  role: 'user',
  content: 'こんにちは',  // ← ユーザーが入力した内容
}

// 【変数】assistantMessage = AIの返答（最初は空）
const assistantMessage: Message = {
  id: generateUniqueId(),
  role: 'assistant',
  content: '',  // ← AIの返答がここに入る
}

// 【関数】sendMessage = ユーザーが呼び出す「送信ボタン」
const sendMessage = async (content: string) =&gt; {
  // この中で sendChatMessage を呼ぶ
}

// 【関数】sendChatMessage = バックエンドにHTTP通信（api.ts）
await sendChatMessage(content, threadId, onChunk)</code></pre>
<table>
<tr><th>名前</th><th>種類</th><th>役割</th></tr>
<tr><td><code>Message</code></td><td>型（interface）</td><td>メッセージの構造を定義する「設計図」</td></tr>
<tr><td><code>messages</code></td><td>変数（配列）</td><td>画面に表示する全メッセージ</td></tr>
<tr><td><code>userMessage</code></td><td>変数（1つ）</td><td>ユーザーが今送ったメッセージ</td></tr>
<tr><td><code>assistantMessage</code></td><td>変数（1つ）</td><td>AIの返答</td></tr>
<tr><td><code>sendMessage</code></td><td>関数（useChat内）</td><td>送信ボタンから呼ばれる処理</td></tr>
<tr><td><code>sendChatMessage</code></td><td>関数（api.ts）</td><td>実際にバックエンドにHTTPリクエスト</td></tr>
</table>

</div>
</details>

<h3 id="インポート部分の解説_1">インポート部分の解説<a class="header-link" href="#インポート部分の解説_1" title="Permanent link">&para;</a></h3>
<div class="info-box">
<div class="box-title">📦 インポートの全体像</div>
<div class="box-content">


<div class="codehilite"><pre><span></span><code><span class="c1">// ファイル: frontend/src/hooks/useChat.ts</span>

<span class="c1">// React のフック（状態管理・関数メモ化・副作用処理）</span>
<span class="k">import</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">useState</span><span class="p">,</span><span class="w"> </span><span class="nx">useCallback</span><span class="p">,</span><span class="w"> </span><span class="nx">useEffect</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="kr">from</span><span class="w"> </span><span class="s1">&#39;react&#39;</span>

<span class="c1">// API通信モジュール（バックエンドにメッセージを送る）</span>
<span class="k">import</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">sendChatMessage</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="kr">from</span><span class="w"> </span><span class="s1">&#39;../services/api&#39;</span>

<span class="c1">// 同じ hooks フォルダ内の useSessions.ts から型をインポート</span>
<span class="k">import</span><span class="w"> </span><span class="kr">type</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">ChatSession</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="kr">from</span><span class="w"> </span><span class="s1">&#39;./useSessions&#39;</span>
</code></pre></div>



</div>
</div>

<table>
<tr><th>インポート</th><th>種類</th><th>中身</th></tr>
<tr>
  <td><code>useState</code></td>
  <td>React フック</td>
  <td>状態（変数）を管理する</td>
</tr>
<tr>
  <td><code>useCallback</code></td>
  <td>React フック</td>
  <td>関数をメモ化（パフォーマンス最適化）</td>
</tr>
<tr>
  <td><code>useEffect</code></td>
  <td>React フック</td>
  <td>副作用（監視・通信など）を実行する</td>
</tr>
<tr>
  <td><code>sendChatMessage</code></td>
  <td>自作関数</td>
  <td>バックエンドにチャットメッセージを送信</td>
</tr>
<tr>
  <td><code>ChatSession</code></td>
  <td>型定義</td>
  <td>チャットセッションの型（<code>type</code>＝型だけインポート）</td>
</tr>
</table>

<div class="tip-box">
<div class="box-title">📂 相対パスの読み方</div>
<div class="box-content">

<table>
<tr><th>パス</th><th>意味</th><th>例</th></tr>
<tr><td><code>./</code></td><td>同じフォルダ</td><td><code>./useSessions</code> = 同じ hooks フォルダ内</td></tr>
<tr><td><code>../</code></td><td>1つ上のフォルダ</td><td><code>../services</code> = hooks の1つ上 → services</td></tr>
<tr><td><code>../../</code></td><td>2つ上のフォルダ</td><td><code>../../App</code> = hooks の2つ上</td></tr>
</table>


<div class="codehilite"><pre><span></span><code>frontend/src/
├── hooks/
│   ├── useAuth.ts      ← ここから見ると...
│   ├── useChat.ts      ← ./useChat（同じフォルダ）
│   └── useSessions.ts
├── services/
│   ├── api.ts          ← ../services/api（1つ上 → services）
│   └── firebase.ts
└── App.tsx             ← ../App（1つ上）
</code></pre></div>



</div>
</div>

<h3 id="このファイルの全体像">このファイルの全体像<a class="header-link" href="#このファイルの全体像" title="Permanent link">&para;</a></h3>
<div class="warning-box">
<h3>📚 useChat.ts は複雑なファイルです</h3>
<p>他のファイルと比べて要素が多いため、<strong>段階的に解説</strong>します。</p>
<pre>
┌─────────────────────────────────────────────────────────────────┐
│ 1. インポート         ← 必要なものを読み込む                      │
├─────────────────────────────────────────────────────────────────┤
│ 2. 型定義（interface） ← データの形を定義する                     │
├─────────────────────────────────────────────────────────────────┤
│ 3. ヘルパー関数        ← メイン関数内で使う補助関数               │
├─────────────────────────────────────────────────────────────────┤
│ 4. メイン関数          ← 実際の処理                               │
└─────────────────────────────────────────────────────────────────┘
</pre>
<p>上から順番に見ていきましょう！</p>
</div>

<hr />
<h3 id="step-1-型定義interface">Step 1: 型定義（interface）<a class="header-link" href="#step-1-型定義interface" title="Permanent link">&para;</a></h3>
<p>まず、このファイルで使う「データの形」を定義します。</p>
<div class="codehilite"><pre><span></span><code><span class="c1">// ファイル: frontend/src/hooks/useChat.ts</span>

<span class="k">import</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">useState</span><span class="p">,</span><span class="w"> </span><span class="nx">useCallback</span><span class="p">,</span><span class="w"> </span><span class="nx">useEffect</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="kr">from</span><span class="w"> </span><span class="s1">&#39;react&#39;</span>
<span class="k">import</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">sendChatMessage</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="kr">from</span><span class="w"> </span><span class="s1">&#39;../services/api&#39;</span>
<span class="k">import</span><span class="w"> </span><span class="kr">type</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">ChatSession</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="kr">from</span><span class="w"> </span><span class="s1">&#39;./useSessions&#39;</span>

<span class="c1">// ─────────────────────────────────────────────────────────────────</span>
<span class="c1">// 型定義</span>
<span class="c1">// ─────────────────────────────────────────────────────────────────</span>

<span class="cm">/** メッセージの型（他のファイルでも使うので export） */</span>
<span class="k">export</span><span class="w"> </span><span class="kd">interface</span><span class="w"> </span><span class="nx">Message</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">id</span><span class="o">:</span><span class="w"> </span><span class="kt">string</span><span class="w">                    </span><span class="c1">// ユニークなID</span>
<span class="w">  </span><span class="nx">role</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;user&#39;</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="s1">&#39;assistant&#39;</span><span class="w">    </span><span class="c1">// 誰のメッセージか</span>
<span class="w">  </span><span class="nx">content</span><span class="o">:</span><span class="w"> </span><span class="kt">string</span><span class="w">               </span><span class="c1">// メッセージ内容</span>
<span class="p">}</span>

<span class="cm">/** useChat のオプション型（このファイル内だけで使用） */</span>
<span class="kd">interface</span><span class="w"> </span><span class="nx">UseChatOptions</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">activeSession</span><span class="o">:</span><span class="w"> </span><span class="kt">ChatSession</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="kc">null</span>
<span class="w">  </span><span class="nx">onMessagesUpdate</span><span class="o">:</span><span class="w"> </span><span class="p">(</span><span class="nx">sessionId</span><span class="o">:</span><span class="w"> </span><span class="kt">string</span><span class="p">,</span><span class="w"> </span><span class="nx">messages</span><span class="o">:</span><span class="w"> </span><span class="kt">Message</span><span class="p">[],</span><span class="w"> </span><span class="nx">threadId</span><span class="o">:</span><span class="w"> </span><span class="kt">string</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="kc">null</span><span class="p">)</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="ow">void</span>
<span class="p">}</span>
</code></pre></div>

<div class="warning-box">
<h3>❓ なぜ useChat だけ型定義（interface）がある？</h3>
<p>これまでの useAuth, useSessions には interface がなかったのに、なぜ急に？</p>

<table>
<tr><th>フック</th><th>引数</th><th>型定義</th></tr>
<tr><td>useAuth()</td><td>なし</td><td>不要</td></tr>
<tr><td>useSessions()</td><td>なし</td><td>不要</td></tr>
<tr><td><strong>useChat(options)</strong></td><td><strong>あり</strong></td><td><strong>必要</strong></td></tr>
</table>

<p><strong>答え: 引数を受け取るから</strong></p>

<pre>
// useAuth - 引数なし → 型定義は不要
export function useAuth() {
  // 内部で Firebase を直接使う
}

// useChat - 引数あり → 「どんな引数を受け取るか」を定義する必要がある
interface UseChatOptions {    // ← これが引数の型定義
  activeSession: ...
  onMessagesUpdate: ...
}
export function useChat(options?: UseChatOptions) {
  // 外部から渡された情報を使う
}
</pre>

<p>💡 <strong>ポイント:</strong> 型定義は「引数の形を説明書として書いておく」ためのもの。引数がなければ説明書も不要！</p>

<h4>❓ でも sendChatMessage も引数あるのに interface ないよね？</h4>

<p>良い質問！引数があっても interface を使わないケースもあります：</p>

<table>
<tr><th>関数</th><th>引数の書き方</th><th>理由</th></tr>
<tr>
<td><code>sendChatMessage</code></td>
<td><code>(message: string, threadId: string | null, onChunk: ...)</code></td>
<td>引数が<strong>単純</strong>（string など基本型）</td>
</tr>
<tr>
<td><code>loginWithGoogle</code></td>
<td><code>()</code></td>
<td>引数なし</td>
</tr>
<tr>
<td><code>useChat</code></td>
<td><code>(options?: UseChatOptions)</code></td>
<td>引数が<strong>複雑</strong>（オブジェクトの中に関数）</td>
</tr>
</table>

<pre>
// 引数が単純 → インライン（その場で直接書く）
function sendChatMessage(
  message: string,           // ← 単純！string だけ
  threadId: string | null,   // ← 単純！string か null
  onChunk: (chunk: string) => void
) { ... }

// 引数が複雑 → interface で別途定義
interface UseChatOptions {
  activeSession: ChatSession | null    // ← オブジェクト型
  onMessagesUpdate: (sessionId: string, messages: Message[], ...) => void  // ← 複雑な関数
}
function useChat(options?: UseChatOptions) { ... }
</pre>

<p><strong>判断基準:</strong></p>
<ul>
<li>引数が <code>string</code>, <code>number</code>, <code>boolean</code> など単純 → <strong>直接書く</strong></li>
<li>引数がオブジェクト（<code>{ ... }</code>）で複雑 → <strong>interface で定義</strong></li>
</ul>
</div>

<div class="info-box">
<h3>🔑 export の有無で何が変わる？</h3>
<table>
<tr><th>書き方</th><th>意味</th><th>どこで使う？</th></tr>
<tr>
<td><code>export interface Message</code></td>
<td>他のファイルからも使える</td>
<td>ChatScreen.tsx で <code>import { Message } from './hooks/useChat'</code></td>
</tr>
<tr>
<td><code>interface UseChatOptions</code></td>
<td>このファイル内だけ</td>
<td>下の useChat 関数の引数の型として使用</td>
</tr>
</table>
<p><strong>判断基準:</strong> 他のファイルで使う予定があるなら <code>export</code> をつける</p>
</div>

<div class="tip-box">
<h3>💡 Message 型の役割</h3>
<p>チャットの1つ1つのメッセージを表します：</p>
<pre>
// 例：こんな形のデータになる
const message: Message = {
  id: "abc-123-def",           // 重複しないユニークなID
  role: "user",                // "user" か "assistant" のどちらか
  content: "こんにちは！"       // 実際のメッセージ内容
}
</pre>

<h4>🔍 変数名と型の見分け方</h4>
<pre>
const message: Message = { ... }
      ↑         ↑
      変数名    型（interface）
</pre>
<p>コロン <code>:</code> の<strong>左が変数名</strong>、<strong>右が型</strong>です。</p>
<table>
<tr><th>書き方</th><th>変数名</th><th>型</th></tr>
<tr><td><code>const message: Message</code></td><td>message</td><td>Message</td></tr>
<tr><td><code>const id: string</code></td><td>id</td><td>string</td></tr>
<tr><td><code>const count: number</code></td><td>count</td><td>number</td></tr>
</table>
</div>

<div class="info-box">
<h3>📝 UseChatOptions 型の解説</h3>


<div class="codehilite"><pre><span></span><code><span class="kd">interface</span><span class="w"> </span><span class="nx">UseChatOptions</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">activeSession</span><span class="o">:</span><span class="w"> </span><span class="kt">ChatSession</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="kc">null</span>
<span class="w">  </span><span class="nx">onMessagesUpdate</span><span class="o">:</span><span class="w"> </span><span class="p">(</span><span class="nx">sessionId</span><span class="o">:</span><span class="w"> </span><span class="kt">string</span><span class="p">,</span><span class="w"> </span><span class="nx">messages</span><span class="o">:</span><span class="w"> </span><span class="kt">Message</span><span class="p">[],</span><span class="w"> </span><span class="nx">threadId</span><span class="o">:</span><span class="w"> </span><span class="kt">string</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="kc">null</span><span class="p">)</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="ow">void</span>
<span class="p">}</span>
</code></pre></div>



<p><strong>2つのプロパティがあります：</strong></p>

<table>
<tr><th>プロパティ</th><th>型</th><th>意味</th></tr>
<tr>
<td><code>activeSession</code></td>
<td><code>ChatSession | null</code></td>
<td>現在選択中のセッション（なければ null）</td>
</tr>
<tr>
<td><code>onMessagesUpdate</code></td>
<td>関数</td>
<td>メッセージが更新された時に呼ぶコールバック関数</td>
</tr>
</table>

<h4>🔍 onMessagesUpdate を分解して理解する</h4>

<pre>
onMessagesUpdate: (sessionId: string, messages: Message[], threadId: string | null) => void
                   ↑                  ↑                    ↑                          ↑
                   引数1              引数2                引数3                       戻り値
</pre>

<table>
<tr><th>部分</th><th>意味</th></tr>
<tr><td><code>(sessionId: string, ...)</code></td><td>引数1: セッションID（文字列）</td></tr>
<tr><td><code>(..., messages: Message[], ...)</code></td><td>引数2: メッセージの配列</td></tr>
<tr><td><code>(..., threadId: string | null)</code></td><td>引数3: スレッドID（文字列 or null）</td></tr>
<tr><td><code>=> void</code></td><td>戻り値なし（何も返さない）</td></tr>
</table>

<h4>📌 実際の使われ方（App.tsx）</h4>

<pre>
// App.tsx で useChat を呼び出す時
const { messages, sendMessage } = useChat({
  activeSession: activeSession,
  onMessagesUpdate: updateSessionMessages  // ← 関数をそのまま渡す
})
</pre>

<p><strong>❓ あれ？useAuth は引数なしだったのに、なぜ useChat は引数あり？</strong></p>

<table>
<tr><th>フック</th><th>呼び出し方</th><th>理由</th></tr>
<tr>
<td>useAuth</td>
<td><code>const { user } = useAuth()</code></td>
<td>引数不要（Firebase設定は内部で完結）</td>
</tr>
<tr>
<td>useSessions</td>
<td><code>const { sessions } = useSessions()</code></td>
<td>引数不要（ローカルストレージで完結）</td>
</tr>
<tr>
<td><strong>useChat</strong></td>
<td><code>const { ... } = useChat({ ... })</code></td>
<td><strong>外部の情報が必要</strong>（どのセッション？保存関数は？）</td>
</tr>
</table>

<p><strong>useChat が引数を必要とする理由:</strong></p>
<ul>
<li><code>activeSession</code> - 「今どのセッションを表示する？」は useChat 単独では分からない</li>
<li><code>onMessagesUpdate</code> - 「メッセージをどう保存する？」は useSessions の関数を使う</li>
</ul>
<p>→ useChat と useSessions が<strong>連携</strong>するために、App.tsx が橋渡しをしている</p>

<p><strong>🔍 なぜ関数をそのまま渡せる？</strong></p>
<pre>
// 冗長な書き方（引数を受け取って、そのまま渡すだけ）
onMessagesUpdate: (sessionId, messages, threadId) => {
  updateSessionMessages(sessionId, messages, threadId)
}

// シンプルな書き方（関数をそのまま渡す）
onMessagesUpdate: updateSessionMessages
</pre>
<p>引数の型が同じなので、関数をそのまま渡せます。<br>
「<code>(a, b, c) => func(a, b, c)</code>」は「<code>func</code>」と同じ意味！</p>

<p>💡 <strong>ポイント:</strong> <code>onMessagesUpdate</code> は「メッセージが変わったら、この関数を呼んでね」という<strong>お願い</strong>を useChat に渡している。useChat 側はメッセージ送信完了時にこの関数を呼び出す。</p>
</div>

<hr />
<h3 id="step-2-ヘルパー関数">Step 2: ヘルパー関数<a class="header-link" href="#step-2-ヘルパー関数" title="Permanent link">&para;</a></h3>
<p>メイン関数の中で繰り返し使う処理を、先に関数として定義しておきます。</p>
<div class="codehilite"><pre><span></span><code><span class="c1">// ─────────────────────────────────────────────────────────────────</span>
<span class="c1">// ヘルパー関数</span>
<span class="c1">// ─────────────────────────────────────────────────────────────────</span>

<span class="cm">/**</span>
<span class="cm"> * ユニークなIDを生成</span>
<span class="cm"> * crypto.randomUUID()を使用して衝突のないIDを生成</span>
<span class="cm"> */</span>
<span class="kd">function</span><span class="w"> </span><span class="nx">generateUniqueId</span><span class="p">()</span><span class="o">:</span><span class="w"> </span><span class="kt">string</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="nx">crypto</span><span class="p">.</span><span class="nx">randomUUID</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div>

<div class="info-box">
<h3>🔧 なぜヘルパー関数を作る？</h3>
<p>この関数は、下のメイン関数内で<strong>2回</strong>呼ばれます：</p>
<ol>
<li>ユーザーのメッセージを作るとき</li>
<li>AIの応答メッセージを作るとき</li>
</ol>

<p><strong>ヘルパー関数がない場合（同じ処理を2回書く）:</strong></p>
<pre>
const userMessage = {
  id: crypto.randomUUID(),  // 1回目
  ...
}
const assistantMessage = {
  id: crypto.randomUUID(),  // 2回目（コピペ）
  ...
}
</pre>

<p><strong>ヘルパー関数がある場合（関数を呼ぶだけ）:</strong></p>
<pre>
const userMessage = {
  id: generateUniqueId(),  // 意図が明確！
  ...
}
const assistantMessage = {
  id: generateUniqueId(),  // 同じ関数を再利用
  ...
}
</pre>

<p><strong>メリット:</strong></p>
<ul>
<li><strong>再利用</strong> - 同じ処理を何度でも呼べる</li>
<li><strong>可読性</strong> - 「ユニークIDを生成」という意図が明確</li>
<li><strong>保守性</strong> - ID生成方法を変えたい時、1箇所だけ修正すればOK</li>
</ul>
</div>

<hr />
<h3 id="step-3-メイン関数の状態定義">Step 3: メイン関数の状態定義<a class="header-link" href="#step-3-メイン関数の状態定義" title="Permanent link">&para;</a></h3>
<p>いよいよメイン関数です。まず、管理する「状態」を定義します。</p>
<div class="codehilite"><pre><span></span><code><span class="c1">// ─────────────────────────────────────────────────────────────────</span>
<span class="c1">// メイン関数</span>
<span class="c1">// ─────────────────────────────────────────────────────────────────</span>

<span class="k">export</span><span class="w"> </span><span class="kd">function</span><span class="w"> </span><span class="nx">useChat</span><span class="p">(</span><span class="nx">options?</span><span class="o">:</span><span class="w"> </span><span class="kt">UseChatOptions</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">activeSession</span><span class="p">,</span><span class="w"> </span><span class="nx">onMessagesUpdate</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">options</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="p">{}</span>

<span class="w">  </span><span class="c1">// 状態の定義</span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="p">[</span><span class="nx">messages</span><span class="p">,</span><span class="w"> </span><span class="nx">setMessages</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">useState</span><span class="p">&lt;</span><span class="nt">Message</span><span class="err">[]</span><span class="p">&gt;(</span><span class="nx">activeSession</span><span class="o">?</span><span class="p">.</span><span class="nx">messages</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="p">[])</span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="p">[</span><span class="nx">threadId</span><span class="p">,</span><span class="w"> </span><span class="nx">setThreadId</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">useState</span><span class="p">&lt;</span><span class="nt">string</span><span class="w"> </span><span class="err">|</span><span class="w"> </span><span class="na">null</span><span class="p">&gt;(</span><span class="nx">activeSession</span><span class="o">?</span><span class="p">.</span><span class="nx">threadId</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="kc">null</span><span class="p">)</span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="p">[</span><span class="nx">isLoading</span><span class="p">,</span><span class="w"> </span><span class="nx">setIsLoading</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">useState</span><span class="p">(</span><span class="kc">false</span><span class="p">)</span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="p">[</span><span class="nx">error</span><span class="p">,</span><span class="w"> </span><span class="nx">setError</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">useState</span><span class="p">&lt;</span><span class="nt">string</span><span class="w"> </span><span class="err">|</span><span class="w"> </span><span class="na">null</span><span class="p">&gt;(</span><span class="kc">null</span><span class="p">)</span>
</code></pre></div>

<div class="info-box">
<h3>📦 4つの状態（State）</h3>
<table>
<tr><th>状態</th><th>型</th><th>役割</th></tr>
<tr><td><code>messages</code></td><td><code>Message[]</code></td><td>チャットメッセージの配列</td></tr>
<tr><td><code>threadId</code></td><td><code>string | null</code></td><td>会話スレッドのID（バックエンドで管理）</td></tr>
<tr><td><code>isLoading</code></td><td><code>boolean</code></td><td>送信中かどうか</td></tr>
<tr><td><code>error</code></td><td><code>string | null</code></td><td>エラーメッセージ</td></tr>
</table>
</div>

<hr />
<h3 id="step-4-セッション切り替え時の処理">Step 4: セッション切り替え時の処理<a class="header-link" href="#step-4-セッション切り替え時の処理" title="Permanent link">&para;</a></h3>
<p>タブを切り替えた時に、そのセッションのメッセージを復元します。</p>
<div class="codehilite"><pre><span></span><code><span class="w">  </span><span class="c1">// アクティブセッションが変更されたらメッセージを復元</span>
<span class="w">  </span><span class="nx">useEffect</span><span class="p">(()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">activeSession</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="nx">setMessages</span><span class="p">(</span><span class="nx">activeSession</span><span class="p">.</span><span class="nx">messages</span><span class="p">)</span>
<span class="w">      </span><span class="nx">setThreadId</span><span class="p">(</span><span class="nx">activeSession</span><span class="p">.</span><span class="nx">threadId</span><span class="p">)</span>
<span class="w">      </span><span class="nx">setError</span><span class="p">(</span><span class="kc">null</span><span class="p">)</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">},</span><span class="w"> </span><span class="p">[</span><span class="nx">activeSession</span><span class="o">?</span><span class="p">.</span><span class="nx">id</span><span class="p">])</span>
</code></pre></div>

<div class="flow-box">
<h3>🔄 セッション切り替えの流れ</h3>
<pre>
[タブ1] をクリック
    │
    ▼
activeSession が変わる
    │
    ▼
useEffect が発火
    │
    ▼
setMessages(タブ1のメッセージ) → 画面に表示
</pre>
</div>

<hr />
<h3 id="step-5-メッセージ送信処理sendmessage">Step 5: メッセージ送信処理（sendMessage）<a class="header-link" href="#step-5-メッセージ送信処理sendmessage" title="Permanent link">&para;</a></h3>
<h4 id="usecallback-と-useeffect-の違い">useCallback と useEffect の違い<a class="header-link" href="#usecallback-と-useeffect-の違い" title="Permanent link">&para;</a></h4>
<p>コードを読む前に、<code>useCallback</code> について説明します。<br />
見た目が <code>useEffect</code> に似ているので、混乱しやすいポイントです。</p>
<div class="codehilite"><pre><span></span><code><span class="c1">// これは useEffect（副作用を実行）</span>
<span class="nx">useEffect</span><span class="p">(()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// 処理</span>
<span class="p">},</span><span class="w"> </span><span class="p">[</span><span class="nx">deps</span><span class="p">])</span>

<span class="c1">// これは useCallback（関数を作成）</span>
<span class="nx">useCallback</span><span class="p">(()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// 処理</span>
<span class="p">},</span><span class="w"> </span><span class="p">[</span><span class="nx">deps</span><span class="p">])</span>
</code></pre></div>

<p>どちらも同じような形をしていますが、目的が全く違います。</p>
<table>
<thead>
<tr>
<th>フック</th>
<th>目的</th>
<th>何が起きる？</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>useEffect</code></td>
<td>副作用を実行</td>
<td>処理が自動的に実行される</td>
</tr>
<tr>
<td><code>useCallback</code></td>
<td>関数を作成</td>
<td>関数が作られ、変数に入る</td>
</tr>
</tbody>
</table>
<p><strong>useEffect の場合：</strong></p>
<div class="codehilite"><pre><span></span><code><span class="nx">useEffect</span><span class="p">(()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">&quot;実行された！&quot;</span><span class="p">)</span><span class="w">  </span><span class="c1">// ← コンポーネント表示時に自動実行</span>
<span class="p">},</span><span class="w"> </span><span class="p">[])</span>
</code></pre></div>

<p><strong>useCallback の場合：</strong></p>
<div class="codehilite"><pre><span></span><code><span class="kd">const</span><span class="w"> </span><span class="nx">myFunction</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">useCallback</span><span class="p">(()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">&quot;実行された！&quot;</span><span class="p">)</span><span class="w">  </span><span class="c1">// ← まだ実行されない</span>
<span class="p">},</span><span class="w"> </span><span class="p">[])</span>

<span class="c1">// ↓ 呼び出すと実行される</span>
<span class="nx">myFunction</span><span class="p">()</span><span class="w">  </span><span class="c1">// &quot;実行された！&quot;</span>
</code></pre></div>

<p>Python で例えると：</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># useEffect のイメージ</span>
<span class="c1"># （クラスの初期化時に自動実行）</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Component</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;実行された！&quot;</span><span class="p">)</span>  <span class="c1"># 自動実行</span>

<span class="c1"># useCallback のイメージ</span>
<span class="c1"># （関数を定義するだけ）</span>
<span class="k">def</span><span class="w"> </span><span class="nf">my_function</span><span class="p">():</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;実行された！&quot;</span><span class="p">)</span>

<span class="n">my_function</span><span class="p">()</span>  <span class="c1"># 呼び出すと実行</span>
</code></pre></div>

<p><strong>では sendMessage の場合は？</strong></p>
<div class="codehilite"><pre><span></span><code><span class="kd">const</span><span class="w"> </span><span class="nx">sendMessage</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">useCallback</span><span class="p">(</span><span class="k">async</span><span class="w"> </span><span class="p">(</span><span class="nx">content</span><span class="o">:</span><span class="w"> </span><span class="kt">string</span><span class="p">)</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// 送信処理</span>
<span class="p">},</span><span class="w"> </span><span class="p">[</span><span class="nx">threadId</span><span class="p">,</span><span class="w"> </span><span class="nx">isLoading</span><span class="p">,</span><span class="w"> </span><span class="nx">messages</span><span class="p">])</span>
</code></pre></div>

<p>これは「sendMessage という関数を作っている」ということです。<br />
ユーザーが送信ボタンを押したときに、この関数が呼び出されます。</p>
<blockquote>
<p><strong>補足</strong>: <code>useCallback</code> を使わずに <code>const sendMessage = async (content) =&gt; { ... }</code> と書いても動作します。<code>useCallback</code> はパフォーマンス最適化のためのもので、初心者は「関数を作っている」と理解すればOKです。</p>
</blockquote>
<hr />
<p>ここが最も複雑な部分です。ユーザーがメッセージを送信した時の処理です。</p>
<div class="codehilite"><pre><span></span><code><span class="w">  </span><span class="c1">// メッセージを送信</span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="nx">sendMessage</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">useCallback</span><span class="p">(</span><span class="k">async</span><span class="w"> </span><span class="p">(</span><span class="nx">content</span><span class="o">:</span><span class="w"> </span><span class="kt">string</span><span class="p">)</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="nx">content</span><span class="p">.</span><span class="nx">trim</span><span class="p">()</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="nx">isLoading</span><span class="p">)</span><span class="w"> </span><span class="k">return</span>

<span class="w">    </span><span class="nx">setError</span><span class="p">(</span><span class="kc">null</span><span class="p">)</span>
<span class="w">    </span><span class="nx">setIsLoading</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span>

<span class="w">    </span><span class="c1">// ─────────────────────────────────────────────────────────────</span>
<span class="w">    </span><span class="c1">// Step A: ユーザーメッセージを追加</span>
<span class="w">    </span><span class="c1">// ─────────────────────────────────────────────────────────────</span>
<span class="w">    </span><span class="kd">const</span><span class="w"> </span><span class="nx">userMessage</span><span class="o">:</span><span class="w"> </span><span class="kt">Message</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="nx">id</span><span class="o">:</span><span class="w"> </span><span class="kt">generateUniqueId</span><span class="p">(),</span><span class="w">  </span><span class="c1">// ← ヘルパー関数を使用</span>
<span class="w">      </span><span class="nx">role</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;user&#39;</span><span class="p">,</span>
<span class="w">      </span><span class="nx">content</span><span class="p">,</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="kd">const</span><span class="w"> </span><span class="nx">updatedMessagesWithUser</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[...</span><span class="nx">messages</span><span class="p">,</span><span class="w"> </span><span class="nx">userMessage</span><span class="p">]</span>
<span class="w">    </span><span class="nx">setMessages</span><span class="p">(</span><span class="nx">updatedMessagesWithUser</span><span class="p">)</span>

<span class="w">    </span><span class="c1">// ─────────────────────────────────────────────────────────────</span>
<span class="w">    </span><span class="c1">// Step B: AIの応答用プレースホルダーを追加</span>
<span class="w">    </span><span class="c1">// ─────────────────────────────────────────────────────────────</span>
<span class="w">    </span><span class="kd">const</span><span class="w"> </span><span class="nx">assistantMessageId</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">generateUniqueId</span><span class="p">()</span><span class="w">  </span><span class="c1">// ← ヘルパー関数を使用</span>
<span class="w">    </span><span class="kd">const</span><span class="w"> </span><span class="nx">assistantMessage</span><span class="o">:</span><span class="w"> </span><span class="kt">Message</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="nx">id</span><span class="o">:</span><span class="w"> </span><span class="kt">assistantMessageId</span><span class="p">,</span>
<span class="w">      </span><span class="nx">role</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;assistant&#39;</span><span class="p">,</span>
<span class="w">      </span><span class="nx">content</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;&#39;</span><span class="p">,</span><span class="w">  </span><span class="c1">// 最初は空</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="kd">const</span><span class="w"> </span><span class="nx">updatedMessagesWithAssistant</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[...</span><span class="nx">updatedMessagesWithUser</span><span class="p">,</span><span class="w"> </span><span class="nx">assistantMessage</span><span class="p">]</span>
<span class="w">    </span><span class="nx">setMessages</span><span class="p">(</span><span class="nx">updatedMessagesWithAssistant</span><span class="p">)</span>
</code></pre></div>

<div class="flow-box">
<h3>📝 Step A → B の画面変化</h3>
<pre>
【Step A: ユーザーメッセージ追加】

┌─────────────────────────────────────┐
│ 🧑 こんにちは                         │  ← ユーザーのメッセージが表示
└─────────────────────────────────────┘

【Step B: プレースホルダー追加】

┌─────────────────────────────────────┐
│ 🧑 こんにちは                         │
├─────────────────────────────────────┤
│ 🤖 （空）                             │  ← AIの応答欄が追加（まだ空）
└─────────────────────────────────────┘
</pre>
</div>

<hr />
<h3 id="step-6-aiの応答を受信">Step 6: AIの応答を受信<a class="header-link" href="#step-6-aiの応答を受信" title="Permanent link">&para;</a></h3>
<p>AIからの応答を受信します。</p>
<div class="codehilite"><pre><span></span><code><span class="w">    </span><span class="c1">// ─────────────────────────────────────────────────────────────</span>
<span class="w">    </span><span class="c1">// Step C: AIの応答を受信（同期）</span>
<span class="w">    </span><span class="c1">// ─────────────────────────────────────────────────────────────</span>
<span class="w">    </span><span class="k">try</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="c1">// sendChatMessage でバックエンドにリクエストを送り、</span>
<span class="w">      </span><span class="c1">// AIの応答が返ってくるまで待機</span>
<span class="w">      </span><span class="kd">const</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">response</span><span class="p">,</span><span class="w"> </span><span class="nx">threadId</span><span class="o">:</span><span class="w"> </span><span class="kt">newThreadId</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">await</span><span class="w"> </span><span class="nx">sendChatMessage</span><span class="p">(</span>
<span class="w">        </span><span class="nx">content</span><span class="p">,</span><span class="w">      </span><span class="c1">// ユーザーが入力したメッセージ</span>
<span class="w">        </span><span class="nx">threadId</span><span class="p">,</span><span class="w">     </span><span class="c1">// 会話のID</span>
<span class="w">      </span><span class="p">)</span>

<span class="w">      </span><span class="c1">// AIの応答をメッセージに追加</span>
<span class="w">      </span><span class="kd">const</span><span class="w"> </span><span class="nx">assistantMessage</span><span class="o">:</span><span class="w"> </span><span class="kt">Message</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nx">id</span><span class="o">:</span><span class="w"> </span><span class="kt">generateUniqueId</span><span class="p">(),</span>
<span class="w">        </span><span class="nx">role</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;assistant&#39;</span><span class="p">,</span>
<span class="w">        </span><span class="nx">content</span><span class="o">:</span><span class="w"> </span><span class="kt">response</span><span class="p">,</span><span class="w">  </span><span class="c1">// AIからの完全な応答</span>
<span class="w">      </span><span class="p">}</span>

<span class="w">      </span><span class="kd">const</span><span class="w"> </span><span class="nx">finalMessages</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[...</span><span class="nx">updatedMessagesWithUser</span><span class="p">,</span><span class="w"> </span><span class="nx">assistantMessage</span><span class="p">]</span>
<span class="w">      </span><span class="nx">setMessages</span><span class="p">(</span><span class="nx">finalMessages</span><span class="p">)</span>
<span class="w">      </span><span class="nx">setThreadId</span><span class="p">(</span><span class="nx">newThreadId</span><span class="p">)</span>
</code></pre></div>

<div class="info-box">
<h3>📝 処理の流れ</h3>
<pre>
【Step A: ユーザーメッセージ追加】

┌─────────────────────────────────────┐
│ 🧑 こんにちは                         │  ← ユーザーのメッセージが表示
└─────────────────────────────────────┘
       ↓
【Step B: 待機中（isLoading = true）】

┌─────────────────────────────────────┐
│ 🧑 こんにちは                         │
├─────────────────────────────────────┤
│ 🤖 AIが考え中...                      │  ← 待機中UIが表示
└─────────────────────────────────────┘
       ↓
【Step C: 応答受信（isLoading = false）】

┌─────────────────────────────────────┐
│ 🧑 こんにちは                         │
├─────────────────────────────────────┤
│ 🤖 こんにちは！何かお手伝いできますか？ │  ← AIの応答が一括で表示
└─────────────────────────────────────┘
</pre>
</div>

<div class="flow-box">
<h3>📡 同期通信の仕組み</h3>
<pre>
[フロントエンド]                        [バックエンド]

sendMessage("こんにちは") ──────────────▶
      │
      │  isLoading = true
      │  「AIが考え中...」表示
      │
      ▼  (待機中...)
                                       AI処理中...
                                            │
◀───────────────────────────────────────────┘
      │   { response: "こんにちは！何かお手伝いできますか？", threadId: "..." }
      │
      │  isLoading = false
      │  応答を画面に表示
      ▼
</pre>
<p>💡 AIの処理中は「AIが考え中...」と表示され、応答が返ってきたら一括で表示されます</p>
</div>

<hr />
<h3 id="step-7-成功時エラー時の処理">Step 7: 成功時・エラー時の処理<a class="header-link" href="#step-7-成功時エラー時の処理" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><code><span class="w">      </span><span class="c1">// ─────────────────────────────────────────────────────────────</span>
<span class="w">      </span><span class="c1">// 成功時：セッションにメッセージを保存</span>
<span class="w">      </span><span class="c1">// ─────────────────────────────────────────────────────────────</span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">activeSession</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="nx">onMessagesUpdate</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// ↑ activeSession があり、かつ onMessagesUpdate 関数が渡されていれば</span>

<span class="w">        </span><span class="nx">onMessagesUpdate</span><span class="p">(</span><span class="nx">activeSession</span><span class="p">.</span><span class="nx">id</span><span class="p">,</span><span class="w"> </span><span class="nx">finalMessages</span><span class="p">,</span><span class="w"> </span><span class="nx">newThreadId</span><span class="p">)</span>
<span class="w">        </span><span class="c1">// ↑ 親コンポーネントに「メッセージが更新されたよ」と通知</span>
<span class="w">        </span><span class="c1">// これにより localStorage にも保存される</span>
<span class="w">        </span><span class="c1">// ※ この関数は「8. useSessions.ts - セッション管理の完全解説」で詳しく説明します</span>
<span class="w">      </span><span class="p">}</span>

<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">catch</span><span class="w"> </span><span class="p">(</span><span class="nx">err</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="c1">// ─────────────────────────────────────────────────────────────</span>
<span class="w">      </span><span class="c1">// エラー時の処理</span>
<span class="w">      </span><span class="c1">// ─────────────────────────────────────────────────────────────</span>

<span class="w">      </span><span class="c1">// エラーメッセージを取り出す</span>
<span class="w">      </span><span class="kd">const</span><span class="w"> </span><span class="nx">errorMessage</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="ow">instanceof</span><span class="w"> </span><span class="ne">Error</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="nx">err</span><span class="p">.</span><span class="nx">message</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;エラーが発生しました&#39;</span>
<span class="w">      </span><span class="c1">// ↑ err が Error オブジェクトなら .message を取得</span>
<span class="w">      </span><span class="c1">//   そうでなければ固定文字列を使う</span>

<span class="w">      </span><span class="nx">setError</span><span class="p">(</span><span class="nx">errorMessage</span><span class="p">)</span><span class="w">  </span><span class="c1">// 画面にエラーを表示</span>

<span class="w">      </span><span class="c1">// 失敗したAIメッセージを削除</span>
<span class="w">      </span><span class="nx">setMessages</span><span class="p">(</span><span class="nx">prev</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="nx">prev</span><span class="p">.</span><span class="nx">filter</span><span class="p">(</span><span class="nx">msg</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="nx">msg</span><span class="p">.</span><span class="nx">id</span><span class="w"> </span><span class="o">!==</span><span class="w"> </span><span class="nx">assistantMessageId</span><span class="p">))</span>
<span class="w">      </span><span class="c1">// ↑ filter = 条件に合うものだけ残す</span>
<span class="w">      </span><span class="c1">// 「AIメッセージ以外を残す」= 「AIメッセージを削除」</span>
<span class="w">      </span><span class="c1">// Python: [msg for msg in prev if msg[&quot;id&quot;] != assistant_message_id]</span>

<span class="w">      </span><span class="c1">// ユーザーメッセージは残す（再送信できるように）</span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">activeSession</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="nx">onMessagesUpdate</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nx">onMessagesUpdate</span><span class="p">(</span><span class="nx">activeSession</span><span class="p">.</span><span class="nx">id</span><span class="p">,</span><span class="w"> </span><span class="nx">updatedMessagesWithUser</span><span class="p">,</span><span class="w"> </span><span class="nx">threadId</span><span class="p">)</span>
<span class="w">      </span><span class="p">}</span>

<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">finally</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="c1">// ─────────────────────────────────────────────────────────────</span>
<span class="w">      </span><span class="c1">// 成功でもエラーでも必ず実行される</span>
<span class="w">      </span><span class="c1">// ─────────────────────────────────────────────────────────────</span>
<span class="w">      </span><span class="nx">setIsLoading</span><span class="p">(</span><span class="kc">false</span><span class="p">)</span><span class="w">  </span><span class="c1">// 「送信中...」状態を解除</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">},</span><span class="w"> </span><span class="p">[</span><span class="nx">threadId</span><span class="p">,</span><span class="w"> </span><span class="nx">isLoading</span><span class="p">,</span><span class="w"> </span><span class="nx">messages</span><span class="p">,</span><span class="w"> </span><span class="nx">activeSession</span><span class="p">,</span><span class="w"> </span><span class="nx">onMessagesUpdate</span><span class="p">])</span>
<span class="w">  </span><span class="c1">// ↑ useCallback の依存配列</span>
<span class="w">  </span><span class="c1">// これらの値が変わったときだけ、関数を作り直す</span>
</code></pre></div>

<div class="info-box">
<h3>🔍 コードの詳細解説</h3>

**1. `err instanceof Error` とは？**


<div class="codehilite"><pre><span></span><code><span class="nx">err</span><span class="w"> </span><span class="ow">instanceof</span><span class="w"> </span><span class="ne">Error</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="nx">err</span><span class="p">.</span><span class="nx">message</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;エラーが発生しました&#39;</span>
</code></pre></div>



- `instanceof` = 「〜のインスタンスか？」を判定
- `err` が Error オブジェクトなら `.message` プロパティがある
- そうでなければ（文字列など）固定メッセージを使う

Python で書くと：

<div class="codehilite"><pre><span></span><code><span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">err</span><span class="p">,</span> <span class="ne">Exception</span><span class="p">):</span>
    <span class="n">error_message</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">err</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
    <span class="n">error_message</span> <span class="o">=</span> <span class="s2">&quot;エラーが発生しました&quot;</span>
</code></pre></div>



**2. `.filter()` とは？**


<div class="codehilite"><pre><span></span><code><span class="nx">prev</span><span class="p">.</span><span class="nx">filter</span><span class="p">(</span><span class="nx">msg</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="nx">msg</span><span class="p">.</span><span class="nx">id</span><span class="w"> </span><span class="o">!==</span><span class="w"> </span><span class="nx">assistantMessageId</span><span class="p">)</span>
</code></pre></div>



- 条件が `true` の要素だけを残した新しい配列を作る
- `msg.id !== assistantMessageId` = 「AIメッセージ以外」

Python で書くと：

<div class="codehilite"><pre><span></span><code><span class="p">[</span><span class="n">msg</span> <span class="k">for</span> <span class="n">msg</span> <span class="ow">in</span> <span class="n">prev</span> <span class="k">if</span> <span class="n">msg</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">]</span> <span class="o">!=</span> <span class="n">assistant_message_id</span><span class="p">]</span>
</code></pre></div>



**3. `finally` ブロック**


<div class="codehilite"><pre><span></span><code><span class="k">try</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="k">catch</span><span class="w"> </span><span class="p">(</span><span class="nx">err</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="k">finally</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span>
</code></pre></div>



- `finally` は成功でもエラーでも **必ず実行される**
- ローディング状態の解除など、後片付けに使う

Python で書くと：

<div class="codehilite"><pre><span></span><code><span class="k">try</span><span class="p">:</span>
    <span class="o">...</span>
<span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
    <span class="o">...</span>
<span class="k">finally</span><span class="p">:</span>
    <span class="n">is_loading</span> <span class="o">=</span> <span class="kc">False</span>  <span class="c1"># 必ず実行</span>
</code></pre></div>



</div>

<div class="info-box">
<h3>✅ 成功時 vs ❌ エラー時</h3>
<table>
<tr><th></th><th>成功時</th><th>エラー時</th></tr>
<tr><td>ユーザーメッセージ</td><td>保存</td><td>保存</td></tr>
<tr><td>AIメッセージ</td><td>保存</td><td><strong>削除</strong></td></tr>
<tr><td>エラー表示</td><td>なし</td><td>表示</td></tr>
</table>
<p>💡 エラー時にAIメッセージを削除するのは、空のメッセージが残らないようにするため</p>
</div>

<hr />
<h3 id="step-8-戻り値">Step 8: 戻り値<a class="header-link" href="#step-8-戻り値" title="Permanent link">&para;</a></h3>
<p>最後に、このフックを使う側が必要なものを返します。</p>
<div class="codehilite"><pre><span></span><code><span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">messages</span><span class="p">,</span><span class="w">      </span><span class="c1">// メッセージ一覧</span>
<span class="w">    </span><span class="nx">isLoading</span><span class="p">,</span><span class="w">     </span><span class="c1">// 送信中か</span>
<span class="w">    </span><span class="nx">error</span><span class="p">,</span><span class="w">         </span><span class="c1">// エラーメッセージ</span>
<span class="w">    </span><span class="nx">sendMessage</span><span class="p">,</span><span class="w">   </span><span class="c1">// 送信関数</span>
<span class="w">    </span><span class="nx">threadId</span><span class="p">,</span><span class="w">      </span><span class="c1">// スレッドID</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>

<div class="flow-box">
<h3>📤 App.tsx での使い方</h3>
<pre>
// App.tsx で useChat を呼び出す
const { messages, isLoading, error, sendMessage } = useChat({
  activeSession,
  onMessagesUpdate: updateSessionMessages,
})

// 画面に表示
messages.map(msg => &lt;Message key={msg.id} ... /&gt;)

// 送信ボタンで呼び出し
&lt;button onClick={() => sendMessage(input)}&gt;送信&lt;/button&gt;
</pre>
</div>

<hr />
<h3 id="コードの構造まとめ">コードの構造まとめ<a class="header-link" href="#コードの構造まとめ" title="Permanent link">&para;</a></h3>
<div class="flow-box">
<h3>📐 useChat.ts の全体構造</h3>
<pre>
┌─────────────────────────────────────────────────────────────────┐
│ 1. インポート                                                     │
│    - React のフック (useState, useCallback, useEffect)           │
│    - API 関数 (sendChatMessage)                                  │
│    - 型 (ChatSession)                                            │
├─────────────────────────────────────────────────────────────────┤
│ 2. 型定義                                                        │
│    - export interface Message     ← 他ファイルでも使う           │
│    - interface UseChatOptions     ← このファイル内だけ           │
├─────────────────────────────────────────────────────────────────┤
│ 3. ヘルパー関数                                                   │
│    - generateUniqueId()           ← メイン関数内で2回使用        │
├─────────────────────────────────────────────────────────────────┤
│ 4. メイン関数 (export function useChat)                          │
│    - 状態定義 (useState × 4)                                     │
│    - セッション切り替え (useEffect)                               │
│    - メッセージ送信 (sendMessage)                                 │
│    - 戻り値 (return)                                              │
└─────────────────────────────────────────────────────────────────┘
</pre>
</div>

<details>
<summary><strong>📄 完全なコード（全体を見たい場合はクリック）</strong></summary>


<div class="codehilite"><pre><span></span><code><span class="c1">// ファイル: frontend/src/hooks/useChat.ts</span>

<span class="k">import</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">useState</span><span class="p">,</span><span class="w"> </span><span class="nx">useCallback</span><span class="p">,</span><span class="w"> </span><span class="nx">useEffect</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="kr">from</span><span class="w"> </span><span class="s1">&#39;react&#39;</span>
<span class="k">import</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">sendChatMessage</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="kr">from</span><span class="w"> </span><span class="s1">&#39;../services/api&#39;</span>
<span class="k">import</span><span class="w"> </span><span class="kr">type</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">ChatSession</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="kr">from</span><span class="w"> </span><span class="s1">&#39;./useSessions&#39;</span>

<span class="cm">/** メッセージの型 */</span>
<span class="k">export</span><span class="w"> </span><span class="kd">interface</span><span class="w"> </span><span class="nx">Message</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">id</span><span class="o">:</span><span class="w"> </span><span class="kt">string</span>
<span class="w">  </span><span class="nx">role</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;user&#39;</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="s1">&#39;assistant&#39;</span>
<span class="w">  </span><span class="nx">content</span><span class="o">:</span><span class="w"> </span><span class="kt">string</span>
<span class="p">}</span>

<span class="cm">/** useChat のオプション型 */</span>
<span class="kd">interface</span><span class="w"> </span><span class="nx">UseChatOptions</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">activeSession</span><span class="o">:</span><span class="w"> </span><span class="kt">ChatSession</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="kc">null</span>
<span class="w">  </span><span class="nx">onMessagesUpdate</span><span class="o">:</span><span class="w"> </span><span class="p">(</span><span class="nx">sessionId</span><span class="o">:</span><span class="w"> </span><span class="kt">string</span><span class="p">,</span><span class="w"> </span><span class="nx">messages</span><span class="o">:</span><span class="w"> </span><span class="kt">Message</span><span class="p">[],</span><span class="w"> </span><span class="nx">threadId</span><span class="o">:</span><span class="w"> </span><span class="kt">string</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="kc">null</span><span class="p">)</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="ow">void</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ユニークなIDを生成</span>
<span class="cm"> */</span>
<span class="kd">function</span><span class="w"> </span><span class="nx">generateUniqueId</span><span class="p">()</span><span class="o">:</span><span class="w"> </span><span class="kt">string</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="nx">crypto</span><span class="p">.</span><span class="nx">randomUUID</span><span class="p">()</span>
<span class="p">}</span>

<span class="k">export</span><span class="w"> </span><span class="kd">function</span><span class="w"> </span><span class="nx">useChat</span><span class="p">(</span><span class="nx">options?</span><span class="o">:</span><span class="w"> </span><span class="kt">UseChatOptions</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">activeSession</span><span class="p">,</span><span class="w"> </span><span class="nx">onMessagesUpdate</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">options</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="p">{}</span>

<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="p">[</span><span class="nx">messages</span><span class="p">,</span><span class="w"> </span><span class="nx">setMessages</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">useState</span><span class="p">&lt;</span><span class="nt">Message</span><span class="err">[]</span><span class="p">&gt;(</span><span class="nx">activeSession</span><span class="o">?</span><span class="p">.</span><span class="nx">messages</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="p">[])</span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="p">[</span><span class="nx">threadId</span><span class="p">,</span><span class="w"> </span><span class="nx">setThreadId</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">useState</span><span class="p">&lt;</span><span class="nt">string</span><span class="w"> </span><span class="err">|</span><span class="w"> </span><span class="na">null</span><span class="p">&gt;(</span><span class="nx">activeSession</span><span class="o">?</span><span class="p">.</span><span class="nx">threadId</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="kc">null</span><span class="p">)</span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="p">[</span><span class="nx">isLoading</span><span class="p">,</span><span class="w"> </span><span class="nx">setIsLoading</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">useState</span><span class="p">(</span><span class="kc">false</span><span class="p">)</span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="p">[</span><span class="nx">error</span><span class="p">,</span><span class="w"> </span><span class="nx">setError</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">useState</span><span class="p">&lt;</span><span class="nt">string</span><span class="w"> </span><span class="err">|</span><span class="w"> </span><span class="na">null</span><span class="p">&gt;(</span><span class="kc">null</span><span class="p">)</span>

<span class="w">  </span><span class="nx">useEffect</span><span class="p">(()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">activeSession</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="nx">setMessages</span><span class="p">(</span><span class="nx">activeSession</span><span class="p">.</span><span class="nx">messages</span><span class="p">)</span>
<span class="w">      </span><span class="nx">setThreadId</span><span class="p">(</span><span class="nx">activeSession</span><span class="p">.</span><span class="nx">threadId</span><span class="p">)</span>
<span class="w">      </span><span class="nx">setError</span><span class="p">(</span><span class="kc">null</span><span class="p">)</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">},</span><span class="w"> </span><span class="p">[</span><span class="nx">activeSession</span><span class="o">?</span><span class="p">.</span><span class="nx">id</span><span class="p">])</span>

<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="nx">sendMessage</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">useCallback</span><span class="p">(</span><span class="k">async</span><span class="w"> </span><span class="p">(</span><span class="nx">content</span><span class="o">:</span><span class="w"> </span><span class="kt">string</span><span class="p">)</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="nx">content</span><span class="p">.</span><span class="nx">trim</span><span class="p">()</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="nx">isLoading</span><span class="p">)</span><span class="w"> </span><span class="k">return</span>

<span class="w">    </span><span class="nx">setError</span><span class="p">(</span><span class="kc">null</span><span class="p">)</span>
<span class="w">    </span><span class="nx">setIsLoading</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span>

<span class="w">    </span><span class="kd">const</span><span class="w"> </span><span class="nx">userMessage</span><span class="o">:</span><span class="w"> </span><span class="kt">Message</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="nx">id</span><span class="o">:</span><span class="w"> </span><span class="kt">generateUniqueId</span><span class="p">(),</span>
<span class="w">      </span><span class="nx">role</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;user&#39;</span><span class="p">,</span>
<span class="w">      </span><span class="nx">content</span><span class="p">,</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kd">const</span><span class="w"> </span><span class="nx">updatedMessagesWithUser</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[...</span><span class="nx">messages</span><span class="p">,</span><span class="w"> </span><span class="nx">userMessage</span><span class="p">]</span>
<span class="w">    </span><span class="nx">setMessages</span><span class="p">(</span><span class="nx">updatedMessagesWithUser</span><span class="p">)</span>

<span class="w">    </span><span class="kd">const</span><span class="w"> </span><span class="nx">assistantMessageId</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">generateUniqueId</span><span class="p">()</span>
<span class="w">    </span><span class="kd">const</span><span class="w"> </span><span class="nx">assistantMessage</span><span class="o">:</span><span class="w"> </span><span class="kt">Message</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="nx">id</span><span class="o">:</span><span class="w"> </span><span class="kt">assistantMessageId</span><span class="p">,</span>
<span class="w">      </span><span class="nx">role</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;assistant&#39;</span><span class="p">,</span>
<span class="w">      </span><span class="nx">content</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;&#39;</span><span class="p">,</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kd">const</span><span class="w"> </span><span class="nx">updatedMessagesWithAssistant</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[...</span><span class="nx">updatedMessagesWithUser</span><span class="p">,</span><span class="w"> </span><span class="nx">assistantMessage</span><span class="p">]</span>
<span class="w">    </span><span class="nx">setMessages</span><span class="p">(</span><span class="nx">updatedMessagesWithAssistant</span><span class="p">)</span>

<span class="w">    </span><span class="k">try</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="kd">let</span><span class="w"> </span><span class="nx">currentContent</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">&#39;&#39;</span>

<span class="w">      </span><span class="kd">const</span><span class="w"> </span><span class="nx">newThreadId</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">await</span><span class="w"> </span><span class="nx">sendChatMessage</span><span class="p">(</span>
<span class="w">        </span><span class="nx">content</span><span class="p">,</span>
<span class="w">        </span><span class="nx">threadId</span><span class="p">,</span>
<span class="w">        </span><span class="p">(</span><span class="nx">chunk</span><span class="p">)</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">          </span><span class="nx">currentContent</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="nx">chunk</span>
<span class="w">          </span><span class="nx">setMessages</span><span class="p">(</span><span class="nx">prev</span><span class="w"> </span><span class="p">=&gt;</span>
<span class="w">            </span><span class="nx">prev</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">msg</span><span class="w"> </span><span class="p">=&gt;</span>
<span class="w">              </span><span class="nx">msg</span><span class="p">.</span><span class="nx">id</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="nx">assistantMessageId</span>
<span class="w">                </span><span class="o">?</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="nx">msg</span><span class="p">,</span><span class="w"> </span><span class="nx">content</span><span class="o">:</span><span class="w"> </span><span class="kt">currentContent</span><span class="w"> </span><span class="p">}</span>
<span class="w">                </span><span class="o">:</span><span class="w"> </span><span class="nx">msg</span>
<span class="w">            </span><span class="p">)</span>
<span class="w">          </span><span class="p">)</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">      </span><span class="p">)</span>

<span class="w">      </span><span class="nx">setThreadId</span><span class="p">(</span><span class="nx">newThreadId</span><span class="p">)</span>

<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">activeSession</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="nx">onMessagesUpdate</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kd">const</span><span class="w"> </span><span class="nx">finalMessages</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">updatedMessagesWithUser</span><span class="p">.</span><span class="nx">concat</span><span class="p">({</span>
<span class="w">          </span><span class="p">...</span><span class="nx">assistantMessage</span><span class="p">,</span>
<span class="w">          </span><span class="nx">content</span><span class="o">:</span><span class="w"> </span><span class="kt">currentContent</span><span class="p">,</span>
<span class="w">        </span><span class="p">})</span>
<span class="w">        </span><span class="nx">onMessagesUpdate</span><span class="p">(</span><span class="nx">activeSession</span><span class="p">.</span><span class="nx">id</span><span class="p">,</span><span class="w"> </span><span class="nx">finalMessages</span><span class="p">,</span><span class="w"> </span><span class="nx">newThreadId</span><span class="p">)</span>
<span class="w">      </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">catch</span><span class="w"> </span><span class="p">(</span><span class="nx">err</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="kd">const</span><span class="w"> </span><span class="nx">errorMessage</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">err</span><span class="w"> </span><span class="ow">instanceof</span><span class="w"> </span><span class="ne">Error</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="nx">err</span><span class="p">.</span><span class="nx">message</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;エラーが発生しました&#39;</span>
<span class="w">      </span><span class="nx">setError</span><span class="p">(</span><span class="nx">errorMessage</span><span class="p">)</span>

<span class="w">      </span><span class="nx">setMessages</span><span class="p">(</span><span class="nx">prev</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="nx">prev</span><span class="p">.</span><span class="nx">filter</span><span class="p">(</span><span class="nx">msg</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="nx">msg</span><span class="p">.</span><span class="nx">id</span><span class="w"> </span><span class="o">!==</span><span class="w"> </span><span class="nx">assistantMessageId</span><span class="p">))</span>

<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">activeSession</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="nx">onMessagesUpdate</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nx">onMessagesUpdate</span><span class="p">(</span><span class="nx">activeSession</span><span class="p">.</span><span class="nx">id</span><span class="p">,</span><span class="w"> </span><span class="nx">updatedMessagesWithUser</span><span class="p">,</span><span class="w"> </span><span class="nx">threadId</span><span class="p">)</span>
<span class="w">      </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">finally</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="nx">setIsLoading</span><span class="p">(</span><span class="kc">false</span><span class="p">)</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">},</span><span class="w"> </span><span class="p">[</span><span class="nx">threadId</span><span class="p">,</span><span class="w"> </span><span class="nx">isLoading</span><span class="p">,</span><span class="w"> </span><span class="nx">messages</span><span class="p">,</span><span class="w"> </span><span class="nx">activeSession</span><span class="p">,</span><span class="w"> </span><span class="nx">onMessagesUpdate</span><span class="p">])</span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">messages</span><span class="p">,</span>
<span class="w">    </span><span class="nx">isLoading</span><span class="p">,</span>
<span class="w">    </span><span class="nx">error</span><span class="p">,</span>
<span class="w">    </span><span class="nx">sendMessage</span><span class="p">,</span>
<span class="w">    </span><span class="nx">threadId</span><span class="p">,</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>



</details>

<hr />
<h2 id="8-usesessionsts---セッション管理の完全解説">8. useSessions.ts - セッション管理の完全解説<a class="header-link" href="#8-usesessionsts---セッション管理の完全解説" title="Permanent link">&para;</a></h2>
<p>複数の会話を管理する仕組みです。</p>
<div class="info-box">
<div class="box-title">🔗 useChat との連携</div>
<div class="box-content">

<strong>2つのフックの役割分担</strong>

<table>
<tr><th>フック</th><th>役割</th><th>担当</th></tr>
<tr><td><code>useChat</code></td><td>画面表示</td><td>「今」のメッセージを管理</td></tr>
<tr><td><code>useSessions</code></td><td>データ保存</td><td>ローカルストレージへの永続化</td></tr>
</table>

<strong>橋渡しの仕組み</strong>

<div style="display: flex; justify-content: center; align-items: center; gap: 20px; margin: 20px 0; padding: 20px; background: #f8f9fa; border-radius: 8px;">
  <div style="text-align: center; font-weight: bold; padding: 10px 20px; background: #e3f2fd; border-radius: 8px;">useSessions<br><span style="font-size: 0.8em; font-weight: normal;">（データ保存）</span></div>
  <div style="display: flex; flex-direction: column; gap: 15px;">
    <div style="display: flex; align-items: center; gap: 10px;">
      <code style="background: #fff3e0; padding: 4px 8px; border-radius: 4px;">activeSession</code>
      <span style="font-size: 1.5em;">→</span>
      <span style="font-size: 0.9em;">「このセッションを表示して」</span>
    </div>
    <div style="display: flex; align-items: center; gap: 10px;">
      <code style="background: #e8f5e9; padding: 4px 8px; border-radius: 4px;">onMessagesUpdate</code>
      <span style="font-size: 1.5em;">←</span>
      <span style="font-size: 0.9em;">「メッセージ更新したから保存して」</span>
    </div>
  </div>
  <div style="text-align: center; font-weight: bold; padding: 10px 20px; background: #fce4ec; border-radius: 8px;">useChat<br><span style="font-size: 0.8em; font-weight: normal;">（画面表示）</span></div>
</div>

<p>App.tsx でこの2つのフックを接続しています（詳細は「7. useChat.ts」を参照）。</p>

</div>
</div>

<h3 id="主な機能">主な機能<a class="header-link" href="#主な機能" title="Permanent link">&para;</a></h3>
<table>
<thead>
<tr>
<th>機能</th>
<th>説明</th>
</tr>
</thead>
<tbody>
<tr>
<td>セッション作成</td>
<td>新しい会話を開始</td>
</tr>
<tr>
<td>セッション切り替え</td>
<td>過去の会話に戻る</td>
</tr>
<tr>
<td>セッション削除</td>
<td>不要な会話を削除</td>
</tr>
<tr>
<td>自動保存</td>
<td>ローカルストレージに保存</td>
</tr>
<tr>
<td>タイトル自動生成</td>
<td>最初のメッセージからタイトルを作成</td>
</tr>
</tbody>
</table>
<h3 id="インポート部分の解説_2">インポート部分の解説<a class="header-link" href="#インポート部分の解説_2" title="Permanent link">&para;</a></h3>
<div class="info-box">
<div class="box-title">📦 インポートの全体像</div>
<div class="box-content">


<div class="codehilite"><pre><span></span><code><span class="c1">// ファイル: frontend/src/hooks/useSessions.ts</span>

<span class="c1">// React のフック（状態管理・関数メモ化・副作用処理）</span>
<span class="k">import</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">useState</span><span class="p">,</span><span class="w"> </span><span class="nx">useCallback</span><span class="p">,</span><span class="w"> </span><span class="nx">useEffect</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="kr">from</span><span class="w"> </span><span class="s1">&#39;react&#39;</span>

<span class="c1">// 同じ hooks フォルダ内の useChat.ts から Message 型をインポート</span>
<span class="k">import</span><span class="w"> </span><span class="kr">type</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">Message</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="kr">from</span><span class="w"> </span><span class="s1">&#39;./useChat&#39;</span>
</code></pre></div>



</div>
</div>

<table>
<tr><th>インポート</th><th>種類</th><th>中身</th></tr>
<tr>
  <td><code>useState</code></td>
  <td>React フック</td>
  <td>状態（変数）を管理する</td>
</tr>
<tr>
  <td><code>useCallback</code></td>
  <td>React フック</td>
  <td>関数をメモ化（パフォーマンス最適化）</td>
</tr>
<tr>
  <td><code>useEffect</code></td>
  <td>React フック</td>
  <td>副作用（監視・通信など）を実行する</td>
</tr>
<tr>
  <td><code>Message</code></td>
  <td>型定義</td>
  <td>メッセージの型（<code>type</code>＝型だけインポート）</td>
</tr>
</table>

<div class="tip-box">
<div class="box-title">📂 相対パスの読み方</div>
<div class="box-content">


<div class="codehilite"><pre><span></span><code><span class="err">現在地</span><span class="o">:</span><span class="w"> </span><span class="n">frontend</span><span class="sr">/src/hooks/</span><span class="n">useSessions</span><span class="o">.</span><span class="na">ts</span>
<span class="o">./</span><span class="n">useChat</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="err">同じ</span><span class="w"> </span><span class="n">hooks</span><span class="w"> </span><span class="err">フォルダ内の</span><span class="w"> </span><span class="n">useChat</span><span class="o">.</span><span class="na">ts</span>
</code></pre></div>



</div>
</div>

<h3 id="完全なコード_1">完全なコード<a class="header-link" href="#完全なコード_1" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><code><span class="cm">/** ローカルストレージのキー */</span>
<span class="kd">const</span><span class="w"> </span><span class="nx">STORAGE_KEY</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">&#39;chat_sessions&#39;</span>

<span class="cm">/**</span>
<span class="cm"> * 最大セッション数</span>
<span class="cm"> * - ローカルストレージの容量制限（5-10MB）を考慮</span>
<span class="cm"> * - 1セッション約8KB（20メッセージ想定）× 10 = 約80KB</span>
<span class="cm"> */</span>
<span class="kd">const</span><span class="w"> </span><span class="nx">MAX_SESSIONS</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">10</span>

<span class="cm">/** デフォルトのセッションタイトル */</span>
<span class="kd">const</span><span class="w"> </span><span class="nx">DEFAULT_SESSION_TITLE</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">&#39;新しい会話&#39;</span>

<span class="cm">/**</span>
<span class="cm"> * チャットセッションの型定義</span>
<span class="cm"> */</span>
<span class="k">export</span><span class="w"> </span><span class="kd">interface</span><span class="w"> </span><span class="nx">ChatSession</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">id</span><span class="o">:</span><span class="w"> </span><span class="kt">string</span><span class="w">            </span><span class="c1">// 一意のセッションID</span>
<span class="w">  </span><span class="nx">title</span><span class="o">:</span><span class="w"> </span><span class="kt">string</span><span class="w">         </span><span class="c1">// セッションのタイトル</span>
<span class="w">  </span><span class="nx">messages</span><span class="o">:</span><span class="w"> </span><span class="kt">Message</span><span class="p">[]</span><span class="w">   </span><span class="c1">// メッセージ履歴</span>
<span class="w">  </span><span class="nx">threadId</span><span class="o">:</span><span class="w"> </span><span class="kt">string</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="kc">null</span><span class="w">  </span><span class="c1">// バックエンドとの会話スレッドID</span>
<span class="w">  </span><span class="nx">createdAt</span><span class="o">:</span><span class="w"> </span><span class="kt">number</span><span class="w">     </span><span class="c1">// 作成日時（Unix timestamp）</span>
<span class="w">  </span><span class="nx">updatedAt</span><span class="o">:</span><span class="w"> </span><span class="kt">number</span><span class="w">     </span><span class="c1">// 最終更新日時</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * セッションIDを生成</span>
<span class="cm"> * 形式: session_{timestamp}_{ランダム文字列}</span>
<span class="cm"> */</span>
<span class="kd">function</span><span class="w"> </span><span class="nx">generateSessionId</span><span class="p">()</span><span class="o">:</span><span class="w"> </span><span class="kt">string</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="sb">`session_</span><span class="si">${</span><span class="nb">Date</span><span class="p">.</span><span class="nx">now</span><span class="p">()</span><span class="si">}</span><span class="sb">_</span><span class="si">${</span><span class="nb">Math</span><span class="p">.</span><span class="nx">random</span><span class="p">().</span><span class="nx">toString</span><span class="p">(</span><span class="mf">36</span><span class="p">).</span><span class="nx">substr</span><span class="p">(</span><span class="mf">2</span><span class="p">,</span><span class="w"> </span><span class="mf">9</span><span class="p">)</span><span class="si">}</span><span class="sb">`</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * 新しい空のセッションを作成</span>
<span class="cm"> */</span>
<span class="kd">function</span><span class="w"> </span><span class="nx">createNewSession</span><span class="p">()</span><span class="o">:</span><span class="w"> </span><span class="nx">ChatSession</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">id</span><span class="o">:</span><span class="w"> </span><span class="kt">generateSessionId</span><span class="p">(),</span>
<span class="w">    </span><span class="nx">title</span><span class="o">:</span><span class="w"> </span><span class="kt">DEFAULT_SESSION_TITLE</span><span class="p">,</span>
<span class="w">    </span><span class="nx">messages</span><span class="o">:</span><span class="w"> </span><span class="p">[],</span>
<span class="w">    </span><span class="nx">threadId</span><span class="o">:</span><span class="w"> </span><span class="kt">null</span><span class="p">,</span>
<span class="w">    </span><span class="nx">createdAt</span><span class="o">:</span><span class="w"> </span><span class="kt">Date.now</span><span class="p">(),</span>
<span class="w">    </span><span class="nx">updatedAt</span><span class="o">:</span><span class="w"> </span><span class="kt">Date.now</span><span class="p">(),</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * ローカルストレージからセッション一覧を読み込み</span>
<span class="cm"> */</span>
<span class="kd">function</span><span class="w"> </span><span class="nx">loadSessionsFromStorage</span><span class="p">()</span><span class="o">:</span><span class="w"> </span><span class="nx">ChatSession</span><span class="p">[]</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">try</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">const</span><span class="w"> </span><span class="nx">stored</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">localStorage</span><span class="p">.</span><span class="nx">getItem</span><span class="p">(</span><span class="nx">STORAGE_KEY</span><span class="p">)</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">stored</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="nb">JSON</span><span class="p">.</span><span class="nx">parse</span><span class="p">(</span><span class="nx">stored</span><span class="p">)</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">catch</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// エラー時は空配列を返す（データ破損時の安全対策）</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="p">[]</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * セッション一覧をローカルストレージに保存</span>
<span class="cm"> */</span>
<span class="kd">function</span><span class="w"> </span><span class="nx">saveSessionsToStorage</span><span class="p">(</span><span class="nx">sessions</span><span class="o">:</span><span class="w"> </span><span class="kt">ChatSession</span><span class="p">[])</span><span class="o">:</span><span class="w"> </span><span class="ow">void</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">try</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">localStorage</span><span class="p">.</span><span class="nx">setItem</span><span class="p">(</span><span class="nx">STORAGE_KEY</span><span class="p">,</span><span class="w"> </span><span class="nb">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">(</span><span class="nx">sessions</span><span class="p">))</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">catch</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// 容量超過などのエラーは握りつぶす</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>

<div class="info-box">
<h3>💡 この2つの関数はいつ呼ばれる？</h3>
<div class="box-content">

<p><strong>loadSessionsFromStorage（読み込み）</strong></p>
<table>
<tr><th>タイミング</th><th>説明</th></tr>
<tr><td>ページをリロード（F5）</td><td>保存済みのセッションを復元</td></tr>
<tr><td>ブラウザを閉じて再度開く</td><td>保存済みのセッションを復元</td></tr>
<tr><td>URL を直接入力してアクセス</td><td>保存済みのセッションを復元</td></tr>
</table>

<p><strong>saveSessionsToStorage（保存）</strong></p>
<table>
<tr><th>タイミング</th><th>説明</th></tr>
<tr><td>メッセージを送信</td><td>会話内容を保存</td></tr>
<tr><td>新しいチャットを作成</td><td>新しいセッションを保存</td></tr>
<tr><td>チャットを削除</td><td>削除後の状態を保存</td></tr>
</table>

<p>保存は <code>useEffect</code> で <code>sessions</code> が変わるたびに自動実行されます（後述）。</p>

</div>
</div>

<div class="codehilite"><pre><span></span><code><span class="cm">/**</span>
<span class="cm"> * メッセージ内容からタイトルを生成</span>
<span class="cm"> * - 最大20文字まで</span>
<span class="cm"> * - 改行はスペースに変換</span>
<span class="cm"> */</span>
<span class="kd">function</span><span class="w"> </span><span class="nx">generateTitleFromMessage</span><span class="p">(</span><span class="nx">content</span><span class="o">:</span><span class="w"> </span><span class="kt">string</span><span class="p">)</span><span class="o">:</span><span class="w"> </span><span class="kt">string</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="nx">maxLength</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">20</span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="nx">trimmed</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">content</span><span class="p">.</span><span class="nx">trim</span><span class="p">().</span><span class="nx">replace</span><span class="p">(</span><span class="sr">/\n/g</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39; &#39;</span><span class="p">)</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">trimmed</span><span class="p">.</span><span class="nx">length</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="nx">maxLength</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nx">trimmed</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="nx">trimmed</span><span class="p">.</span><span class="nx">substring</span><span class="p">(</span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="nx">maxLength</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s1">&#39;...&#39;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * セッション管理フック</span>
<span class="cm"> */</span>
<span class="k">export</span><span class="w"> </span><span class="kd">function</span><span class="w"> </span><span class="nx">useSessions</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// ───────────────────────────────────────────────────────────────</span>
<span class="w">  </span><span class="c1">// セッション一覧</span>
<span class="w">  </span><span class="c1">// useState の初期化関数を使用（初回のみ実行）</span>
<span class="w">  </span><span class="c1">// ───────────────────────────────────────────────────────────────</span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="p">[</span><span class="nx">sessions</span><span class="p">,</span><span class="w"> </span><span class="nx">setSessions</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">useState</span><span class="p">&lt;</span><span class="nt">ChatSession</span><span class="err">[]</span><span class="p">&gt;(()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">const</span><span class="w"> </span><span class="nx">loaded</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">loadSessionsFromStorage</span><span class="p">()</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nx">loaded</span><span class="p">.</span><span class="nx">length</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="mf">0</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="p">[</span><span class="nx">createNewSession</span><span class="p">()]</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="nx">loaded</span>
<span class="w">  </span><span class="p">})</span>

<span class="w">  </span><span class="c1">// アクティブなセッションのID</span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="p">[</span><span class="nx">activeSessionId</span><span class="p">,</span><span class="w"> </span><span class="nx">setActiveSessionId</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">useState</span><span class="p">&lt;</span><span class="nt">string</span><span class="p">&gt;(</span>
<span class="w">    </span><span class="p">()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="nx">sessions</span><span class="p">[</span><span class="mf">0</span><span class="p">]</span><span class="o">?</span><span class="p">.</span><span class="nx">id</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="s1">&#39;&#39;</span>
<span class="w">  </span><span class="p">)</span>
</code></pre></div>

<div class="info-box">
<h3>💡 なぜ sessions[0] がアクティブになる？</h3>
<div class="box-content">

<p>新しいセッションは常に<strong>先頭に追加</strong>されます（後述の <code>createSession</code> で <code>[newSession, ...prev]</code> としている）。</p>

<p>つまり <code>sessions[0]</code> は<strong>「最後に作成したセッション」</strong>です。</p>

<pre>
【例】
1. セッションAを作成 → sessions = [A]
2. セッションBを作成 → sessions = [B, A]  ← Bが先頭
3. ブラウザを閉じて再アクセス
4. sessions[0] → B がアクティブになる
</pre>

<p><strong>注意:</strong> 「どのセッションを見ていたか」は保存されません。<br>
<code>activeSessionId</code> は localStorage に保存していないため、再アクセス時は常に最後に作成したセッションが表示されます。</p>

</div>
</div>

<div class="codehilite"><pre><span></span><code><span class="w">  </span><span class="c1">// 現在アクティブなセッション</span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="nx">activeSession</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">sessions</span><span class="p">.</span><span class="nx">find</span><span class="p">(</span><span class="nx">s</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="nx">s</span><span class="p">.</span><span class="nx">id</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="nx">activeSessionId</span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="nx">sessions</span><span class="p">[</span><span class="mf">0</span><span class="p">]</span>

<span class="w">  </span><span class="c1">// ───────────────────────────────────────────────────────────────</span>
<span class="w">  </span><span class="c1">// セッション変更時に自動保存</span>
<span class="w">  </span><span class="c1">// ───────────────────────────────────────────────────────────────</span>
<span class="w">  </span><span class="nx">useEffect</span><span class="p">(()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">saveSessionsToStorage</span><span class="p">(</span><span class="nx">sessions</span><span class="p">)</span>
<span class="w">  </span><span class="p">},</span><span class="w"> </span><span class="p">[</span><span class="nx">sessions</span><span class="p">])</span>

<span class="w">  </span><span class="c1">// ───────────────────────────────────────────────────────────────</span>
<span class="w">  </span><span class="c1">// 新しいセッションを作成</span>
<span class="w">  </span><span class="c1">// ───────────────────────────────────────────────────────────────</span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="nx">createSession</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">useCallback</span><span class="p">(()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">const</span><span class="w"> </span><span class="nx">newSession</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">createNewSession</span><span class="p">()</span>
<span class="w">    </span><span class="nx">setSessions</span><span class="p">(</span><span class="nx">prev</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="kd">const</span><span class="w"> </span><span class="nx">updated</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="nx">newSession</span><span class="p">,</span><span class="w"> </span><span class="p">...</span><span class="nx">prev</span><span class="p">]</span><span class="w">  </span><span class="c1">// 先頭に追加</span>
<span class="w">      </span><span class="c1">// 最大数を超えたら古いものを削除</span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">updated</span><span class="p">.</span><span class="nx">length</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="nx">MAX_SESSIONS</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nx">updated</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="nx">MAX_SESSIONS</span><span class="p">)</span>
<span class="w">      </span><span class="p">}</span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="nx">updated</span>
<span class="w">    </span><span class="p">})</span>
<span class="w">    </span><span class="nx">setActiveSessionId</span><span class="p">(</span><span class="nx">newSession</span><span class="p">.</span><span class="nx">id</span><span class="p">)</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nx">newSession</span><span class="p">.</span><span class="nx">id</span>
<span class="w">  </span><span class="p">},</span><span class="w"> </span><span class="p">[])</span>

<span class="w">  </span><span class="c1">// ───────────────────────────────────────────────────────────────</span>
<span class="w">  </span><span class="c1">// セッションを切り替え</span>
<span class="w">  </span><span class="c1">// ───────────────────────────────────────────────────────────────</span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="nx">switchSession</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">useCallback</span><span class="p">((</span><span class="nx">sessionId</span><span class="o">:</span><span class="w"> </span><span class="kt">string</span><span class="p">)</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">setActiveSessionId</span><span class="p">(</span><span class="nx">sessionId</span><span class="p">)</span>
<span class="w">  </span><span class="p">},</span><span class="w"> </span><span class="p">[])</span>

<span class="w">  </span><span class="c1">// ───────────────────────────────────────────────────────────────</span>
<span class="w">  </span><span class="c1">// セッションを削除</span>
<span class="w">  </span><span class="c1">// ───────────────────────────────────────────────────────────────</span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="nx">closeSession</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">useCallback</span><span class="p">((</span><span class="nx">sessionId</span><span class="o">:</span><span class="w"> </span><span class="kt">string</span><span class="p">)</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">setSessions</span><span class="p">(</span><span class="nx">prev</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="kd">const</span><span class="w"> </span><span class="nx">remainingSessions</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">prev</span><span class="p">.</span><span class="nx">filter</span><span class="p">(</span><span class="nx">s</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="nx">s</span><span class="p">.</span><span class="nx">id</span><span class="w"> </span><span class="o">!==</span><span class="w"> </span><span class="nx">sessionId</span><span class="p">)</span>

<span class="w">      </span><span class="c1">// 全て削除された場合は新しいセッションを作成</span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">remainingSessions</span><span class="p">.</span><span class="nx">length</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="mf">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kd">const</span><span class="w"> </span><span class="nx">newSession</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">createNewSession</span><span class="p">()</span>
<span class="w">        </span><span class="nx">setActiveSessionId</span><span class="p">(</span><span class="nx">newSession</span><span class="p">.</span><span class="nx">id</span><span class="p">)</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="p">[</span><span class="nx">newSession</span><span class="p">]</span>
<span class="w">      </span><span class="p">}</span>

<span class="w">      </span><span class="c1">// 削除されたのがアクティブセッションだった場合</span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">sessionId</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="nx">activeSessionId</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kd">const</span><span class="w"> </span><span class="nx">deletedIndex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">prev</span><span class="p">.</span><span class="nx">findIndex</span><span class="p">(</span><span class="nx">s</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="nx">s</span><span class="p">.</span><span class="nx">id</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="nx">sessionId</span><span class="p">)</span>
<span class="w">        </span><span class="kd">const</span><span class="w"> </span><span class="nx">nextIndex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Math</span><span class="p">.</span><span class="nx">min</span><span class="p">(</span><span class="nx">deletedIndex</span><span class="p">,</span><span class="w"> </span><span class="nx">remainingSessions</span><span class="p">.</span><span class="nx">length</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mf">1</span><span class="p">)</span>
<span class="w">        </span><span class="nx">setActiveSessionId</span><span class="p">(</span><span class="nx">remainingSessions</span><span class="p">[</span><span class="nx">nextIndex</span><span class="p">].</span><span class="nx">id</span><span class="p">)</span>
<span class="w">      </span><span class="p">}</span>

<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="nx">remainingSessions</span>
<span class="w">    </span><span class="p">})</span>
<span class="w">  </span><span class="p">},</span><span class="w"> </span><span class="p">[</span><span class="nx">activeSessionId</span><span class="p">])</span>

<span class="w">  </span><span class="c1">// ───────────────────────────────────────────────────────────────</span>
<span class="w">  </span><span class="c1">// セッションのメッセージを更新</span>
<span class="w">  </span><span class="c1">// ───────────────────────────────────────────────────────────────</span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="nx">updateSessionMessages</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">useCallback</span><span class="p">((</span>
<span class="w">    </span><span class="nx">sessionId</span><span class="o">:</span><span class="w"> </span><span class="kt">string</span><span class="p">,</span>
<span class="w">    </span><span class="nx">messages</span><span class="o">:</span><span class="w"> </span><span class="kt">Message</span><span class="p">[],</span>
<span class="w">    </span><span class="nx">threadId</span><span class="o">:</span><span class="w"> </span><span class="kt">string</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="kc">null</span>
<span class="w">  </span><span class="p">)</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">setSessions</span><span class="p">(</span><span class="nx">prev</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="nx">prev</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">session</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="c1">// map は配列の要素を1つずつ処理する</span>
<span class="w">      </span><span class="c1">// session には sessions[0], sessions[1], ... が順番に入る</span>
<span class="w">      </span><span class="c1">// IDが違う（更新対象外）ならそのまま返す</span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">session</span><span class="p">.</span><span class="nx">id</span><span class="w"> </span><span class="o">!==</span><span class="w"> </span><span class="nx">sessionId</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="nx">session</span>

<span class="w">      </span><span class="c1">// ↓ ここから下は、IDが一致した（更新対象の）セッションだけ実行される</span>

<span class="w">      </span><span class="c1">// タイトル自動生成（まだ「新しい会話」の場合のみ）</span>
<span class="w">      </span><span class="kd">let</span><span class="w"> </span><span class="nx">title</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">session</span><span class="p">.</span><span class="nx">title</span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">title</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="nx">DEFAULT_SESSION_TITLE</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="nx">messages</span><span class="p">.</span><span class="nx">length</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mf">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kd">const</span><span class="w"> </span><span class="nx">firstUserMessage</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">messages</span><span class="p">.</span><span class="nx">find</span><span class="p">(</span><span class="nx">m</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="nx">m</span><span class="p">.</span><span class="nx">role</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="s1">&#39;user&#39;</span><span class="p">)</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">firstUserMessage</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">          </span><span class="nx">title</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">generateTitleFromMessage</span><span class="p">(</span><span class="nx">firstUserMessage</span><span class="p">.</span><span class="nx">content</span><span class="p">)</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">      </span><span class="p">}</span>

<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="p">...</span><span class="nx">session</span><span class="p">,</span>
<span class="w">        </span><span class="nx">messages</span><span class="p">,</span>
<span class="w">        </span><span class="nx">threadId</span><span class="p">,</span>
<span class="w">        </span><span class="nx">title</span><span class="p">,</span>
<span class="w">        </span><span class="nx">updatedAt</span><span class="o">:</span><span class="w"> </span><span class="kt">Date.now</span><span class="p">(),</span>
<span class="w">      </span><span class="p">}</span>
<span class="w">    </span><span class="p">}))</span>
<span class="w">  </span><span class="p">},</span><span class="w"> </span><span class="p">[])</span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">sessions</span><span class="p">,</span><span class="w">              </span><span class="c1">// セッション一覧</span>
<span class="w">    </span><span class="nx">activeSession</span><span class="p">,</span><span class="w">         </span><span class="c1">// 現在のセッション</span>
<span class="w">    </span><span class="nx">activeSessionId</span><span class="p">,</span><span class="w">       </span><span class="c1">// 現在のセッションID</span>
<span class="w">    </span><span class="nx">createSession</span><span class="p">,</span><span class="w">         </span><span class="c1">// 新規作成</span>
<span class="w">    </span><span class="nx">switchSession</span><span class="p">,</span><span class="w">         </span><span class="c1">// 切り替え</span>
<span class="w">    </span><span class="nx">closeSession</span><span class="p">,</span><span class="w">          </span><span class="c1">// 削除</span>
<span class="w">    </span><span class="nx">updateSessionMessages</span><span class="p">,</span><span class="w"> </span><span class="c1">// メッセージ更新</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>

<h3 id="ローカルストレージの仕組み">ローカルストレージの仕組み<a class="header-link" href="#ローカルストレージの仕組み" title="Permanent link">&para;</a></h3>
<div class="info-box">
<h3>💾 ローカルストレージ</h3>
<p>ブラウザに内蔵された「簡易データベース」</p>

<table style="width: 100%; border-collapse: collapse; font-family: monospace; margin: 16px 0;">
<tr>
<td colspan="2" style="padding: 10px; border: 2px solid #333; background: #2d2d2d; color: #fff; font-weight: bold;">localStorage</td>
</tr>
<tr>
<td style="padding: 10px; border: 2px solid #333; background: #444; color: #fff; width: 30%; font-weight: bold;">キー</td>
<td style="padding: 10px; border: 2px solid #333; background: #444; color: #fff; font-weight: bold;">値</td>
</tr>
<tr>
<td style="padding: 10px; border: 2px solid #333; background: #1e1e1e;"><code style="background: transparent; color: #f8c555;">chat_sessions</code></td>
<td style="padding: 10px; border: 2px solid #333; background: #1e1e1e;"><code style="background: transparent; color: #98c379;">[{"id":"session_123", "title":"天気について", "messages":[...]}, {...}]</code></td>
</tr>
</table>
<p><strong>【特徴】</strong></p>
<ul>
<li>✅ ブラウザを閉じてもデータが残る</li>
<li>✅ 約 5-10MB まで保存可能</li>
<li>❌ 他のデバイスとは同期されない</li>
<li>❌ ブラウザのデータ削除で消える</li>
</ul>
<p><strong>【使い方】</strong></p>
<pre>
localStorage.setItem('key', 'value')  // 保存
localStorage.getItem('key')           // 取得
localStorage.removeItem('key')        // 削除
</pre>
<p>⚠️ 注意: 文字列しか保存できない<br>
→ オブジェクトは JSON.stringify() で文字列に変換<br>
→ 取得時は JSON.parse() でオブジェクトに戻す</p>
</div>

<hr />
<h2 id="9-apits---api通信の完全解説">9. api.ts - API通信の完全解説<a class="header-link" href="#9-apits---api通信の完全解説" title="Permanent link">&para;</a></h2>
<p>バックエンドとの通信を担当するモジュールです。</p>
<h3 id="インポート部分の解説_3">インポート部分の解説<a class="header-link" href="#インポート部分の解説_3" title="Permanent link">&para;</a></h3>
<div class="info-box">
<div class="box-title">📦 インポートの全体像</div>
<div class="box-content">


<div class="codehilite"><pre><span></span><code><span class="c1">// ファイル: frontend/src/services/api.ts</span>

<span class="c1">// 同じ services フォルダ内の firebase.ts から auth をインポート</span>
<span class="k">import</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">auth</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="kr">from</span><span class="w"> </span><span class="s1">&#39;./firebase&#39;</span>
</code></pre></div>



</div>
</div>

<table>
<tr><th>インポート</th><th>種類</th><th>中身</th></tr>
<tr>
  <td><code>auth</code></td>
  <td>自作モジュール</td>
  <td>Firebase 認証インスタンス<br>（現在のユーザー情報・IDトークン取得に使用）</td>
</tr>
</table>

<div class="tip-box">
<div class="box-title">📂 相対パスの読み方</div>
<div class="box-content">


<div class="codehilite"><pre><span></span><code><span class="err">現在地</span><span class="o">:</span><span class="w"> </span><span class="n">frontend</span><span class="sr">/src/services/</span><span class="n">api</span><span class="o">.</span><span class="na">ts</span>
<span class="o">./</span><span class="n">firebase</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="err">同じ</span><span class="w"> </span><span class="n">services</span><span class="w"> </span><span class="err">フォルダ内の</span><span class="w"> </span><span class="n">firebase</span><span class="o">.</span><span class="na">ts</span>
</code></pre></div>



</div>
</div>

<h3 id="完全なコード_2">完全なコード<a class="header-link" href="#完全なコード_2" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><code><span class="c1">// ファイル: frontend/src/services/api.ts</span>

<span class="k">import</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">auth</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="kr">from</span><span class="w"> </span><span class="s1">&#39;./firebase&#39;</span>

<span class="c1">// APIベースURL（環境変数から取得）</span>
<span class="kd">const</span><span class="w"> </span><span class="nx">API_BASE_URL</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">import</span><span class="p">.</span><span class="nx">meta</span><span class="p">.</span><span class="nx">env</span><span class="p">.</span><span class="nx">VITE_API_BASE_URL</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="s1">&#39;http://localhost:8080&#39;</span>

<span class="cm">/**</span>
<span class="cm"> * 認証トークンを取得</span>
<span class="cm"> *</span>
<span class="cm"> * Firebase からIDトークンを取得する。</span>
<span class="cm"> * このトークンがバックエンドへの「認証の証」になる。</span>
<span class="cm"> */</span>
<span class="k">async</span><span class="w"> </span><span class="kd">function</span><span class="w"> </span><span class="nx">getAuthToken</span><span class="p">()</span><span class="o">:</span><span class="w"> </span><span class="nb">Promise</span><span class="p">&lt;</span><span class="nt">string</span><span class="p">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="nx">user</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">auth</span><span class="p">.</span><span class="nx">currentUser</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="nx">user</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">throw</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="ne">Error</span><span class="p">(</span><span class="s1">&#39;ログインが必要です&#39;</span><span class="p">)</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="nx">user</span><span class="p">.</span><span class="nx">getIdToken</span><span class="p">()</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * 認証ヘッダーを生成</span>
<span class="cm"> *</span>
<span class="cm"> * HTTP リクエストに付加するヘッダーを作成。</span>
<span class="cm"> * Bearer トークン形式で認証情報を送る。</span>
<span class="cm"> */</span>
<span class="k">async</span><span class="w"> </span><span class="kd">function</span><span class="w"> </span><span class="nx">createAuthHeaders</span><span class="p">()</span><span class="o">:</span><span class="w"> </span><span class="nb">Promise</span><span class="p">&lt;</span><span class="nt">HeadersInit</span><span class="p">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="nx">token</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">await</span><span class="w"> </span><span class="nx">getAuthToken</span><span class="p">()</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="s1">&#39;Content-Type&#39;</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;application/json&#39;</span><span class="p">,</span>
<span class="w">    </span><span class="s1">&#39;Authorization&#39;</span><span class="o">:</span><span class="w"> </span><span class="sb">`Bearer </span><span class="si">${</span><span class="nx">token</span><span class="si">}</span><span class="sb">`</span><span class="p">,</span><span class="w">  </span><span class="c1">// これが認証の証！</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>

<span class="cm">/** sendChatMessage の戻り値型 */</span>
<span class="k">export</span><span class="w"> </span><span class="kd">interface</span><span class="w"> </span><span class="nx">ChatResponse</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">response</span><span class="o">:</span><span class="w"> </span><span class="kt">string</span>
<span class="w">  </span><span class="nx">threadId</span><span class="o">:</span><span class="w"> </span><span class="kt">string</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * チャットメッセージを送信</span>
<span class="cm"> *</span>
<span class="cm"> * @param message ユーザーのメッセージ</span>
<span class="cm"> * @param threadId スレッドID（省略可）</span>
<span class="cm"> * @returns レスポンスオブジェクト { response: string, threadId: string }</span>
<span class="cm"> */</span>
<span class="k">export</span><span class="w"> </span><span class="k">async</span><span class="w"> </span><span class="kd">function</span><span class="w"> </span><span class="nx">sendChatMessage</span><span class="p">(</span>
<span class="w">  </span><span class="nx">message</span><span class="o">:</span><span class="w"> </span><span class="kt">string</span><span class="p">,</span>
<span class="w">  </span><span class="nx">threadId</span><span class="o">:</span><span class="w"> </span><span class="kt">string</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="kc">null</span>
<span class="p">)</span><span class="o">:</span><span class="w"> </span><span class="nb">Promise</span><span class="p">&lt;</span><span class="nt">ChatResponse</span><span class="p">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// ─────────────────────────────────────────────────────────────</span>
<span class="w">  </span><span class="c1">// Step 1: 認証ヘッダーを作成</span>
<span class="w">  </span><span class="c1">// ─────────────────────────────────────────────────────────────</span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="nx">headers</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">await</span><span class="w"> </span><span class="nx">createAuthHeaders</span><span class="p">()</span>

<span class="w">  </span><span class="c1">// ─────────────────────────────────────────────────────────────</span>
<span class="w">  </span><span class="c1">// Step 2: APIにPOSTリクエスト</span>
<span class="w">  </span><span class="c1">// ─────────────────────────────────────────────────────────────</span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="nx">res</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">await</span><span class="w"> </span><span class="nx">fetch</span><span class="p">(</span><span class="sb">`</span><span class="si">${</span><span class="nx">API_BASE_URL</span><span class="si">}</span><span class="sb">/chat`</span><span class="p">,</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">method</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;POST&#39;</span><span class="p">,</span>
<span class="w">    </span><span class="nx">headers</span><span class="p">,</span>
<span class="w">    </span><span class="nx">body</span><span class="o">:</span><span class="w"> </span><span class="kt">JSON.stringify</span><span class="p">({</span>
<span class="w">      </span><span class="nx">message</span><span class="p">,</span>
<span class="w">      </span><span class="nx">thread_id</span><span class="o">:</span><span class="w"> </span><span class="kt">threadId</span><span class="p">,</span>
<span class="w">    </span><span class="p">}),</span>
<span class="w">  </span><span class="p">})</span>

<span class="w">  </span><span class="c1">// ─────────────────────────────────────────────────────────────</span>
<span class="w">  </span><span class="c1">// Step 3: エラーチェック</span>
<span class="w">  </span><span class="c1">// ─────────────────────────────────────────────────────────────</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="nx">res</span><span class="p">.</span><span class="nx">ok</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">const</span><span class="w"> </span><span class="nx">error</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">await</span><span class="w"> </span><span class="nx">res</span><span class="p">.</span><span class="nx">json</span><span class="p">()</span>
<span class="w">    </span><span class="k">throw</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="ne">Error</span><span class="p">(</span><span class="nx">error</span><span class="p">.</span><span class="nx">error</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="s1">&#39;エラーが発生しました&#39;</span><span class="p">)</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="c1">// ─────────────────────────────────────────────────────────────</span>
<span class="w">  </span><span class="c1">// Step 4: JSONレスポンスを取得</span>
<span class="w">  </span><span class="c1">// ─────────────────────────────────────────────────────────────</span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="nx">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">await</span><span class="w"> </span><span class="nx">res</span><span class="p">.</span><span class="nx">json</span><span class="p">()</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">response</span><span class="o">:</span><span class="w"> </span><span class="kt">data.data.response</span><span class="p">,</span>
<span class="w">    </span><span class="nx">threadId</span><span class="o">:</span><span class="w"> </span><span class="kt">data.data.thread_id</span><span class="p">,</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>

<div class="info-box">
<h3>📡 同期通信の流れ</h3>
<pre>
[フロントエンド]                        [バックエンド]

fetch("/chat", {...}) ──────────────────▶
      │                                      │
      │  await で応答待ち                    │
      │  （「AIが考え中...」表示）             │
      │                                      ▼
      │                                   AI処理
      │                                      │
◀────────────────────────────────────────────┘
      │   JSON: { response: "...", thread_id: "..." }
      │
      ▼
  応答を画面に表示
</pre>
<p>💡 シンプルなHTTP POST/レスポンスのやり取りです</p>
</div>

<hr />
<h2 id="10-firebasets---firebase初期化">10. firebase.ts - Firebase初期化<a class="header-link" href="#10-firebasets---firebase初期化" title="Permanent link">&para;</a></h2>
<p>Firebase SDKの初期化を行うファイルです。</p>
<h3 id="インポート部分の解説_4">インポート部分の解説<a class="header-link" href="#インポート部分の解説_4" title="Permanent link">&para;</a></h3>
<div class="info-box">
<div class="box-title">📦 インポートの全体像</div>
<div class="box-content">


<div class="codehilite"><pre><span></span><code><span class="c1">// ファイル: frontend/src/services/firebase.ts</span>

<span class="c1">// Firebase SDK からインポート</span>
<span class="k">import</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">initializeApp</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="kr">from</span><span class="w"> </span><span class="s1">&#39;firebase/app&#39;</span>
<span class="k">import</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">getAuth</span><span class="p">,</span><span class="w"> </span><span class="nx">GoogleAuthProvider</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="kr">from</span><span class="w"> </span><span class="s1">&#39;firebase/auth&#39;</span>
</code></pre></div>



</div>
</div>

<table>
<tr><th>インポート</th><th>種類</th><th>中身</th></tr>
<tr>
  <td><code>initializeApp</code></td>
  <td>Firebase Core</td>
  <td>Firebase アプリを初期化する関数<br>（<code>npm install firebase</code> で入る）</td>
</tr>
<tr>
  <td><code>getAuth</code></td>
  <td>Firebase Auth</td>
  <td>認証インスタンスを取得する関数</td>
</tr>
<tr>
  <td><code>GoogleAuthProvider</code></td>
  <td>Firebase Auth</td>
  <td>Google ログイン用のプロバイダー（クラス）</td>
</tr>
</table>

<div class="tip-box">
<div class="box-title">📂 パッケージのインポート</div>
<div class="box-content">


<div class="codehilite"><pre><span></span><code>&#39;firebase/app&#39;  = npm パッケージからインポート（node_modules 内）
&#39;firebase/auth&#39; = firebase パッケージの認証モジュール
</code></pre></div>



`./` や `../` がないパスは npm パッケージを指します。

</div>
</div>

<h3 id="完全なコード_3">完全なコード<a class="header-link" href="#完全なコード_3" title="Permanent link">&para;</a></h3>
<div class="codehilite"><pre><span></span><code><span class="c1">// ファイル: frontend/src/services/firebase.ts</span>

<span class="k">import</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">initializeApp</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="kr">from</span><span class="w"> </span><span class="s1">&#39;firebase/app&#39;</span>
<span class="k">import</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">getAuth</span><span class="p">,</span><span class="w"> </span><span class="nx">GoogleAuthProvider</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="kr">from</span><span class="w"> </span><span class="s1">&#39;firebase/auth&#39;</span>

<span class="c1">// Firebase設定（環境変数から取得）</span>
<span class="kd">const</span><span class="w"> </span><span class="nx">firebaseConfig</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">apiKey</span><span class="o">:</span><span class="w"> </span><span class="kt">import.meta.env.VITE_FIREBASE_API_KEY</span><span class="p">,</span>
<span class="w">  </span><span class="nx">authDomain</span><span class="o">:</span><span class="w"> </span><span class="kt">import.meta.env.VITE_FIREBASE_AUTH_DOMAIN</span><span class="p">,</span>
<span class="w">  </span><span class="nx">projectId</span><span class="o">:</span><span class="w"> </span><span class="kt">import.meta.env.VITE_FIREBASE_PROJECT_ID</span><span class="p">,</span>
<span class="p">}</span>

<span class="c1">// Firebase初期化</span>
<span class="kd">const</span><span class="w"> </span><span class="nx">app</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">initializeApp</span><span class="p">(</span><span class="nx">firebaseConfig</span><span class="p">)</span>

<span class="c1">// 認証インスタンス</span>
<span class="k">export</span><span class="w"> </span><span class="kd">const</span><span class="w"> </span><span class="nx">auth</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">getAuth</span><span class="p">(</span><span class="nx">app</span><span class="p">)</span>

<span class="c1">// Googleログインプロバイダ</span>
<span class="k">export</span><span class="w"> </span><span class="kd">const</span><span class="w"> </span><span class="nx">googleProvider</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nx">GoogleAuthProvider</span><span class="p">()</span>
</code></pre></div>

<h3 id="環境変数について">環境変数について<a class="header-link" href="#環境変数について" title="Permanent link">&para;</a></h3>
<div class="info-box">
<h3>🔐 環境変数と Vite</h3>
<p><strong>【.envファイル】</strong></p>
<pre>
frontend/.env
┌─────────────────────────────────────────────────────────────────────┐
│ VITE_FIREBASE_API_KEY=AIza...                                        │
│ VITE_FIREBASE_AUTH_DOMAIN=your-project.firebaseapp.com              │
│ VITE_FIREBASE_PROJECT_ID=your-project-id                            │
│ VITE_API_BASE_URL=https://your-api.run.app                          │
└─────────────────────────────────────────────────────────────────────┘
</pre>
<p><strong>【Viteでの環境変数のルール】</strong></p>
<ul>
<li>✅ VITE_ で始まる変数だけがフロントエンドで使える</li>
<li>✅ import.meta.env.VITE_XXX でアクセス</li>
<li>❌ VITE_ がない変数はフロントエンドからアクセスできない（セキュリティ）</li>
</ul>
<p><strong>【なぜ環境変数を使う？】</strong></p>
<ol>
<li>秘密情報をコードに直書きしない</li>
<li>開発/本番で設定を切り替えやすい</li>
<li>.gitignore で .env を除外 → Gitに秘密情報が入らない</li>
</ol>
<p>⚠️ 注意: フロントエンドの環境変数は結局ブラウザに送られる<br>
→ 本当の秘密（APIキーなど）はバックエンドに置く</p>
</div>

<hr />
<h2 id="11-全体の処理フロー">11. 全体の処理フロー<a class="header-link" href="#11-全体の処理フロー" title="Permanent link">&para;</a></h2>
<p>すべてのコードがどう連携するか、全体像を把握しましょう。</p>
<div class="flow-box">
<h3>🔄 チャット送信の完全フロー</h3>
<pre>
[ユーザー] メッセージ入力
    │
    ▼
[ChatScreen] onSendMessage(text) 呼び出し
    │
    ▼
[useChat] sendMessage(content)
    │
    ├── setMessages([...messages, userMessage])  ← ユーザーメッセージ追加
    │
    ├── setMessages([..., assistantMessage])  ← 空のAIメッセージ追加
    │
    ▼
[api.ts] sendChatMessage(content, threadId, onChunk)
    │
    ├── getAuthToken()  ← IDトークン取得
    │
    ├── fetch('/chat', { headers: { Authorization: 'Bearer ...' } })
    │
    ▼
[バックエンド] ─────────────────────────────────────────────────
    │  ・トークン検証
    │  ・AI に問い合わせ
    │  ・ストリーミングで返答
────┴───────────────────────────────────────────────────────────
    │
    ▼
[api.ts] reader.read() でチャンクを受信
    │
    ├── onChunk("こ") → setMessages 更新
    ├── onChunk("ん") → setMessages 更新
    ├── onChunk("に") → setMessages 更新
    ├── ...
    ├── onChunk("[DONE]") → 終了
    │
    ▼
[useChat] → [useSessions] updateSessionMessages()
    │
    ▼
[useSessions] → localStorage に保存
</pre>
</div>

<hr />
<h2 id="-やりたいこと--編集ファイル-対応表">📋 やりたいこと → 編集ファイル 対応表<a class="header-link" href="#-やりたいこと--編集ファイル-対応表" title="Permanent link">&para;</a></h2>
<div class="info-box">
<div class="box-title">🛠️ カスタマイズガイド</div>
<div class="box-content">

| やりたいこと | 編集するファイル | 該当箇所 |
|-------------|-----------------|---------|
| **色を変える** | `frontend/src/styles.css` | `:root` の CSS 変数（`--color-primary` など） |
| **ボタンのテキストを変える** | `frontend/src/components/ChatScreen.tsx` | `<button>` タグの中身 |
| **ローディング表示を変える** | `frontend/src/components/ChatScreen.tsx` | `isLoading` 時の表示部分 |
| **ログイン画面のデザインを変える** | `frontend/src/components/LoginScreen.tsx` | 全体 |
| **APIのURLを変える** | `frontend/.env` | `VITE_API_BASE_URL` |
| **新しいAPIエンドポイントを追加** | `frontend/src/services/api.ts` | 新しい関数を追加 |
| **認証方法を変える** | `frontend/src/services/firebase.ts` | プロバイダ設定 |
| **セッション数の上限を変える** | `frontend/src/hooks/useSessions.ts` | `MAX_SESSIONS` 定数 |
| **AIの応答を変える** | `backend/agents/_template/agent.py` | `SYSTEM_PROMPT`（フロントではない） |

</div>
</div>

<blockquote>
<p><strong>💡 ポイント</strong>: UIの見た目を変えるだけなら <code>styles.css</code> と <code>ChatScreen.tsx</code> だけで十分です。<br />
AIの応答内容を変えるには、バックエンドの <code>agent.py</code> を編集してください。</p>
</blockquote>
<hr />
<h2 id="まとめ">まとめ<a class="header-link" href="#まとめ" title="Permanent link">&para;</a></h2>
<div class="summary-box">
<h3>🎓 この章で学んだこと</h3>
<table>
<tr><th>概念</th><th>ポイント</th></tr>
<tr><td>コンポーネント</td><td>画面のパーツ。組み合わせてUIを作る</td></tr>
<tr><td>useState</td><td>状態を持つ。変更すると再描画される</td></tr>
<tr><td>useEffect</td><td>副作用を実行。マウント時やデータ変更時に処理</td></tr>
<tr><td>カスタムフック</td><td>ロジックを再利用。useAuth, useChatなど</td></tr>
<tr><td>TypeScript</td><td>型で安全に。間違いを事前に防ぐ</td></tr>
<tr><td>fetch API</td><td>バックエンドと通信</td></tr>
</table>
<ul>
<li>✅ useAuth: Firebase認証の状態管理</li>
<li>✅ useChat: メッセージ送受信</li>
<li>✅ useSessions: 複数会話のローカル保存</li>
<li>✅ api.ts: バックエンドとのHTTP通信</li>
</ul>
</div>

<hr />
<h2 id="次に読むべきドキュメント">次に読むべきドキュメント<a class="header-link" href="#次に読むべきドキュメント" title="Permanent link">&para;</a></h2>
<table>
<thead>
<tr>
<th>順番</th>
<th>ドキュメント</th>
<th>内容</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td><a href="./05_セットアップの流れ.md">05_セットアップの流れ.md</a></td>
<td>環境構築の手順</td>
</tr>
<tr>
<td>2</td>
<td><a href="./11_チャット送信の流れ.md">11_チャット送信の流れ.md</a></td>
<td>詳細なデータフロー</td>
</tr>
<tr>
<td>3</td>
<td><a href="./12_ログインの流れ.md">12_ログインの流れ.md</a></td>
<td>認証フローの詳細</td>
</tr>
</tbody>
</table>
      </article>
      <footer class="footer">
        GCP AI Agent 設計資料 | Built with Python & Markdown
      </footer>
    </main>
  </div>

  <script>
    function toggleSidebar() {
      document.getElementById('sidebar').classList.toggle('open');
    }

    // Close sidebar when clicking outside on mobile
    document.addEventListener('click', function(e) {
      const sidebar = document.getElementById('sidebar');
      const toggle = document.querySelector('.menu-toggle');
      if (!sidebar.contains(e.target) && !toggle.contains(e.target)) {
        sidebar.classList.remove('open');
      }
    });
  </script>
</body>
</html>