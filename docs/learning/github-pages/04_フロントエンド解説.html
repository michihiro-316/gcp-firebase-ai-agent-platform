<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>04 フロントエンド解説 - GCP AI Agent 設計資料</title>
  <link rel="stylesheet" href="assets/style.css">
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>📚</text></svg>">
</head>
<body>
  <header class="header">
    <a href="index.html" class="header-logo">
      <span>📚</span>
      <span>GCP AI Agent 設計資料</span>
    </a>
    <nav class="header-nav">
      <a href="index.html">ホーム</a>
      <a href="02_全体像.html">全体像</a>
      <a href="https://github.com" target="_blank">GitHub</a>
    </nav>
    <button class="menu-toggle" onclick="toggleSidebar()">
      <span></span>
      <span></span>
      <span></span>
    </button>
  </header>

  <div class="layout">
    <aside class="sidebar" id="sidebar">
      <div class="sidebar-section">
        <div class="sidebar-title">📖 はじめに</div>
        <ul class="sidebar-nav">
          <li><a href="01_はじめに読んでください.html" >はじめに読んでください</a></li>
        </ul>
      </div>

      <div class="sidebar-section">
        <div class="sidebar-title">🏗️ 仕組みを理解</div>
        <ul class="sidebar-nav">
          <li><a href="02_全体像.html" >全体像</a></li>
          <li><a href="03_バックエンド解説.html" >バックエンド解説</a></li>
          <li><a href="04_フロントエンド解説.html" class="active">フロントエンド解説</a></li>
        </ul>
      </div>

      <div class="sidebar-section">
        <div class="sidebar-title">🛠️ セットアップ</div>
        <ul class="sidebar-nav">
          <li><a href="05_セットアップの流れ.html" >セットアップの流れ</a></li>
          <li><a href="06_コマンド解説.html" >コマンド解説</a></li>
        </ul>
      </div>

      <div class="sidebar-section">
        <div class="sidebar-title">🚀 動かす</div>
        <ul class="sidebar-nav">
          <li><a href="07_動かしてみよう.html" >動かしてみよう</a></li>
          <li><a href="08_AIカスタマイズ.html" >AIカスタマイズ</a></li>
        </ul>
      </div>

      <div class="sidebar-section">
        <div class="sidebar-title">🔧 上級編</div>
        <ul class="sidebar-nav">
          <li><a href="10_Gatewayアーキテクチャ.html" >Gatewayアーキテクチャ</a></li>
        </ul>
      </div>

      <div class="sidebar-section">
        <div class="sidebar-title">🔄 参考: フロー解説</div>
        <ul class="sidebar-nav">
          <li><a href="11_チャット送信の流れ.html" >チャット送信の流れ</a></li>
          <li><a href="12_ログインの流れ.html" >ログインの流れ</a></li>
          <li><a href="13_セッション管理の流れ.html" >セッション管理の流れ</a></li>
        </ul>
      </div>
    </aside>

    <main class="main">
      <article class="content">
        <h1 id="フロントエンド解説">フロントエンド解説<a class="header-link" href="#フロントエンド解説" title="Permanent link">&para;</a></h1>
<div class="chapter-hero">
<span class="emoji">🎨</span>
<h1>フロントエンド解説</h1>
<p class="subtitle">「え？Reactってレゴブロックみたいなもの？」<br>「そう！画面のパーツを組み合わせて作るんだ！」</p>
</div>

<hr />
<h2 id="この章で学ぶこと">この章で学ぶこと<a class="header-link" href="#この章で学ぶこと" title="Permanent link">&para;</a></h2>
<div class="goal-box">
<h3>📚 学習目標</h3>
<ol>
<li>Reactの基本概念（コンポーネント、JSX）</li>
<li>useState と useEffect の仕組み</li>
<li>カスタムフックの作り方と使い方</li>
<li>認証処理の流れ（useAuth.ts）</li>
<li>チャット処理の流れ（useChat.ts）</li>
<li>セッション管理の仕組み（useSessions.ts）</li>
<li>API通信とストリーミング（api.ts）</li>
<li>TypeScriptの型システム</li>
</ol>
<p><strong>⏱️ 想定学習時間: 45分</strong></p>
</div>

<hr />
<h2 id="使っている技術">使っている技術<a class="header-link" href="#使っている技術" title="Permanent link">&para;</a></h2>
<table>
<thead>
<tr>
<th>技術</th>
<th>役割</th>
<th>なぜ使う？</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>React</strong></td>
<td>UIを作るライブラリ</td>
<td>コンポーネントで画面を組み立てられる</td>
</tr>
<tr>
<td><strong>TypeScript</strong></td>
<td>型のあるJavaScript</td>
<td>間違いを事前に防げる</td>
</tr>
<tr>
<td><strong>Vite</strong></td>
<td>開発サーバー・ビルドツール</td>
<td>超高速！変更が即座に反映</td>
</tr>
<tr>
<td><strong>Firebase SDK</strong></td>
<td>Firebase連携</td>
<td>認証やデータベースを簡単に使える</td>
</tr>
</tbody>
</table>
<hr />
<h2 id="-pythonエンジニア向け-アロー関数の基礎">🐍 Pythonエンジニア向け: アロー関数の基礎<a class="header-link" href="#-pythonエンジニア向け-アロー関数の基礎" title="Permanent link">&para;</a></h2>
<p>Reactのコードには <code>() =&gt; { }</code> という書き方が頻繁に出てきます。<br />
<strong>最初に理解しておくと、この先がラクになります！</strong></p>
<div class="info-box">
<h3>📝 アロー関数 = Pythonの lambda（無名関数）の進化版</h3>

**基本構文:**

<pre>
() => { ... }
↑    ↑   ↑
①   ②   ③

① () = 引数（なければ空のカッコ）
② => = 「これが関数ですよ」の印（アロー）
③ { } = 関数の中身
</pre>

**Pythonとの比較:**


<pre class="codehilite"><code class="language-python"># Python の関数定義
def say_hello():
    print(&quot;Hello&quot;)

# Python の lambda（1行のみ）
say_hello = lambda: print(&quot;Hello&quot;)
</code></pre>




<pre class="codehilite"><code class="language-javascript">// JavaScript の関数定義（従来）
function sayHello() {
  console.log(&quot;Hello&quot;);
}

// JavaScript のアロー関数（現代的）
const sayHello = () =&gt; {
  console.log(&quot;Hello&quot;);
};
</code></pre>



**引数がある場合:**


<pre class="codehilite"><code class="language-python"># Python
def add(a, b):
    return a + b

add_lambda = lambda a, b: a + b
</code></pre>




<pre class="codehilite"><code class="language-javascript">// JavaScript（アロー関数）
const add = (a, b) =&gt; {
  return a + b;
};

// 1行なら省略可能
const add = (a, b) =&gt; a + b;
</code></pre>



</div>

<div class="tip-box">
<h3>💡 よく見るパターン</h3>

**パターン1: イベントハンドラ**

<pre class="codehilite"><code class="language-tsx">&lt;button onClick={() =&gt; { console.log(&quot;クリック！&quot;); }}&gt;
  ボタン
&lt;/button&gt;
</code></pre>



**パターン2: 配列の処理**

<pre class="codehilite"><code class="language-javascript">// Python: [x * 2 for x in numbers]
// JavaScript:
numbers.map((x) =&gt; x * 2)
</code></pre>



**パターン3: 関数を返す関数**

<pre class="codehilite"><code class="language-javascript">// アロー関数を return で返す
return () =&gt; {
  // この中身は「今」実行されない
  // 後で誰かが呼び出すと実行される
};
</code></pre>



**パターン4: 別の関数の引数として渡す（コールバック）**

<pre class="codehilite"><code class="language-javascript">// 関数を引数として渡すパターン
onAuthStateChanged(auth, (user) =&gt; {
  setUser(user);
});
</code></pre>


→ **詳しくは「[6. useAuth.ts - 認証フックの完全解説](#6-useauthts---認証フックの完全解説)」で図解付きで説明しています！**

</div>

<div class="warning-box">
<h3>⚠️ 超重要: `inner` と `inner()` の違い</h3>

**これ、初心者がつまずく最大のポイントです！**


<pre class="codehilite"><code class="language-python">def outer():
    def inner():
        print(&quot;後で実行&quot;)

    return inner    # ← カッコなし = 関数そのものを返す
    # return inner()  ← カッコあり = 関数を実行して、その結果を返す
</code></pre>



**図で理解:**

<pre>
inner   ← 関数そのもの（まだ実行されていない）
         「後で実行してね」という約束を渡す

inner() ← 関数を実行した結果
         今すぐ「後で実行」と表示される
         返り値は None（print は何も返さないから）
</pre>

**具体例で比較:**


<pre class="codehilite"><code class="language-python">def outer():
    def inner():
        print(&quot;実行された！&quot;)
        return 42

    return inner   # カッコなし

# 使う側
result = outer()   # result には inner関数が入る
print(result)      # → &lt;function inner at 0x...&gt;（関数オブジェクト）
print(result())    # → 実行された！ → 42（ここで初めて実行）
</code></pre>




<pre class="codehilite"><code class="language-python">def outer():
    def inner():
        print(&quot;実行された！&quot;)
        return 42

    return inner()  # カッコあり ← ここで実行されてしまう！

# 使う側
result = outer()   # → 「実行された！」が表示される
print(result)      # → 42（inner() の戻り値）
</code></pre>



**JavaScript でも同じ:**


<pre class="codehilite"><code class="language-javascript">// カッコなし = 関数を返す（useEffectではこれが正解）
return () =&gt; { clearInterval(timer); }

// カッコあり = 今すぐ実行して、その結果（undefined）を返す
return (() =&gt; { clearInterval(timer); })()
//                                      ↑↑
//                         この () で即実行してしまう！
</code></pre>



<table>
<tr><th>書き方</th><th>何が起きる？</th><th>useEffectでは？</th></tr>
<tr><td><code>return inner</code></td><td>関数を返す</td><td>✅ 正解！Reactが後で呼ぶ</td></tr>
<tr><td><code>return inner()</code></td><td>今すぐ実行し、結果を返す</td><td>❌ 即実行される</td></tr>
</table>

</div>

<hr />
<h2 id="ファイルの拡張子を理解しよう">ファイルの拡張子を理解しよう<a class="header-link" href="#ファイルの拡張子を理解しよう" title="Permanent link">&para;</a></h2>
<div class="info-box">
<h3>📝 拡張子の意味</h3>
<table>
<tr><th>拡張子</th><th>意味</th><th>用途</th></tr>
<tr><td><strong>.js</strong></td><td>JavaScript</td><td>普通のJavaScriptファイル</td></tr>
<tr><td><strong>.ts</strong></td><td>TypeScript</td><td>型付きJavaScript（HTMLを含まない）</td></tr>
<tr><td><strong>.jsx</strong></td><td>JavaScript + JSX</td><td>React用（HTMLっぽい記法を含む）</td></tr>
<tr><td><strong>.tsx</strong></td><td>TypeScript + JSX</td><td>React用＋型付き（<strong>このプロジェクトの主役</strong>）</td></tr>
</table>
<p><strong>【.tsx のポイント】</strong></p>
<pre>
// .ts ファイル（HTMLなし）
function add(a: number, b: number): number {
  return a + b;
}

// .tsx ファイル（HTMLあり = JSX）
function Button(): JSX.Element {
  return &lt;button&gt;クリック&lt;/button&gt;;  // ← これがJSX
}
</pre>
<p>💡 <strong>使い分け:</strong></p>
<ul>
<li>UIを含む（画面パーツ）→ <code>.tsx</code></li>
<li>UIを含まない（ロジックのみ）→ <code>.ts</code></li>
</ul>
</div>

<hr />
<h2 id="プロジェクト構成の全体像">プロジェクト構成の全体像<a class="header-link" href="#プロジェクト構成の全体像" title="Permanent link">&para;</a></h2>
<div class="architecture-box">
<h3>🏗️ Reactプロジェクトの構成</h3>
<pre>
src/frontend/
├── index.html           ← ★ HTMLの土台（1回だけ読み込まれる）
├── src/
│   ├── main.tsx         ← ★ Reactの起動スクリプト
│   ├── App.tsx          ← ★ メインコンポーネント
│   └── components/      ← 各種UIパーツ
├── .env                 ← 環境変数（APIキーなど）
└── vite.config.ts       ← Viteの設定
</pre>
</div>

<div class="warning-box">
<h3>⚠️ 超重要：どのファイルに何を書く？</h3>
<div class="box-content">

<p><strong>【index.html】全ページ共通で1回だけ読み込むもの</strong></p>
<ul>
<li>Google Tag Manager (GTM)</li>
<li>Google Analytics</li>
<li>外部CSS/フォント（Google Fontsなど）</li>
<li><code>&lt;title&gt;</code> や <code>&lt;meta&gt;</code> タグ</li>
<li>favicon の設定</li>
</ul>

<pre><code class="language-html">&lt;!-- index.html の例 --&gt;
&lt;!DOCTYPE html&gt;
&lt;html lang="ja"&gt;
&lt;head&gt;
  &lt;!-- ↓ 全ページ共通で1回だけ読み込むもの --&gt;
  &lt;meta charset="UTF-8" /&gt;
  &lt;title&gt;AIチャット&lt;/title&gt;
  &lt;link rel="icon" href="/favicon.ico" /&gt;

  &lt;!-- GTM（Google Tag Manager）--&gt;
  &lt;script&gt;(function(w,d,s,l,i){...})(window,document,'script','dataLayer','GTM-XXXX');&lt;/script&gt;

  &lt;!-- Google Fonts --&gt;
  &lt;link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP&amp;display=swap" rel="stylesheet"&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;!-- ↓ Reactがここにコンポーネントを描画する --&gt;
  &lt;div id="root"&gt;&lt;/div&gt;

  &lt;!-- ↓ main.tsx を読み込んでReactを起動 --&gt;
  &lt;script type="module" src="/src/main.tsx"&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<div class="info-box">
<h3>🤔 なぜ .tsx ファイルを直接読み込める？</h3>
<p>本来ブラウザは <code>.tsx</code>（TypeScript + React）を読めません。<br>
これを可能にしているのが <strong>Vite（ビルドツール）</strong> です。</p>
<pre>
あなたのコード           Vite            ブラウザ
  (TypeScript)    →    (翻訳)    →    (JavaScript)
  (React JSX)     →    (翻訳)    →    (HTML + JS)
</pre>
<p><code>npm run dev</code> で Vite が起動し、翻訳しながら localhost:5173 で配信してくれます。</p>
<p>👉 詳しくは <a href="./05_セットアップの流れ.html#npm-install-npm-run-dev-とは">セットアップの流れ「npm install / npm run dev とは」</a> を参照</p>
</div>

<p><strong>【main.tsx】Reactを起動するだけ</strong></p>
<ul>
<li><code>index.html</code> の <code>#root</code> にReactアプリを埋め込む</li>
<li>基本的に変更不要</li>
</ul>

<pre><code class="language-tsx">// main.tsx
import React from 'react'
import ReactDOM from 'react-dom/client'
import App from './App'

ReactDOM.createRoot(document.getElementById('root')!).render(
  &lt;React.StrictMode&gt;
    &lt;App /&gt;  {/* ← ここからReactの世界が始まる */}
  &lt;/React.StrictMode&gt;
)
</code></pre>

<p><strong>【App.tsx 以下】画面の中身</strong></p>
<ul>
<li>ログイン状態による表示切り替え</li>
<li>チャット画面</li>
<li>ヘッダー、フッターなどのUI</li>
<li>動的に変わる部分はすべてここ</li>
</ul>

</div>
</div>

<div class="flow-box">
<h3>🔄 読み込まれる順番</h3>
<pre>
ブラウザ
  │
  ↓ ① index.html を読む
  │
  ├─▶ &lt;head&gt; の中身を処理
  │     ・GTM スクリプト実行
  │     ・CSS/フォント読み込み
  │
  ├─▶ &lt;body&gt; の中身を処理
  │     ・#root という空の div を作成
  │
  ↓ ② main.tsx を読む
  │
  ├─▶ React を起動
  │     ・#root に App コンポーネントを描画
  │
  ↓ ③ App.tsx が描画される
  │
  └─▶ ユーザーの操作に応じて画面が更新
        ・ログイン → ChatScreen
        ・メッセージ送信 → 画面更新
</pre>
<p><strong>ポイント:</strong> index.html は「器」、React は「中身」を担当</p>
</div>

<hr />
<h2 id="ファイル構成詳細">ファイル構成（詳細）<a class="header-link" href="#ファイル構成詳細" title="Permanent link">&para;</a></h2>
<pre class="codehilite"><code>src/frontend/src/
├── App.tsx              ← 🎯 メインコンポーネント（ここから始まる）
├── main.tsx             ← エントリーポイント（Reactの起動）
├── hooks/               ← 🎣 カスタムフック（ロジックを再利用）
│   ├── useAuth.ts       ← ログイン処理（UIなし → .ts）
│   ├── useChat.ts       ← チャット処理（UIなし → .ts）
│   └── useSessions.ts   ← セッション管理（UIなし → .ts）
├── services/            ← 外部サービス連携
│   ├── firebase.ts      ← Firebase初期化（UIなし → .ts）
│   └── api.ts           ← APIクライアント（UIなし → .ts）
├── components/          ← UIパーツ
│   ├── ChatScreen.tsx   ← チャット画面（UIあり → .tsx）
│   └── LoginScreen.tsx  ← ログイン画面（UIあり → .tsx）
└── renderers/           ← 【上級者向け】チャット表示カスタマイズ
</code></pre>

<div class="tip-box">
<h3>💡 学習のポイント</h3>
<p>まず理解すべきファイル（優先順位順）:</p>
<ol>
<li><strong>App.tsx</strong> ← 全体の流れを把握</li>
<li><strong>useAuth.ts</strong> ← 認証の仕組み</li>
<li><strong>useChat.ts</strong> ← チャットの仕組み</li>
<li><strong>useSessions.ts</strong> ← セッション管理</li>
<li><strong>api.ts</strong> ← API通信の仕組み</li>
</ol>
<p>renderers/ は上級者向け。最初はスキップしてOK！</p>
</div>

<hr />
<h2 id="1-reactの基本概念">1. Reactの基本概念<a class="header-link" href="#1-reactの基本概念" title="Permanent link">&para;</a></h2>
<h3 id="コンポーネントとは">コンポーネントとは？<a class="header-link" href="#コンポーネントとは" title="Permanent link">&para;</a></h3>
<div class="architecture-box">
<h3>🧱 コンポーネント = 画面のパーツ（レゴブロック）</h3>
<div style="border: 3px solid #fbbf24; border-radius: 8px; padding: 16px; background: #1e293b;">
  <div style="color: #fbbf24; font-weight: bold; margin-bottom: 12px;">App（親コンポーネント）</div>
  <div style="display: flex; gap: 16px; align-items: flex-start;">
    <!-- LoginScreen -->
    <div style="border: 2px solid #94a3b8; border-radius: 6px; padding: 12px; flex: 1; background: #334155;">
      <div style="color: #94a3b8; font-weight: bold; margin-bottom: 8px;">LoginScreen</div>
      <div style="border: 2px solid #64748b; border-radius: 4px; padding: 8px; display: inline-block; background: #475569;">
        <code style="color: #fbbf24; font-weight: bold;">LoginButton</code>
      </div>
    </div>
    <!-- または -->
    <div style="color: #94a3b8; font-weight: bold; align-self: center;">または</div>
    <!-- ChatScreen -->
    <div style="border: 2px solid #94a3b8; border-radius: 6px; padding: 12px; flex: 1; background: #334155;">
      <div style="color: #94a3b8; font-weight: bold; margin-bottom: 8px;">ChatScreen</div>
      <div style="border: 2px solid #64748b; border-radius: 4px; padding: 8px; background: #475569;">
        <div style="margin-bottom: 4px;"><code style="color: #fbbf24; font-weight: bold;">SessionList</code></div>
        <div style="margin-bottom: 4px;"><code style="color: #fbbf24; font-weight: bold;">MessageList</code></div>
        <div><code style="color: #fbbf24; font-weight: bold;">InputField</code></div>
      </div>
    </div>
  </div>
</div>
<p>コンポーネントを組み合わせて画面全体を作る！</p>
</div>

<h3 id="jsxjavascript--html">JSX（JavaScript + HTML）<a class="header-link" href="#jsxjavascript--html" title="Permanent link">&para;</a></h3>
<p>ReactではJSXという記法を使います。<br />
JavaScript の中に HTML っぽく書ける！</p>
<pre class="codehilite"><code class="language-tsx">// ボタンコンポーネントの例
function MyButton() {
  // JavaScript の中に HTML っぽく書ける！
  return &lt;button&gt;クリック&lt;/button&gt;;
}

// 使う側
function App() {
  return (
    &lt;div&gt;
      &lt;h1&gt;こんにちは&lt;/h1&gt;
      &lt;MyButton /&gt;  {/* ← 自作コンポーネントを使う */}
    &lt;/div&gt;
  );
}
</code></pre>

<div class="info-box">
<h3>📝 JSXの特徴</h3>
<ul>
<li>✅ HTML っぽく書ける（でも実は JavaScript）</li>
<li>✅ {} の中に JavaScript を書ける</li>
<li>✅ 自作コンポーネントは &lt;MyComponent /&gt; のように使う</li>
<li>✅ class は className と書く（JSの予約語だから）</li>
</ul>
<p><strong>例:</strong></p>
<pre>const name = "太郎";
return &lt;h1&gt;こんにちは、{name}さん！&lt;/h1&gt;;
// → "こんにちは、太郎さん！" と表示される</pre>
</div>

<hr />
<h2 id="2-usestate---状態管理の基本">2. useState - 状態管理の基本<a class="header-link" href="#2-usestate---状態管理の基本" title="Permanent link">&para;</a></h2>
<h3 id="usestate-とは">useState とは？<a class="header-link" href="#usestate-とは" title="Permanent link">&para;</a></h3>
<p>コンポーネント内で「状態（データ）」を持つための仕組み。<br />
状態が変わると、画面が自動で再描画される！</p>
<pre class="codehilite"><code class="language-tsx">import { useState } from 'react';

function Counter() {
  // ┌─────────────────────────────────────────────────────────────────┐
  // │ useState(初期値) の戻り値:                                       │
  // │   [0] 現在の値（count）                                          │
  // │   [1] 値を更新する関数（setCount）                                │
  // └─────────────────────────────────────────────────────────────────┘
  const [count, setCount] = useState(0);  // 初期値は 0

  return (
    &lt;div&gt;
      &lt;p&gt;カウント: {count}&lt;/p&gt;
      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;
        +1
      &lt;/button&gt;
    &lt;/div&gt;
  );
}
</code></pre>

<div class="flow-box">
<h3>🔄 useState の動作</h3>
<ol>
<li><strong>最初のレンダリング</strong><br>count = 0<br>画面: 「カウント: 0」</li>
<li><strong>ボタンをクリック</strong><br>setCount(0 + 1) が呼ばれる</li>
<li><strong>React が再レンダリング</strong><br>count = 1<br>画面: 「カウント: 1」 ← 自動で更新！</li>
</ol>
<p>⚠️ 直接 count = 1 と書いても画面は更新されない！<br>必ず setCount() を使う！</p>
</div>

<h3 id="配列の分割代入">配列の分割代入<a class="header-link" href="#配列の分割代入" title="Permanent link">&para;</a></h3>
<pre class="codehilite"><code class="language-tsx">// これ何？と思った人へ
const [count, setCount] = useState(0);

// ↑ は以下と同じ意味
const result = useState(0);      // [0, 関数] が返ってくる
const count = result[0];         // 現在の値
const setCount = result[1];      // 更新関数

// 「配列の分割代入」という JavaScript の機能
// 配列の要素を変数に展開できる
const [first, second] = [1, 2];  // first = 1, second = 2
</code></pre>

<h3 id="オブジェクトの分割代入カスタムフックで頻出">オブジェクトの分割代入（カスタムフックで頻出）<a class="header-link" href="#オブジェクトの分割代入カスタムフックで頻出" title="Permanent link">&para;</a></h3>
<p>配列だけでなく、<strong>オブジェクト（dict）</strong> からも値を取り出せます。<br />
カスタムフック（useAuth, useChat など）はこちらを使います。</p>
<pre class="codehilite"><code class="language-tsx">// useChat が返すオブジェクト
{
  messages: [...],
  isLoading: true,
  error: &quot;何かエラー&quot;,
  sendMessage: (関数)
}

// オブジェクトの分割代入で取り出す
const { messages, isLoading, error, sendMessage } = useChat(...)
</code></pre>

<div class="info-box">
<h3>📝 Python で書くと</h3>
<pre>
# Python の場合（dict から取り出す）
result = use_chat(...)
messages = result["messages"]
is_loading = result["isLoading"]
error = result["error"]
send_message = result["sendMessage"]

# JavaScript の分割代入は、上の4行を1行で書ける！
</pre>
</div>

<h3 id="別名で取り出すリネーム">別名で取り出す（リネーム）<a class="header-link" href="#別名で取り出すリネーム" title="Permanent link">&para;</a></h3>
<p><strong>同じ名前のキーが衝突するとき</strong>、別名を付けて取り出せます。</p>
<pre class="codehilite"><code class="language-tsx">// 問題: useAuth も useChat も error を返す → 名前が被る！
const { error } = useAuth()   // 認証エラー
const { error } = useChat()   // チャットエラー ← エラー！

// 解決: 別名を付ける
const { error: authError } = useAuth()   // authError という変数に
const { error: chatError } = useChat()   // chatError という変数に
</code></pre>

<div class="tip-box">
<h3>💡 SQL の AS と同じ！</h3>
<pre>
-- SQL
SELECT error AS chatError FROM ...
--     ↑元     ↑別名

// JavaScript（順番が逆だけど同じ意味）
const { error: chatError } = useChat(...)
//      ↑元    ↑別名
</pre>
<table>
<tr><th>言語</th><th>記法</th><th>意味</th></tr>
<tr><td>SQL</td><td><code>error AS chatError</code></td><td>error を chatError という名前で取り出す</td></tr>
<tr><td>JavaScript</td><td><code>{ error: chatError }</code></td><td>error を chatError という名前で取り出す</td></tr>
<tr><td>Python</td><td><code>chat_error = result["error"]</code></td><td>dict の "error" キーの値を chat_error に代入</td></tr>
</table>
</div>

<h3 id="配列-vs-オブジェクトの分割代入">配列 vs オブジェクトの分割代入<a class="header-link" href="#配列-vs-オブジェクトの分割代入" title="Permanent link">&para;</a></h3>
<div class="info-box">
<h3>🔑 どっちを使う？</h3>
<table>
<tr><th>種類</th><th>取り出し方</th><th>使う場面</th></tr>
<tr><td><strong>配列</strong></td><td>順番で決まる</td><td>useState（[値, 更新関数]）</td></tr>
<tr><td><strong>オブジェクト</strong></td><td>名前で決まる</td><td>カスタムフック（useAuth, useChat など）</td></tr>
</table>
<pre>
// 配列: 順番で取り出す（名前は自由に付けられる）
const [count, setCount] = useState(0)
//     [0]    [1]

// オブジェクト: キー名で取り出す（順番は関係ない）
const { messages, isLoading } = useChat(...)
const { isLoading, messages } = useChat(...)  // 順番入れ替えてもOK
</pre>
</div>

<h3 id="setcountはどこで定義した超よくある質問">「setCount」はどこで定義した？（超よくある質問）<a class="header-link" href="#setcountはどこで定義した超よくある質問" title="Permanent link">&para;</a></h3>
<div class="warning-box">
<h3>❓ 「setCount って自分で作ってないのに、なぜ使える？」</h3>
<div class="box-content">

**答え: `useState` が内部で作って返してくれる**


<pre class="codehilite"><code class="language-tsx">const [count, setCount] = useState(0);
//            ↑ これは useState が作った関数
</code></pre>



自分で `function setCount() {...}` と書いたわけではない！
`useState` を呼ぶと、React が以下を返してくれる：

1. **現在の値**（`count`）
2. **その値を更新する関数**（`setCount`）

<pre>
useState(0) が返すもの:
┌─────────────────────────────────────────┐
│  [0] → 現在の値（最初は初期値の 0）       │
│  [1] → 更新関数（React が用意してくれる） │
└─────────────────────────────────────────┘
</pre>

**ポイント**: `setCount` を呼ぶと、Reactは：
1. 新しい値を内部に保存
2. コンポーネントを再レンダリング（画面更新）

</div>
</div>

<h3 id="初期値と現在値の違い混乱しやすい">初期値と現在値の違い（混乱しやすい）<a class="header-link" href="#初期値と現在値の違い混乱しやすい" title="Permanent link">&para;</a></h3>
<pre class="codehilite"><code class="language-tsx">const [count, setCount] = useState(0);
//                                 ↑ 初期値（最初の1回だけ使う）
//           ↑ 現在の値（常に変化しうる）
</code></pre>

<div class="info-box">
<h3>📝 初期値 vs 現在値</h3>
<table>
<tr><th>用語</th><th>意味</th><th>例</th></tr>
<tr><td><strong>初期値</strong></td><td>useState の引数。最初のレンダリング時だけ使う</td><td><code>useState(0)</code> の <code>0</code></td></tr>
<tr><td><strong>現在値</strong></td><td>今のstate。更新のたびに変わる</td><td><code>count</code>（0→1→2→...）</td></tr>
</table>
<p>💡 2回目以降のレンダリングでは、初期値 <code>0</code> は無視される</p>
</div>

<h3 id="セッター関数の使い方---値を直接渡すだけでok">セッター関数の使い方 - 値を直接渡すだけでOK！<a class="header-link" href="#セッター関数の使い方---値を直接渡すだけでok" title="Permanent link">&para;</a></h3>
<div class="tip-box">
<h3>💡 セッター関数には「値を直接渡す」のが基本！</h3>
<div class="box-content">


<pre class="codehilite"><code class="language-tsx">const [user, setUser] = useState(null);
const [loading, setLoading] = useState(true);

// ✅ 値を直接渡す（これが基本！）
setUser(newUser);      // newUser をそのままセット
setLoading(false);     // false をそのままセット
setUser(null);         // null をセット
</code></pre>



**Python との比較:**

<pre class="codehilite"><code class="language-python"># Python（普通の変数）
user = new_user       # 代入で更新

# React（useState）
setUser(new_user)     # セッター関数で更新
</code></pre>



**なぜ普通の代入 `user = xxx` じゃダメ？**

普通の代入だと React が変更に気づけない。`setUser()` を使うことで「値が変わった！」と React に通知され、画面が再描画される。

</div>
</div>

<div class="info-box">
<h3>📝 セッター関数の2つの書き方</h3>
<table>
<tr><th>書き方</th><th>例</th><th>いつ使う？</th></tr>
<tr><td><strong>値を直接渡す</strong></td><td><code>setUser(user)</code></td><td>新しい値がわかっているとき（基本はこれ！）</td></tr>
<tr><td><strong>関数を渡す</strong></td><td><code>setCount(prev => prev + 1)</code></td><td>前の値を使って計算するとき</td></tr>
</table>
</div>

<h3 id="関数型更新prev--連続更新で必須">関数型更新（prev）- 連続更新で必須！<a class="header-link" href="#関数型更新prev--連続更新で必須" title="Permanent link">&para;</a></h3>
<div class="warning-box">
<h3>⚠️ 連続で setState すると、期待通りに動かない？</h3>
<div class="box-content">

**問題のあるコード:**

<pre class="codehilite"><code class="language-tsx">const [count, setCount] = useState(0);

function handleClick() {
  setCount(count + 1);  // count=0 なので 0+1=1
  setCount(count + 1);  // count=0 なので 0+1=1
  setCount(count + 1);  // count=0 なので 0+1=1
  // 結果: count は 1 になる（3じゃない！）
}
</code></pre>



**なぜ？** `setCount` は非同期で、`count` はまだ古い値のまま

**解決: 関数型更新（prev）を使う**

<pre class="codehilite"><code class="language-tsx">function handleClick() {
  setCount(prev =&gt; prev + 1);  // prev=0 → 1
  setCount(prev =&gt; prev + 1);  // prev=1 → 2
  setCount(prev =&gt; prev + 1);  // prev=2 → 3
  // 結果: count は 3 になる！✅
}
</code></pre>



</div>
</div>

<div class="info-box">
<h3>🔑 prev の正体</h3>
<p><strong>prev は「過去の値」ではなく「更新直前の最新値」</strong></p>
<pre>
setCount(prev => prev + 1)
         ↑
         これは「更新が適用される直前の state」

時系列:
  1回目: prev=0 → 0+1=1 を返す → state=1
  2回目: prev=1 → 1+1=2 を返す → state=2
  3回目: prev=2 → 2+1=3 を返す → state=3
</pre>
<p><strong>いつ関数型を使う？</strong></p>
<ul>
<li>✅ 連続で更新するとき</li>
<li>✅ 現在の値を元に計算するとき</li>
<li>✅ 非同期処理の中で更新するとき</li>
</ul>
</div>

<h3 id="配列-state-の更新超重要">配列 state の更新（超重要！）<a class="header-link" href="#配列-state-の更新超重要" title="Permanent link">&para;</a></h3>
<p>実際のアプリでは、配列（リスト）を state で管理することが多い。<br />
<strong>破壊的変更（push等）はNG！必ずコピーして新しい配列を作る</strong></p>
<div class="architecture-box">
<h3>📦 配列 state の更新テンプレート</h3>

**セットアップ:**

<pre class="codehilite"><code class="language-tsx">const [items, setItems] = useState([
  { id: 1, name: &quot;りんご&quot; },
  { id: 2, name: &quot;バナナ&quot; },
]);
</code></pre>



**① 追加（末尾に追加）**

<pre class="codehilite"><code class="language-tsx">const newItem = { id: 3, name: &quot;みかん&quot; };
setItems(prev =&gt; [...prev, newItem]);
// 結果: [りんご, バナナ, みかん]
</code></pre>



**② 削除（特定のIDを削除）**

<pre class="codehilite"><code class="language-tsx">setItems(prev =&gt; prev.filter(item =&gt; item.id !== 2));
// 結果: [りんご, みかん]  ← id:2 のバナナが消えた
</code></pre>



**③ 更新（特定のアイテムを変更）**

<pre class="codehilite"><code class="language-tsx">setItems(prev =&gt; prev.map(item =&gt;
  item.id === 1
    ? { ...item, name: &quot;青りんご&quot; }  // id:1 だけ変更
    : item                           // それ以外はそのまま
));
// 結果: [青りんご, バナナ, みかん]
</code></pre>



</div>

<div class="warning-box">
<h3>❌ やってはいけない（破壊的変更）</h3>
<div class="box-content">


<pre class="codehilite"><code class="language-tsx">// ❌ NG: push は元の配列を変更する
items.push(newItem);
setItems(items);  // Reactは「同じ配列」と判断して再描画しない

// ❌ NG: 直接代入
items[0].name = &quot;青りんご&quot;;
setItems(items);  // 同じく再描画されない
</code></pre>



**なぜNG？**
Reactは「配列の参照（アドレス）」が変わったかで再描画を判断する。
`push` や直接代入は参照が同じままなので、Reactは変化に気づかない。

**✅ 正解: スプレッド構文で新しい配列を作る**

<pre class="codehilite"><code class="language-tsx">setItems(prev =&gt; [...prev, newItem]);  // 新しい配列を作成
</code></pre>



</div>
</div>

<h3 id="オブジェクト-state-の更新">オブジェクト state の更新<a class="header-link" href="#オブジェクト-state-の更新" title="Permanent link">&para;</a></h3>
<p>オブジェクト（連想配列/dict）も配列と同じ原則：<strong>コピーして一部を変える</strong></p>
<div class="architecture-box">
<h3>🔧 オブジェクト state の更新テンプレート</h3>

**セットアップ:**

<pre class="codehilite"><code class="language-tsx">const [user, setUser] = useState({
  name: &quot;太郎&quot;,
  age: 25,
  email: &quot;taro@example.com&quot;
});
</code></pre>



**① 一部だけ更新**

<pre class="codehilite"><code class="language-tsx">setUser(prev =&gt; ({
  ...prev,           // 既存のプロパティをコピー
  name: &quot;花子&quot;       // name だけ上書き
}));
// 結果: { name: &quot;花子&quot;, age: 25, email: &quot;taro@example.com&quot; }
</code></pre>



**② ネストしたオブジェクトの更新**

<pre class="codehilite"><code class="language-tsx">const [user, setUser] = useState({
  name: &quot;太郎&quot;,
  profile: {
    age: 25,
    city: &quot;東京&quot;
  }
});

// profile.age だけ更新
setUser(prev =&gt; ({
  ...prev,
  profile: {
    ...prev.profile,  // profile の中身もコピー
    age: 26           // age だけ上書き
  }
}));
</code></pre>



</div>

<div class="warning-box">
<h3>❌ よくある間違い</h3>
<div class="box-content">


<pre class="codehilite"><code class="language-tsx">// ❌ NG: 他のプロパティが消える
setUser({ name: &quot;花子&quot; });
// 結果: { name: &quot;花子&quot; }  ← age, email が消えた！

// ✅ OK: スプレッドで既存をコピー
setUser(prev =&gt; ({ ...prev, name: &quot;花子&quot; }));
// 結果: { name: &quot;花子&quot;, age: 25, email: &quot;taro@example.com&quot; }
</code></pre>



</div>
</div>

<hr />
<h2 id="25-フォーム入力controlled-component">2.5 フォーム入力（controlled component）<a class="header-link" href="#25-フォーム入力controlled-component" title="Permanent link">&para;</a></h2>
<p>フォームの入力欄を state で管理する方法。<br />
設定画面や入力フォームで必須のパターン！</p>
<h3 id="基本-テキスト入力">基本: テキスト入力<a class="header-link" href="#基本-テキスト入力" title="Permanent link">&para;</a></h3>
<pre class="codehilite"><code class="language-tsx">function InputForm() {
  const [text, setText] = useState(&quot;&quot;);

  return (
    &lt;div&gt;
      &lt;input
        type=&quot;text&quot;
        value={text}                           // ① 表示は state が正
        onChange={(e) =&gt; setText(e.target.value)}  // ② 入力したら state 更新
      /&gt;
      &lt;p&gt;入力内容: {text}&lt;/p&gt;
    &lt;/div&gt;
  );
}
</code></pre>

<div class="flow-box">
<h3>🔄 controlled component の動き</h3>
<pre>
ユーザーが「あ」と入力
    ↓
onChange 発火 → setText("あ")
    ↓
state が "あ" に更新
    ↓
React が再レンダリング
    ↓
input の value="あ" で表示
</pre>
<p><strong>ポイント:</strong> state が「唯一の情報源（Single Source of Truth）」</p>
</div>

<h3 id="実践例-todoリストに追加">実践例: TODOリストに追加<a class="header-link" href="#実践例-todoリストに追加" title="Permanent link">&para;</a></h3>
<pre class="codehilite"><code class="language-tsx">function TodoApp() {
  const [text, setText] = useState(&quot;&quot;);
  const [todos, setTodos] = useState&lt;string[]&gt;([]);

  const handleAdd = () =&gt; {
    if (!text.trim()) return;  // 空文字は追加しない

    setTodos(prev =&gt; [...prev, text]);  // リストに追加
    setText(&quot;&quot;);                         // 入力欄をクリア
  };

  return (
    &lt;div&gt;
      &lt;input
        value={text}
        onChange={(e) =&gt; setText(e.target.value)}
        placeholder=&quot;やることを入力&quot;
      /&gt;
      &lt;button onClick={handleAdd}&gt;追加&lt;/button&gt;

      &lt;ul&gt;
        {todos.map((todo, index) =&gt; (
          &lt;li key={index}&gt;{todo}&lt;/li&gt;
        ))}
      &lt;/ul&gt;
    &lt;/div&gt;
  );
}
</code></pre>

<div class="tip-box">
<h3>💡 フォームのポイントまとめ</h3>
<ul>
<li><strong>value={state}</strong>: 表示内容は state が決める</li>
<li><strong>onChange</strong>: 入力のたびに state を更新</li>
<li><strong>送信後は setText("")</strong>: 入力欄をクリア</li>
<li><strong>trim() でチェック</strong>: 空白だけの入力を防ぐ</li>
</ul>
</div>

<hr />
<h2 id="3-useeffect---副作用の処理">3. useEffect - 副作用の処理<a class="header-link" href="#3-useeffect---副作用の処理" title="Permanent link">&para;</a></h2>
<h3 id="まず副作用って何">まず「副作用」って何？<a class="header-link" href="#まず副作用って何" title="Permanent link">&para;</a></h3>
<div class="info-box">
<h3>🤔 副作用（Side Effect）とは</h3>
<p><strong>副作用 = 画面の描画以外の処理</strong></p>
<table>
<tr><th>画面描画（本業）</th><th>副作用（本業以外）</th></tr>
<tr><td>文字を表示する</td><td>サーバーからデータを取る</td></tr>
<tr><td>ボタンを表示する</td><td>ローカルストレージに保存</td></tr>
<tr><td>リストを表示する</td><td>タイマーを設定する</td></tr>
<tr><td>色を変える</td><td>イベントリスナーを登録</td></tr>
</table>
<p>💡 Reactコンポーネントの本業は「画面を描くこと」。<br>
それ以外の処理はすべて「副作用」と呼ぶ</p>
</div>

<h3 id="なぜ-useeffect-が必要なのか">なぜ useEffect が必要なのか？<a class="header-link" href="#なぜ-useeffect-が必要なのか" title="Permanent link">&para;</a></h3>
<div class="warning-box">
<h3>⚠️ useEffect なしで API を呼ぶとどうなる？</h3>
<div class="box-content">


<pre class="codehilite"><code class="language-tsx">// ❌ 悪い例: useEffect なしで API を呼ぶ
function UserProfile() {
  const [user, setUser] = useState(null);

  // ここに書くと...
  fetch('/api/user').then(data =&gt; setUser(data));  // 無限ループ！

  return &lt;div&gt;{user?.name}&lt;/div&gt;;
}
</code></pre>



**何が起きる？**
<pre>
① コンポーネント実行 → fetch() 呼ばれる
② setUser() で state 更新 → 再レンダリング発生
③ コンポーネント再実行 → fetch() また呼ばれる
④ setUser() で state 更新 → 再レンダリング発生
⑤ 無限ループ！！！💥
</pre>

**useEffect を使う理由:**
「画面が表示されたときに1回だけ」実行したいから

</div>
</div>

<h3 id="useeffect-の基本形">useEffect の基本形<a class="header-link" href="#useeffect-の基本形" title="Permanent link">&para;</a></h3>
<pre class="codehilite"><code class="language-tsx">useEffect(() =&gt; {
  // ここに「やりたい処理」を書く
}, []);  // ← これは「依存配列」
</code></pre>

<div class="flow-box">
<h3>📝 useEffect の書き方</h3>
<pre>
useEffect(
  () => { ... },    ← 第1引数: 実行したい処理（関数）
  []                ← 第2引数: 依存配列（いつ実行するか）
);

依存配列の意味:
  []      → 最初の1回だけ実行（画面が表示されたとき）
  [userId] → userId が変わるたびに実行
  なし    → 毎回実行（ほぼ使わない）
</pre>
</div>

<h3 id="先に-promise-を理解しよう">先に Promise を理解しよう<a class="header-link" href="#先に-promise-を理解しよう" title="Permanent link">&para;</a></h3>
<p>useEffect の中で <code>fetch().then()</code> を使うので、先に Promise を理解しましょう。</p>
<div class="info-box">
<h3>⏳ Promise とは「約束」</h3>
<p><strong>Promise = 「あとで結果を教えるよ」という約束</strong></p>
<pre>
【レストランで例えると】

店員:「料理ができたらお呼びしますね」← これが Promise
    ↓
（あなたは待つ）
    ↓
店員:「できました！」← Promise が解決（resolve）
    ↓
あなた: 料理を受け取る ← .then() で結果を受け取る
</pre>
<p>サーバーとの通信は時間がかかるので「あとで結果を教える」仕組みが必要</p>
</div>

<h3 id="fetch-とは">fetch とは？<a class="header-link" href="#fetch-とは" title="Permanent link">&para;</a></h3>
<p><code>fetch</code> は <strong>バックエンドAPI にリクエストを送る関数</strong>です。</p>
<pre class="codehilite"><code class="language-tsx">// このプロジェクトでの使用例
fetch('/api/chat', { method: 'POST', body: JSON.stringify({ message: 'こんにちは' }) })
//     ↑ Backend の API      ↑ AIにメッセージを送信
</code></pre>

<p>フロントエンド（ブラウザ）→ バックエンド（サーバー）への通信に使います。</p>
<h3 id="promise-の返り値">Promise の返り値<a class="header-link" href="#promise-の返り値" title="Permanent link">&para;</a></h3>
<p><code>fetch</code> などの通信関数を呼ぶと、<strong>すぐには結果が返ってこない</strong>のがポイントです。</p>
<pre class="codehilite"><code class="language-tsx">// ❌ こう書いても、result には Promise オブジェクトが入るだけ
const result = fetch('/api/user');
console.log(result);  // Promise { &lt;pending&gt; } ← まだ結果がない！

// ✅ 結果を受け取るには .then() を使う
fetch('/api/user').then(response =&gt; {
  console.log(response);  // ← ここで初めて結果が使える！
});
</code></pre>

<div class="warning-box">
<h3>⚠️ 初心者がハマるポイント</h3>
<p>Promise を返す関数（fetch など）は、<strong>呼んだ瞬間には結果が返ってこない</strong>。<br>
結果を使うには <code>.then()</code> の中で受け取る必要がある！</p>
</div>

<h3 id="then-の書き方">.then() の書き方<a class="header-link" href="#then-の書き方" title="Permanent link">&para;</a></h3>
<pre class="codehilite"><code class="language-tsx">// fetch() は Promise を返す
fetch('/api/user')      // ① サーバーにリクエスト送信（時間かかる）
  .then(response =&gt; {   // ② レスポンスが返ってきたら実行
    return response.json();  // JSON に変換（これも Promise）
  })
  .then(data =&gt; {       // ③ JSON 変換が終わったら実行
    console.log(data);  // { name: &quot;太郎&quot;, age: 25 }
  });
</code></pre>

<div class="tip-box">
<h3>💡 引数名は自由につけてOK！</h3>
<p><code>.then(response => ...)</code> の <code>response</code> は<strong>ただの変数名</strong>です。好きな名前をつけられます。</p>
<pre>
// どれも同じ動作！
.then(response => { ... })  // よく使われる名前
.then(res => { ... })       // 省略形
.then(r => { ... })         // 短い名前
.then(なんでもOK => { ... }) // 日本語でも動く（非推奨）
</pre>
<p>ただし、<strong>何が入ってくるか分かりやすい名前</strong>をつけるのがベスト！<br>
fetch の結果なら <code>response</code>、JSONデータなら <code>data</code> など。</p>
</div>

<div class="flow-box">
<h3>🔄 .then() の処理の流れ</h3>
<pre>
fetch('/api/user')  ← サーバーにリクエスト（1〜2秒かかる）
        │
        │  待っている間、他の処理は続く
        ↓
    .then(response => ...)  ← レスポンス到着！ここが実行される
        │
        ↓
    .then(data => ...)  ← 次の処理

💡 ポイント: .then() は「終わったら次へ」を繋げていく
</pre>
</div>

<h3 id="useeffect--fetch-の完全な例">useEffect + fetch の完全な例<a class="header-link" href="#useeffect--fetch-の完全な例" title="Permanent link">&para;</a></h3>
<pre class="codehilite"><code class="language-tsx">import { useState, useEffect } from 'react';

function UserProfile() {
  const [user, setUser] = useState(null);

  useEffect(() =&gt; {
    // 画面が表示されたときに1回だけ実行
    fetch('/api/user')
      .then(response =&gt; response.json())  // JSON に変換
      .then(data =&gt; {
        setUser(data);  // state を更新
      });
  }, []);  // [] = 最初の1回だけ

  return &lt;div&gt;{user?.name}&lt;/div&gt;;
}
</code></pre>

<div class="architecture-box">
<h3>🔍 このコードを1行ずつ解説</h3>
<pre>
const [user, setUser] = useState(null);
       ↑         ↑              ↑
    現在値   更新関数      初期値（まだデータない）

useEffect(() => {
    ↑
  「画面が表示されたら実行して」という指示

  fetch('/api/user')
    ↑
  サーバーに「ユーザー情報ちょうだい」と依頼

    .then(response => response.json())
      │                    ↑
      │       返ってきたデータを JSON 形式に変換
      │
      │  📦 ここで返される値（JavaScript オブジェクト）が
      │     次の .then() の data に渡される！
      ↓
    .then(data => {
      setUser(data);  ← state を更新 → 画面が再描画される
    });

🔗 .then() チェーンのデータの流れ:

fetch('/api/user')
    │
    │ 返り値: Response オブジェクト（まだ JSON じゃない）
    ↓
.then(response => response.json())
    │
    │ 返り値: { name: "太郎", age: 25 }（JavaScript オブジェクト）
    │        ※ JSON文字列 → オブジェクトに変換済み
    ↓
.then(data => setUser(data))
    │
    │ data = { name: "太郎", age: 25 } ← 上の返り値がそのまま来る！
    │ これを setUser() に渡して state を更新
    ↓
  完了！画面が再描画される

}, []);
   ↑
 空配列 = 最初の1回だけ実行

return <div>{user?.name}</div>;
             ↑
           user が null の間は何も表示しない
           user にデータが入ったら名前を表示
</pre>
</div>

<h3 id="username-の意味オプショナルチェーン">user?.name の意味（オプショナルチェーン）<a class="header-link" href="#username-の意味オプショナルチェーン" title="Permanent link">&para;</a></h3>
<pre class="codehilite"><code class="language-tsx">// user?.name は以下と同じ意味
user ? user.name : undefined

// もし user が null や undefined だったら、
// .name にアクセスせず undefined を返す
// → エラーにならない！
</code></pre>

<h3 id="asyncawait-で書き直すより読みやすい">async/await で書き直す（より読みやすい）<a class="header-link" href="#asyncawait-で書き直すより読みやすい" title="Permanent link">&para;</a></h3>
<p><code>.then()</code> の代わりに <code>async/await</code> を使うと読みやすくなります。</p>
<pre class="codehilite"><code class="language-tsx">useEffect(() =&gt; {
  // 内部で async 関数を定義して即実行
  const fetchData = async () =&gt; {
    const response = await fetch('/api/user');  // 待つ
    const data = await response.json();         // 待つ
    setUser(data);
  };

  fetchData();  // 実行
}, []);
</code></pre>

<div class="tip-box">
<h3>💡 .then() と async/await は同じこと</h3>
<pre>
【.then() 版】
fetch('/api/user')
  .then(response => response.json())
  .then(data => setUser(data));

【async/await 版】
const response = await fetch('/api/user');
const data = await response.json();
setUser(data);

どちらも「終わるまで待つ」を表現している
async/await の方が「上から順に読める」ので読みやすい
</pre>
</div>

<h3 id="依存配列のパターン">依存配列のパターン<a class="header-link" href="#依存配列のパターン" title="Permanent link">&para;</a></h3>
<pre class="codehilite"><code class="language-tsx">// パターン1: 最初の1回だけ実行（一番よく使う）
useEffect(() =&gt; {
  console.log(&quot;画面が表示されたときに1回だけ&quot;);
}, []);  // 空配列 = 1回だけ

// パターン2: 特定の値が変わったら実行
useEffect(() =&gt; {
  console.log(&quot;userId が変わったから、データを取り直す&quot;);
  fetchUserData(userId);
}, [userId]);  // userId が変わるたびに実行

// パターン3: 毎回実行（ほぼ使わない）
useEffect(() =&gt; {
  console.log(&quot;レンダリングのたびに実行&quot;);
});  // 依存配列なし = 毎回

// パターン4: クリーンアップ関数付き（後で詳しく解説）
useEffect(() =&gt; {
  const timer = setInterval(() =&gt; console.log('tick'), 1000);
  return () =&gt; { clearInterval(timer); };
}, []);
</code></pre>

<hr />
<h3 id="-ブレイクタイム-パターン4を徹底解説">☕ ブレイクタイム: パターン4を徹底解説<a class="header-link" href="#-ブレイクタイム-パターン4を徹底解説" title="Permanent link">&para;</a></h3>
<p>パターン4が難しいと感じる人が多いので、ここで丁寧に解説します。</p>
<p><strong>まず、コードの構造を分解してみましょう:</strong></p>
<pre class="codehilite"><code class="language-tsx">useEffect(           // ← useEffect を呼び出す
  () =&gt; {            // ← 第1引数: 関数（エフェクト本体）
    // ここが「画面表示時」に実行される部分

    return () =&gt; {   // ← クリーンアップ関数を返す
      // ここが「画面から消える時」に実行される部分
    };
  },
  []                 // ← 第2引数: 依存配列（空 = 初回のみ）
);
</code></pre>

<p><strong>図で見ると:</strong></p>
<div style="background: #1e293b; border-radius: 8px; padding: 20px; font-family: monospace; color: #e2e8f0; display: flex; align-items: flex-start; gap: 8px;">
  <div style="color: #94a3b8;">useEffect(</div>
  <div style="border: 2px solid #64748b; border-radius: 6px; padding: 12px; flex: 1;">
    <div style="color: #f8fafc;">() =&gt; {</div>
    <div style="padding-left: 20px; margin: 8px 0;">
      <div style="color: #94a3b8;">① 画面表示時の処理</div>
      <div style="color: #f8fafc;">const timer = setInterval(...);</div>
    </div>
    <div style="padding-left: 20px; margin-top: 12px;">
      <div style="color: #f8fafc;">return () =&gt; {</div>
      <div style="padding-left: 20px;">
        <div style="color: #94a3b8;">② 画面消去時の処理</div>
        <div style="color: #f8fafc;">clearInterval(timer);</div>
      </div>
      <div style="color: #f8fafc;">};</div>
    </div>
    <div style="color: #f8fafc; margin-top: 8px;">}</div>
  </div>
  <div style="color: #94a3b8;">, []);</div>
  <div style="margin-left: 12px; font-size: 0.9em;">
    <div style="color: #fbbf24; margin-bottom: 40px;">← 関数を「定義」している<br>　（実行ではない！）</div>
    <div style="color: #fbbf24;">← 関数を返す<br>　（まだ実行しない！）</div>
  </div>
</div>

<div class="warning-box">
<h3>⚠️ 「() => {}」が紛らわしい理由</h3>

**Q: `() => { clearInterval(timer); }` って、実行してるんじゃないの？**

A: **いいえ！これは「関数を定義している」だけです。**

`() => {}` は「実行している」ように見えますが、実は「関数を作っている」だけ。
関数を実行するには、関数自体の後ろに `()` をつける必要があります。

<pre>
【比較してみよう】

clearInterval;           ← ❌ 実行されない（関数の参照だけ）
clearInterval(timer);    ← ✅ 実行される（引数付きで呼び出し）

() => { clearInterval(timer); }      ← ❌ 関数を「定義」しているだけ
(() => { clearInterval(timer); })()  ← ✅ 関数を定義して「即実行」（IIFE）
                                ↑↑
                     この () で実行！

💡 つまり (() => { clearInterval(timer); })() は
   clearInterval(timer); と同じ結果になる！
   （わざわざ関数で包んで即実行 = 直接実行と等価）
</pre>

**つまり:**

<table>
<tr><th>書き方</th><th>何をしている？</th><th>実行タイミング</th></tr>
<tr><td><code>clearInterval(timer)</code></td><td>関数を呼び出す</td><td><strong>今すぐ</strong>実行</td></tr>
<tr><td><code>() => { clearInterval(timer); }</code></td><td>関数を作る</td><td><strong>まだ</strong>実行されない</td></tr>
<tr><td><code>return () => { ... }</code></td><td>関数を作って返す</td><td><strong>後で</strong>誰かが呼ぶと実行</td></tr>
</table>

**だから useEffect の return は:**


<pre class="codehilite"><code class="language-javascript">return () =&gt; { clearInterval(timer); };
//     ↑
//     「実行の仕方」を返している（関数を返す）
//     「実行した結果」を返しているわけではない！
</code></pre>



Reactはこの「実行の仕方」を受け取って保存し、画面が消えるときに呼び出します。

💡 **詳しくは上の「[アロー関数の基礎](#-pythonエンジニア向け-アロー関数の基礎)」を参照！**

</div>

<hr />
<p><strong>実際のタイマーの例:</strong></p>
<pre class="codehilite"><code class="language-tsx">useEffect(() =&gt; {
  // ① 画面表示時: タイマー開始
  const timer = setInterval(() =&gt; {
    fetchNewMessages();  // 1秒ごとに新着確認
  }, 1000);

  // ② 画面消去時: タイマー停止
  return () =&gt; {
    clearInterval(timer);
  };
}, []);
</code></pre>

<div class="warning-box">
<h3>⚠️ よくある疑問: setInterval は「完了」しないの？</h3>

**Q: setInterval が動き続けるなら、次の行（return）に到達しないのでは？**

A: **いいえ、到達します！** setInterval は **非同期** だからです。

<pre>
【誤解しやすいイメージ】（❌ 間違い）

const timer = setInterval(...);  ← ここで1秒待機...?
return () => { ... };            ← setIntervalが終わるまで到達しない...?
</pre>

<pre>
【実際の動き】（✅ 正解）

const timer = setInterval(...);  ← 「予約だけ」して即座に次へ進む！
return () => { ... };            ← すぐにここに到達する！
</pre>

**setInterval は「内部でwhileループで待機」しているわけではありません。**

<table>
<tr><th>イメージ</th><th>実際の動作</th></tr>
<tr><td>❌ whileループで待つ<br>（ブロッキング）</td><td>✅ 予約だけして即座に戻る<br>（ノンブロッキング）</td></tr>
<tr><td>❌ setInterval完了まで待機</td><td>✅ ブラウザのタイマーに「後で呼んで」と依頼するだけ</td></tr>
</table>

**🐍 Pythonで例えると:**

setInterval は **Python の `async`/`await`** に近い概念です。


<pre class="codehilite"><code class="language-python"># Python の async（ブロックしない）
async def poll():
    while True:
        print(&quot;tick&quot;)
        await asyncio.sleep(1)  # ← 他の処理に譲る

# JavaScript の setInterval（ブロックしない）
setInterval(() =&gt; console.log(&quot;tick&quot;), 1000);  // ← 登録後、即座に次の行へ
</code></pre>



どちらも「メインスレッドをブロックせず、後でコールバックを実行する」という非同期の考え方です。

</div>

<p><strong>時系列で見ると:</strong></p>
<pre>
ユーザーがチャット画面を開く
    ↓
useEffect の関数が実行される
    ↓
① const timer = setInterval(...)
   → ブラウザ:「1秒ごとに呼ぶね」と予約（即座に完了）
    ↓
② return () => { clearInterval(timer); }
   → クリーンアップ関数をReactに渡す（即座に完了）
    ↓
useEffect 完了！（ここまで一瞬）
    ↓
〜〜〜 バックグラウンドでタイマーが動く 〜〜〜
    ↓
1秒後: fetchNewMessages() 実行
2秒後: fetchNewMessages() 実行
3秒後: fetchNewMessages() 実行
... （ずっと続く）
    ↓
ユーザーが設定画面に移動
    ↓
Reactが return の関数を実行
    ↓
clearInterval(timer) でタイマー停止
    ↓
もう fetchNewMessages() は呼ばれない ✅
</pre>

<div class="info-box">
<h3>🎯 useEffect のライフサイクル</h3>
<p>コンポーネントの一生:</p>
<pre>
[マウント] ─────→ [更新] ─────→ [更新] ─────→ [アンマウント]
    ↓                ↓            ↓                ↓
useEffect        依存配列の     依存配列の      クリーンアップ
実行             値が変わった   値が変わった      関数実行
                 ら再実行       ら再実行
</pre>
<ul>
<li><strong>マウント</strong> = 画面に表示されたとき</li>
<li><strong>アンマウント</strong> = 画面から消えたとき（別ページに移動など）</li>
<li><strong>クリーンアップ</strong> = タイマー停止、イベント解除など後片付け</li>
</ul>
</div>

<h3 id="実践例-ローディング状態の管理">実践例: ローディング状態の管理<a class="header-link" href="#実践例-ローディング状態の管理" title="Permanent link">&para;</a></h3>
<pre class="codehilite"><code class="language-tsx">function UserProfile() {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);   // ローディング中か？（true = 読み込み中）
  const [error, setError] = useState(null);       // エラーメッセージ（なければ null）

  useEffect(() =&gt; {
    fetch('/api/user')
      .then(response =&gt; {
        // response.ok = HTTPステータスが 200-299 なら true
        // !response.ok = 失敗（404, 500 など）なら true
        if (!response.ok) throw new Error('取得失敗');  // ← エラーを投げて .catch へ飛ばす
        return response.json();  // JSONをパースして次の .then へ
      })
      .then(data =&gt; {
        setUser(data);
        setLoading(false);  // ローディング終了（false = もう読み込み中じゃない）
      })
      .catch(err =&gt; {
        // ↑ の throw や、通信エラーがここに来る
        setError(err.message);  // err.message = &quot;取得失敗&quot; など
        setLoading(false);      // エラーでも読み込みは終了
      });
  }, []);

  // 状態に応じて表示を切り替え
  if (loading) return &lt;div&gt;読み込み中...&lt;/div&gt;;
  if (error) return &lt;div&gt;エラー: {error}&lt;/div&gt;;
  return &lt;div&gt;{user.name}&lt;/div&gt;;
}
</code></pre>

<div class="tip-box">
<h3>💡 loading = true は「読み込み中」という意味</h3>

**Q: 「ローディング中をtrueにする」って変じゃない？**

A: これは**フラグ（旗）**の考え方です。


<pre class="codehilite"><code>loading = true   → 「ローディング中フラグが立っている」→ 読み込み中
loading = false  → 「ローディング中フラグが下りている」→ 読み込み完了
</code></pre>



**実際の開発でもこの書き方が標準です：**
- `isLoading` や `loading` という名前で「〜中かどうか」を表す
- `true` = その状態である、`false` = その状態ではない


<pre class="codehilite"><code class="language-tsx">// よく見るパターン
const [isLoading, setIsLoading] = useState(true);   // 読み込み中？
const [isOpen, setIsOpen] = useState(false);        // モーダルが開いている？
const [isSubmitting, setIsSubmitting] = useState(false);  // 送信中？
</code></pre>



</div>

<hr />
<h2 id="4-カスタムフック---ロジックの再利用">4. カスタムフック - ロジックの再利用<a class="header-link" href="#4-カスタムフック---ロジックの再利用" title="Permanent link">&para;</a></h2>
<h3 id="カスタムフックとは">カスタムフックとは？<a class="header-link" href="#カスタムフックとは" title="Permanent link">&para;</a></h3>
<p><code>use</code> で始まる関数。useState や useEffect を組み合わせて、<br />
<strong>よく使う処理をまとめて、分かりやすい名前をつける</strong>ことができます。</p>
<h3 id="ステップ1-まずデフォルト引数を理解しよう">ステップ1: まずデフォルト引数を理解しよう<a class="header-link" href="#ステップ1-まずデフォルト引数を理解しよう" title="Permanent link">&para;</a></h3>
<pre class="codehilite"><code class="language-tsx">function useCounter(initialValue = 0) {
//                              ↑
//              「引数が渡されなかったら 0 を使う」という意味
</code></pre>

<table>
<thead>
<tr>
<th>呼び出し方</th>
<th>initialValue の値</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>useCounter()</code></td>
<td><code>0</code>（デフォルト）</td>
</tr>
<tr>
<td><code>useCounter(5)</code></td>
<td><code>5</code></td>
</tr>
<tr>
<td><code>useCounter(100)</code></td>
<td><code>100</code></td>
</tr>
</tbody>
</table>
<h3 id="ステップ2-カスタムフックの中身を理解しよう">ステップ2: カスタムフックの中身を理解しよう<a class="header-link" href="#ステップ2-カスタムフックの中身を理解しよう" title="Permanent link">&para;</a></h3>
<pre class="codehilite"><code class="language-tsx">function useCounter(initialValue = 0) {
  // ① useState で状態を作る
  const [count, setCount] = useState(initialValue);
  //     ↑
  //     count は「現在の数値」（0, 1, 2...）← 関数ではなく値！

  // ② setCount を「使いやすくラップした関数」を作る
  const increment = () =&gt; setCount(count + 1);  // +1 専用
  const decrement = () =&gt; setCount(count - 1);  // -1 専用
  const reset = () =&gt; setCount(initialValue);   // リセット専用

  // ③ 値と関数をまとめて返す
  return { count, increment, decrement, reset };
}
</code></pre>

<div class="info-box">
<h3>💡 なぜ increment, decrement, reset を作るの？</h3>
<p><code>setCount</code> を直接使うこともできますが、ラップ関数を作ると便利です。</p>
<pre>
setCount（React の基本機能）
    │
    ├─→ increment = () => setCount(count + 1)  ← +1専用に強化
    │
    ├─→ decrement = () => setCount(count - 1)  ← -1専用に強化
    │
    └─→ reset = () => setCount(initialValue)   ← リセット専用に強化
</pre>
<p><strong>メリット:</strong> 使う側が「+1って何だっけ？」と考えなくていい。<code>increment</code> という意味のある名前で呼べる！</p>
</div>

<h3 id="ステップ3-返り値を理解しよう">ステップ3: 返り値を理解しよう<a class="header-link" href="#ステップ3-返り値を理解しよう" title="Permanent link">&para;</a></h3>
<p><code>return { count, increment, decrement, reset }</code> で返しているものを整理：</p>
<table>
<thead>
<tr>
<th>名前</th>
<th>型</th>
<th>中身の例</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>count</code></td>
<td><strong>数値</strong></td>
<td><code>0</code>, <code>1</code>, <code>2</code>...</td>
</tr>
<tr>
<td><code>increment</code></td>
<td><strong>関数</strong></td>
<td><code>() =&gt; setCount(count + 1)</code></td>
</tr>
<tr>
<td><code>decrement</code></td>
<td><strong>関数</strong></td>
<td><code>() =&gt; setCount(count - 1)</code></td>
</tr>
<tr>
<td><code>reset</code></td>
<td><strong>関数</strong></td>
<td><code>() =&gt; setCount(initialValue)</code></td>
</tr>
</tbody>
</table>
<div class="warning-box">
<h3>⚠️ 注意: count は関数ではなく「値」！</h3>
<p><code>increment</code>, <code>decrement</code>, <code>reset</code> は関数ですが、<code>count</code> は<strong>ただの数値</strong>です。</p>
</div>

<h3 id="ステップ4-使う側を理解しよう分割代入">ステップ4: 使う側を理解しよう（分割代入）<a class="header-link" href="#ステップ4-使う側を理解しよう分割代入" title="Permanent link">&para;</a></h3>
<pre class="codehilite"><code class="language-tsx">const { count, increment } = useCounter(0);
</code></pre>

<p>これは<strong>分割代入</strong>という書き方です。以下と同じ意味：</p>
<pre class="codehilite"><code class="language-tsx">// ステップ1: useCounter(0) を呼ぶと、オブジェクトが返ってくる
const result = useCounter(0);
// result = { count: 0, increment: [関数], decrement: [関数], reset: [関数] }

// ステップ2: 必要なものだけ取り出す
const count = result.count;           // 0
const increment = result.increment;   // +1する関数
</code></pre>

<p>この2ステップを <strong>1行で書ける</strong> のが分割代入：</p>
<pre class="codehilite"><code class="language-tsx">const { count, increment } = useCounter(0);
//      ↑      ↑
//      必要なものだけ名前で取り出す（decrement, reset は使わないから書かない）
</code></pre>

<h3 id="ステップ5-実際に使ってみよう">ステップ5: 実際に使ってみよう<a class="header-link" href="#ステップ5-実際に使ってみよう" title="Permanent link">&para;</a></h3>
<pre class="codehilite"><code class="language-tsx">// 使う側A
function ComponentA() {
  const { count, increment } = useCounter(0);
  //             ↑ decrement, reset は使わないから取り出さない

  return &lt;button onClick={increment}&gt;{count}&lt;/button&gt;;
  //              ↑ 関数          ↑ 値（数値）
}

// 使う側B
function ComponentB() {
  const { count, increment, reset } = useCounter(100);
  //                        ↑ reset も使うから取り出す

  return (
    &lt;div&gt;
      &lt;span&gt;{count}&lt;/span&gt;           {/* ← 値をそのまま表示 */}
      &lt;button onClick={increment}&gt;+&lt;/button&gt;  {/* ← 関数を実行 */}
      &lt;button onClick={reset}&gt;リセット&lt;/button&gt;
    &lt;/div&gt;
  );
}
</code></pre>

<div class="tip-box">
<h3>✨ カスタムフックのメリット</h3>
<ol>
<li><strong>ロジックの再利用</strong><br>同じ処理を複数のコンポーネントで使い回せる</li>
<li><strong>コンポーネントがスッキリ</strong><br>複雑なロジックをフックに分離 → コンポーネントは表示に専念</li>
<li><strong>分かりやすい名前</strong><br><code>setCount(count + 1)</code> より <code>increment</code> の方が意図が明確</li>
</ol>
<p>⚠️ ルール:</p>
<ul>
<li>名前は必ず use で始める（例: useAuth, useChat）</li>
<li>フックはトップレベルでのみ呼び出す（if文の中はダメ）</li>
</ul>
</div>

<hr />
<h2 id="5-apptsx---アプリのメインコンポーネント">5. App.tsx - アプリのメインコンポーネント<a class="header-link" href="#5-apptsx---アプリのメインコンポーネント" title="Permanent link">&para;</a></h2>
<p>このアプリの「親玉」。全体の流れを管理します。</p>
<h3 id="完全なコードコメント付き">完全なコード（コメント付き）<a class="header-link" href="#完全なコードコメント付き" title="Permanent link">&para;</a></h3>
<pre class="codehilite"><code class="language-tsx">/**
 * App.tsx - フロントエンドのメインコンポーネント
 *
 * 役割:
 *   - 未ログイン → LoginScreen を表示
 *   - ログイン済 → ChatScreen を表示
 */
import { ChatScreen } from './components/ChatScreen'
import { LoginScreen } from './components/LoginScreen'
import { useAuth } from './hooks/useAuth'
import { useChat } from './hooks/useChat'
import { useSessions } from './hooks/useSessions'

/**
 * デバッグモード: 開発環境でのみ有効
 * - true: 認証をスキップしてチャット画面を表示（画面確認用）
 * - false: 通常の認証フローを使用
 */
const DEBUG_SHOW_CHAT = import.meta.env.DEV &amp;&amp; import.meta.env.VITE_DEBUG_MODE === 'true'

function App() {
  // ───────────────────────────────────────────────────────────────
  // カスタムフックを使って状態を取得
  // ───────────────────────────────────────────────────────────────

  // 認証状態（ユーザー情報、ログイン関数など）
  const { user, loading, error: authError, loginWithGoogle, logout } = useAuth()

  // セッション管理（複数の会話を管理）
  const {
    sessions,              // セッション一覧
    activeSession,         // 現在選択中のセッション
    activeSessionId,       // 現在のセッションID
    createSession,         // 新規セッション作成
    switchSession,         // セッション切り替え
    closeSession,          // セッション削除
    updateSessionMessages, // メッセージ更新
  } = useSessions()

  // チャット状態（メッセージ、送信関数など）
  const { messages, isLoading, error: chatError, sendMessage } = useChat({
    activeSession,
    onMessagesUpdate: updateSessionMessages,
  })

  // ───────────────────────────────────────────────────────────────
  // 条件分岐で表示する画面を決定
  // ───────────────────────────────────────────────────────────────

  // ローディング中（認証状態の確認中）
  if (loading &amp;&amp; !DEBUG_SHOW_CHAT) {
    return (
      &lt;div className=&quot;loading-screen&quot;&gt;
        &lt;div className=&quot;spinner&quot; /&gt;
        &lt;p&gt;読み込み中...&lt;/p&gt;
      &lt;/div&gt;
    )
  }

  // 未ログイン → ログイン画面を表示
  if (!user &amp;&amp; !DEBUG_SHOW_CHAT) {
    return &lt;LoginScreen onLogin={loginWithGoogle} error={authError} /&gt;
  }

  // ログイン済み → チャット画面を表示
  const displayUser = user || { email: 'demo@example.com', displayName: 'Demo User' }

  return (
    &lt;ChatScreen
      user={displayUser}
      messages={messages}
      isLoading={isLoading}
      error={chatError}
      onSendMessage={sendMessage}
      onLogout={logout}
      sessions={sessions}
      activeSessionId={activeSessionId}
      onSelectSession={switchSession}
      onNewSession={createSession}
      onCloseSession={closeSession}
    /&gt;
  )
}

export default App
</code></pre>

<div class="flow-box">
<h3>🔍 App.tsx の処理フロー</h3>

<!-- App 起動 -->
<div style="display: flex; flex-direction: column; align-items: center; gap: 8px;">
  <div style="background: #3b82f6; color: white; padding: 12px 24px; border-radius: 8px; font-weight: bold;">
    App 起動
  </div>
  <div style="font-size: 1.5em; color: #3b82f6;">▼</div>
</div>

<!-- loading チェック -->
<div style="display: flex; align-items: center; gap: 16px; margin: 16px 0; flex-wrap: wrap;">
  <div style="background: #fbbf24; color: #1e293b; padding: 12px 20px; border-radius: 8px; text-align: center; min-width: 120px;">
    <div style="font-weight: bold;">loading?</div>
    <div style="font-size: 0.9em;">true</div>
  </div>
  <div style="font-size: 1.5em; color: #fbbf24;">→</div>
  <div style="background: #fef3c7; border: 2px solid #fbbf24; padding: 12px 20px; border-radius: 8px; flex: 1; min-width: 200px;">
    ローディング画面表示（スピナー）
  </div>
</div>

<div style="display: flex; flex-direction: column; align-items: center; gap: 8px;">
  <div style="color: #6b7280; font-size: 0.9em;">↓ false</div>
</div>

</details>
      </article>
      <footer class="footer">
        GCP AI Agent 設計資料 | Built with Python & Markdown
      </footer>
    </main>
  </div>

  <script>
    function toggleSidebar() {
      document.getElementById('sidebar').classList.toggle('open');
    }

    // Close sidebar when clicking outside on mobile
    document.addEventListener('click', function(e) {
      const sidebar = document.getElementById('sidebar');
      const toggle = document.querySelector('.menu-toggle');
      if (!sidebar.contains(e.target) && !toggle.contains(e.target)) {
        sidebar.classList.remove('open');
      }
    });
  </script>
</body>
</html>