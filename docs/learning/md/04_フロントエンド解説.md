# フロントエンド解説

<div class="chapter-hero">
<span class="emoji">🎨</span>
<h1>フロントエンド解説</h1>
<p class="subtitle">「え？Reactってレゴブロックみたいなもの？」<br>「そう！画面のパーツを組み合わせて作るんだ！」</p>
</div>

---

## この章で学ぶこと

<div class="goal-box">
<h3>📚 学習目標</h3>
<ol>
<li>Reactの基本概念（コンポーネント、JSX）</li>
<li>useState と useEffect の仕組み</li>
<li>カスタムフックの作り方と使い方</li>
<li>認証処理の流れ（useAuth.ts）</li>
<li>チャット処理の流れ（useChat.ts）</li>
<li>セッション管理の仕組み（useSessions.ts）</li>
<li>API通信とストリーミング（api.ts）</li>
<li>TypeScriptの型システム</li>
</ol>
<p><strong>⏱️ 想定学習時間: 45分</strong></p>
</div>

---

## 使っている技術

| 技術 | 役割 | なぜ使う？ |
|------|------|----------|
| **React** | UIを作るライブラリ | コンポーネントで画面を組み立てられる |
| **TypeScript** | 型のあるJavaScript | 間違いを事前に防げる |
| **Vite** | 開発サーバー・ビルドツール | 超高速！変更が即座に反映 |
| **Firebase SDK** | Firebase連携 | 認証やデータベースを簡単に使える |

---

## ファイルの拡張子を理解しよう

<div class="info-box">
<h3>📝 拡張子の意味</h3>
<table>
<tr><th>拡張子</th><th>意味</th><th>用途</th></tr>
<tr><td><strong>.js</strong></td><td>JavaScript</td><td>普通のJavaScriptファイル</td></tr>
<tr><td><strong>.ts</strong></td><td>TypeScript</td><td>型付きJavaScript（HTMLを含まない）</td></tr>
<tr><td><strong>.jsx</strong></td><td>JavaScript + JSX</td><td>React用（HTMLっぽい記法を含む）</td></tr>
<tr><td><strong>.tsx</strong></td><td>TypeScript + JSX</td><td>React用＋型付き（<strong>このプロジェクトの主役</strong>）</td></tr>
</table>
<p><strong>【.tsx のポイント】</strong></p>
<pre>
// .ts ファイル（HTMLなし）
function add(a: number, b: number): number {
  return a + b;
}

// .tsx ファイル（HTMLあり = JSX）
function Button(): JSX.Element {
  return &lt;button&gt;クリック&lt;/button&gt;;  // ← これがJSX
}
</pre>
<p>💡 <strong>使い分け:</strong></p>
<ul>
<li>UIを含む（画面パーツ）→ <code>.tsx</code></li>
<li>UIを含まない（ロジックのみ）→ <code>.ts</code></li>
</ul>
</div>

---

## プロジェクト構成の全体像

<div class="architecture-box">
<h3>🏗️ Reactプロジェクトの構成</h3>
<pre>
src/frontend/
├── index.html           ← ★ HTMLの土台（1回だけ読み込まれる）
├── src/
│   ├── main.tsx         ← ★ Reactの起動スクリプト
│   ├── App.tsx          ← ★ メインコンポーネント
│   └── components/      ← 各種UIパーツ
├── .env                 ← 環境変数（APIキーなど）
└── vite.config.ts       ← Viteの設定
</pre>
</div>

<div class="warning-box">
<h3>⚠️ 超重要：どのファイルに何を書く？</h3>
<div class="box-content">

**【index.html】全ページ共通で1回だけ読み込むもの**
- Google Tag Manager (GTM)
- Google Analytics
- 外部CSS/フォント（Google Fontsなど）
- `<title>` や `<meta>` タグ
- favicon の設定

```html
<!-- index.html の例 -->
<!DOCTYPE html>
<html lang="ja">
<head>
  <!-- ↓ 全ページ共通で1回だけ読み込むもの -->
  <meta charset="UTF-8" />
  <title>AIチャット</title>
  <link rel="icon" href="/favicon.ico" />

  <!-- GTM（Google Tag Manager）-->
  <script>(function(w,d,s,l,i){...})(window,document,'script','dataLayer','GTM-XXXX');</script>

  <!-- Google Fonts -->
  <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP&display=swap" rel="stylesheet">
</head>
<body>
  <!-- ↓ Reactがここにコンポーネントを描画する -->
  <div id="root"></div>

  <!-- ↓ main.tsx を読み込んでReactを起動 -->
  <script type="module" src="/src/main.tsx"></script>
</body>
</html>
```

**【main.tsx】Reactを起動するだけ**
- `index.html` の `#root` にReactアプリを埋め込む
- 基本的に変更不要

```tsx
// main.tsx
import React from 'react'
import ReactDOM from 'react-dom/client'
import App from './App'

ReactDOM.createRoot(document.getElementById('root')!).render(
  <React.StrictMode>
    <App />  {/* ← ここからReactの世界が始まる */}
  </React.StrictMode>
)
```

**【App.tsx 以下】画面の中身**
- ログイン状態による表示切り替え
- チャット画面
- ヘッダー、フッターなどのUI
- 動的に変わる部分はすべてここ

</div>
</div>

<div class="flow-box">
<h3>🔄 読み込まれる順番</h3>
<pre>
ブラウザ
  │
  ↓ ① index.html を読む
  │
  ├─▶ &lt;head&gt; の中身を処理
  │     ・GTM スクリプト実行
  │     ・CSS/フォント読み込み
  │
  ├─▶ &lt;body&gt; の中身を処理
  │     ・#root という空の div を作成
  │
  ↓ ② main.tsx を読む
  │
  ├─▶ React を起動
  │     ・#root に App コンポーネントを描画
  │
  ↓ ③ App.tsx が描画される
  │
  └─▶ ユーザーの操作に応じて画面が更新
        ・ログイン → ChatScreen
        ・メッセージ送信 → 画面更新
</pre>
<p><strong>ポイント:</strong> index.html は「器」、React は「中身」を担当</p>
</div>

---

## ファイル構成（詳細）

```
src/frontend/src/
├── App.tsx              ← 🎯 メインコンポーネント（ここから始まる）
├── main.tsx             ← エントリーポイント（Reactの起動）
├── hooks/               ← 🎣 カスタムフック（ロジックを再利用）
│   ├── useAuth.ts       ← ログイン処理（UIなし → .ts）
│   ├── useChat.ts       ← チャット処理（UIなし → .ts）
│   └── useSessions.ts   ← セッション管理（UIなし → .ts）
├── services/            ← 外部サービス連携
│   ├── firebase.ts      ← Firebase初期化（UIなし → .ts）
│   └── api.ts           ← APIクライアント（UIなし → .ts）
├── components/          ← UIパーツ
│   ├── ChatScreen.tsx   ← チャット画面（UIあり → .tsx）
│   └── LoginScreen.tsx  ← ログイン画面（UIあり → .tsx）
└── renderers/           ← 【上級者向け】チャット表示カスタマイズ
```

<div class="tip-box">
<h3>💡 学習のポイント</h3>
<p>まず理解すべきファイル（優先順位順）:</p>
<ol>
<li><strong>App.tsx</strong> ← 全体の流れを把握</li>
<li><strong>useAuth.ts</strong> ← 認証の仕組み</li>
<li><strong>useChat.ts</strong> ← チャットの仕組み</li>
<li><strong>useSessions.ts</strong> ← セッション管理</li>
<li><strong>api.ts</strong> ← API通信の仕組み</li>
</ol>
<p>renderers/ は上級者向け。最初はスキップしてOK！</p>
</div>

---

## 1. Reactの基本概念

### コンポーネントとは？

<div class="architecture-box">
<h3>🧱 コンポーネント = 画面のパーツ（レゴブロック）</h3>
<pre>
┌───────────────────────────────────────────────────────────────────┐
│  App（親コンポーネント）                                            │
│  ┌──────────────────────────────────────────────────────────────┐ │
│  │  LoginScreen          または         ChatScreen              │ │
│  │  ┌─────────────┐                    ┌─────────────────────┐ │ │
│  │  │ LoginButton │                    │ SessionList        │ │ │
│  │  └─────────────┘                    │ MessageList        │ │ │
│  │                                      │ InputField         │ │ │
│  │                                      └─────────────────────┘ │ │
│  └──────────────────────────────────────────────────────────────┘ │
└───────────────────────────────────────────────────────────────────┘
</pre>
<p>コンポーネントを組み合わせて画面全体を作る！</p>
</div>

### JSX（JavaScript + HTML）

ReactではJSXという記法を使います。
JavaScript の中に HTML っぽく書ける！

```tsx
// ボタンコンポーネントの例
function MyButton() {
  // JavaScript の中に HTML っぽく書ける！
  return <button>クリック</button>;
}

// 使う側
function App() {
  return (
    <div>
      <h1>こんにちは</h1>
      <MyButton />  {/* ← 自作コンポーネントを使う */}
    </div>
  );
}
```

<div class="info-box">
<h3>📝 JSXの特徴</h3>
<ul>
<li>✅ HTML っぽく書ける（でも実は JavaScript）</li>
<li>✅ {} の中に JavaScript を書ける</li>
<li>✅ 自作コンポーネントは &lt;MyComponent /&gt; のように使う</li>
<li>✅ class は className と書く（JSの予約語だから）</li>
</ul>
<p><strong>例:</strong></p>
<pre>const name = "太郎";
return &lt;h1&gt;こんにちは、{name}さん！&lt;/h1&gt;;
// → "こんにちは、太郎さん！" と表示される</pre>
</div>

---

## 2. useState - 状態管理の基本

### useState とは？

コンポーネント内で「状態（データ）」を持つための仕組み。
状態が変わると、画面が自動で再描画される！

```tsx
import { useState } from 'react';

function Counter() {
  // ┌─────────────────────────────────────────────────────────────────┐
  // │ useState(初期値) の戻り値:                                       │
  // │   [0] 現在の値（count）                                          │
  // │   [1] 値を更新する関数（setCount）                                │
  // └─────────────────────────────────────────────────────────────────┘
  const [count, setCount] = useState(0);  // 初期値は 0

  return (
    <div>
      <p>カウント: {count}</p>
      <button onClick={() => setCount(count + 1)}>
        +1
      </button>
    </div>
  );
}
```

<div class="flow-box">
<h3>🔄 useState の動作</h3>
<ol>
<li><strong>最初のレンダリング</strong><br>count = 0<br>画面: 「カウント: 0」</li>
<li><strong>ボタンをクリック</strong><br>setCount(0 + 1) が呼ばれる</li>
<li><strong>React が再レンダリング</strong><br>count = 1<br>画面: 「カウント: 1」 ← 自動で更新！</li>
</ol>
<p>⚠️ 直接 count = 1 と書いても画面は更新されない！<br>必ず setCount() を使う！</p>
</div>

### 配列の分割代入

```tsx
// これ何？と思った人へ
const [count, setCount] = useState(0);

// ↑ は以下と同じ意味
const result = useState(0);      // [0, 関数] が返ってくる
const count = result[0];         // 現在の値
const setCount = result[1];      // 更新関数

// 「配列の分割代入」という JavaScript の機能
// 配列の要素を変数に展開できる
const [first, second] = [1, 2];  // first = 1, second = 2
```

### 「setCount」はどこで定義した？（超よくある質問）

<div class="warning-box">
<h3>❓ 「setCount って自分で作ってないのに、なぜ使える？」</h3>
<div class="box-content">

**答え: `useState` が内部で作って返してくれる**

```tsx
const [count, setCount] = useState(0);
//            ↑ これは useState が作った関数
```

自分で `function setCount() {...}` と書いたわけではない！
`useState` を呼ぶと、React が以下を返してくれる：

1. **現在の値**（`count`）
2. **その値を更新する関数**（`setCount`）

<pre>
useState(0) が返すもの:
┌─────────────────────────────────────────┐
│  [0] → 現在の値（最初は初期値の 0）       │
│  [1] → 更新関数（React が用意してくれる） │
└─────────────────────────────────────────┘
</pre>

**ポイント**: `setCount` を呼ぶと、Reactは：
1. 新しい値を内部に保存
2. コンポーネントを再レンダリング（画面更新）

</div>
</div>

### 初期値と現在値の違い（混乱しやすい）

```tsx
const [count, setCount] = useState(0);
//                                 ↑ 初期値（最初の1回だけ使う）
//           ↑ 現在の値（常に変化しうる）
```

<div class="info-box">
<h3>📝 初期値 vs 現在値</h3>
<table>
<tr><th>用語</th><th>意味</th><th>例</th></tr>
<tr><td><strong>初期値</strong></td><td>useState の引数。最初のレンダリング時だけ使う</td><td><code>useState(0)</code> の <code>0</code></td></tr>
<tr><td><strong>現在値</strong></td><td>今のstate。更新のたびに変わる</td><td><code>count</code>（0→1→2→...）</td></tr>
</table>
<p>💡 2回目以降のレンダリングでは、初期値 <code>0</code> は無視される</p>
</div>

### 関数型更新（prev）- 連続更新で必須！

<div class="warning-box">
<h3>⚠️ 連続で setState すると、期待通りに動かない？</h3>
<div class="box-content">

**問題のあるコード:**
```tsx
const [count, setCount] = useState(0);

function handleClick() {
  setCount(count + 1);  // count=0 なので 0+1=1
  setCount(count + 1);  // count=0 なので 0+1=1
  setCount(count + 1);  // count=0 なので 0+1=1
  // 結果: count は 1 になる（3じゃない！）
}
```

**なぜ？** `setCount` は非同期で、`count` はまだ古い値のまま

**解決: 関数型更新（prev）を使う**
```tsx
function handleClick() {
  setCount(prev => prev + 1);  // prev=0 → 1
  setCount(prev => prev + 1);  // prev=1 → 2
  setCount(prev => prev + 1);  // prev=2 → 3
  // 結果: count は 3 になる！✅
}
```

</div>
</div>

<div class="info-box">
<h3>🔑 prev の正体</h3>
<p><strong>prev は「過去の値」ではなく「更新直前の最新値」</strong></p>
<pre>
setCount(prev => prev + 1)
         ↑
         これは「更新が適用される直前の state」

時系列:
  1回目: prev=0 → 0+1=1 を返す → state=1
  2回目: prev=1 → 1+1=2 を返す → state=2
  3回目: prev=2 → 2+1=3 を返す → state=3
</pre>
<p><strong>いつ関数型を使う？</strong></p>
<ul>
<li>✅ 連続で更新するとき</li>
<li>✅ 現在の値を元に計算するとき</li>
<li>✅ 非同期処理の中で更新するとき</li>
</ul>
</div>

### 配列 state の更新（超重要！）

実際のアプリでは、配列（リスト）を state で管理することが多い。
**破壊的変更（push等）はNG！必ずコピーして新しい配列を作る**

<div class="architecture-box">
<h3>📦 配列 state の更新テンプレート</h3>

**セットアップ:**
```tsx
const [items, setItems] = useState([
  { id: 1, name: "りんご" },
  { id: 2, name: "バナナ" },
]);
```

**① 追加（末尾に追加）**
```tsx
const newItem = { id: 3, name: "みかん" };
setItems(prev => [...prev, newItem]);
// 結果: [りんご, バナナ, みかん]
```

**② 削除（特定のIDを削除）**
```tsx
setItems(prev => prev.filter(item => item.id !== 2));
// 結果: [りんご, みかん]  ← id:2 のバナナが消えた
```

**③ 更新（特定のアイテムを変更）**
```tsx
setItems(prev => prev.map(item =>
  item.id === 1
    ? { ...item, name: "青りんご" }  // id:1 だけ変更
    : item                           // それ以外はそのまま
));
// 結果: [青りんご, バナナ, みかん]
```

</div>

<div class="warning-box">
<h3>❌ やってはいけない（破壊的変更）</h3>
<div class="box-content">

```tsx
// ❌ NG: push は元の配列を変更する
items.push(newItem);
setItems(items);  // Reactは「同じ配列」と判断して再描画しない

// ❌ NG: 直接代入
items[0].name = "青りんご";
setItems(items);  // 同じく再描画されない
```

**なぜNG？**
Reactは「配列の参照（アドレス）」が変わったかで再描画を判断する。
`push` や直接代入は参照が同じままなので、Reactは変化に気づかない。

**✅ 正解: スプレッド構文で新しい配列を作る**
```tsx
setItems(prev => [...prev, newItem]);  // 新しい配列を作成
```

</div>
</div>

### オブジェクト state の更新

オブジェクト（連想配列/dict）も配列と同じ原則：**コピーして一部を変える**

<div class="architecture-box">
<h3>🔧 オブジェクト state の更新テンプレート</h3>

**セットアップ:**
```tsx
const [user, setUser] = useState({
  name: "太郎",
  age: 25,
  email: "taro@example.com"
});
```

**① 一部だけ更新**
```tsx
setUser(prev => ({
  ...prev,           // 既存のプロパティをコピー
  name: "花子"       // name だけ上書き
}));
// 結果: { name: "花子", age: 25, email: "taro@example.com" }
```

**② ネストしたオブジェクトの更新**
```tsx
const [user, setUser] = useState({
  name: "太郎",
  profile: {
    age: 25,
    city: "東京"
  }
});

// profile.age だけ更新
setUser(prev => ({
  ...prev,
  profile: {
    ...prev.profile,  // profile の中身もコピー
    age: 26           // age だけ上書き
  }
}));
```

</div>

<div class="warning-box">
<h3>❌ よくある間違い</h3>
<div class="box-content">

```tsx
// ❌ NG: 他のプロパティが消える
setUser({ name: "花子" });
// 結果: { name: "花子" }  ← age, email が消えた！

// ✅ OK: スプレッドで既存をコピー
setUser(prev => ({ ...prev, name: "花子" }));
// 結果: { name: "花子", age: 25, email: "taro@example.com" }
```

</div>
</div>

---

## 2.5 フォーム入力（controlled component）

フォームの入力欄を state で管理する方法。
設定画面や入力フォームで必須のパターン！

### 基本: テキスト入力

```tsx
function InputForm() {
  const [text, setText] = useState("");

  return (
    <div>
      <input
        type="text"
        value={text}                           // ① 表示は state が正
        onChange={(e) => setText(e.target.value)}  // ② 入力したら state 更新
      />
      <p>入力内容: {text}</p>
    </div>
  );
}
```

<div class="flow-box">
<h3>🔄 controlled component の動き</h3>
<pre>
ユーザーが「あ」と入力
    ↓
onChange 発火 → setText("あ")
    ↓
state が "あ" に更新
    ↓
React が再レンダリング
    ↓
input の value="あ" で表示
</pre>
<p><strong>ポイント:</strong> state が「唯一の情報源（Single Source of Truth）」</p>
</div>

### 実践例: TODOリストに追加

```tsx
function TodoApp() {
  const [text, setText] = useState("");
  const [todos, setTodos] = useState<string[]>([]);

  const handleAdd = () => {
    if (!text.trim()) return;  // 空文字は追加しない

    setTodos(prev => [...prev, text]);  // リストに追加
    setText("");                         // 入力欄をクリア
  };

  return (
    <div>
      <input
        value={text}
        onChange={(e) => setText(e.target.value)}
        placeholder="やることを入力"
      />
      <button onClick={handleAdd}>追加</button>

      <ul>
        {todos.map((todo, index) => (
          <li key={index}>{todo}</li>
        ))}
      </ul>
    </div>
  );
}
```

<div class="tip-box">
<h3>💡 フォームのポイントまとめ</h3>
<ul>
<li><strong>value={state}</strong>: 表示内容は state が決める</li>
<li><strong>onChange</strong>: 入力のたびに state を更新</li>
<li><strong>送信後は setText("")</strong>: 入力欄をクリア</li>
<li><strong>trim() でチェック</strong>: 空白だけの入力を防ぐ</li>
</ul>
</div>

---

## 3. useEffect - 副作用の処理

### useEffect とは？

「副作用（Side Effect）」を実行するための仕組み。
副作用 = 画面描画以外の処理（API呼び出し、イベント登録など）

```tsx
import { useState, useEffect } from 'react';

function UserProfile() {
  const [user, setUser] = useState(null);

  // ┌─────────────────────────────────────────────────────────────────┐
  // │ useEffect(処理, 依存配列)                                        │
  // │   処理: 実行したい関数                                            │
  // │   依存配列: この値が変わったら再実行                               │
  // └─────────────────────────────────────────────────────────────────┘
  useEffect(() => {
    // コンポーネントが表示されたときに実行
    fetchUser().then(data => setUser(data));
  }, []);  // [] = 最初の1回だけ実行

  return <div>{user?.name}</div>;
}
```

### 依存配列のパターン

```tsx
// パターン1: 最初の1回だけ実行
useEffect(() => {
  console.log("マウント時に1回だけ");
}, []);

// パターン2: 特定の値が変わったら実行
useEffect(() => {
  console.log("userId が変わったら実行");
  fetchUserData(userId);
}, [userId]);  // userId が変わるたびに実行

// パターン3: 毎回実行（非推奨）
useEffect(() => {
  console.log("毎レンダリングで実行");
});  // 依存配列なし = 毎回実行

// パターン4: クリーンアップ関数付き
useEffect(() => {
  const subscription = subscribeToData();

  // クリーンアップ: コンポーネントが消えるときに実行
  return () => {
    subscription.unsubscribe();
  };
}, []);
```

<div class="info-box">
<h3>🎯 useEffect のライフサイクル</h3>
<p>コンポーネントの一生:</p>
<pre>
[マウント] ─────→ [更新] ─────→ [更新] ─────→ [アンマウント]
    ↓                ↓            ↓                ↓
useEffect        依存配列の     依存配列の      クリーンアップ
実行             値が変わった   値が変わった      関数実行
                 ら再実行       ら再実行
</pre>
<ul>
<li><strong>マウント</strong> = 画面に表示されたとき</li>
<li><strong>アンマウント</strong> = 画面から消えたとき</li>
</ul>
</div>

---

## 4. カスタムフック - ロジックの再利用

### カスタムフックとは？

`use` で始まる関数。useState や useEffect を組み合わせて、
ロジックを再利用可能なパッケージにする。

```tsx
// カスタムフックを作る
function useCounter(initialValue = 0) {
  const [count, setCount] = useState(initialValue);

  const increment = () => setCount(count + 1);
  const decrement = () => setCount(count - 1);
  const reset = () => setCount(initialValue);

  return { count, increment, decrement, reset };
}

// 使う側A
function ComponentA() {
  const { count, increment } = useCounter(0);
  return <button onClick={increment}>{count}</button>;
}

// 使う側B
function ComponentB() {
  const { count, increment, reset } = useCounter(100);
  // ComponentA とは別の状態を持つ！
  return (
    <div>
      <span>{count}</span>
      <button onClick={increment}>+</button>
      <button onClick={reset}>リセット</button>
    </div>
  );
}
```

<div class="tip-box">
<h3>✨ カスタムフックのメリット</h3>
<ol>
<li><strong>ロジックの再利用</strong><br>同じ処理を複数のコンポーネントで使い回せる</li>
<li><strong>コンポーネントがスッキリ</strong><br>複雑なロジックをフックに分離 → コンポーネントは表示に専念</li>
<li><strong>テストしやすい</strong><br>UIなしでロジックだけテストできる</li>
</ol>
<p>⚠️ ルール:</p>
<ul>
<li>名前は必ず use で始める（例: useAuth, useChat）</li>
<li>フックはトップレベルでのみ呼び出す（if文の中はダメ）</li>
</ul>
</div>

---

## 5. App.tsx - アプリのメインコンポーネント

このアプリの「親玉」。全体の流れを管理します。

### 完全なコード（コメント付き）

```tsx
/**
 * App.tsx - フロントエンドのメインコンポーネント
 *
 * 役割:
 *   - 未ログイン → LoginScreen を表示
 *   - ログイン済 → ChatScreen を表示
 */
import { ChatScreen } from './components/ChatScreen'
import { LoginScreen } from './components/LoginScreen'
import { useAuth } from './hooks/useAuth'
import { useChat } from './hooks/useChat'
import { useSessions } from './hooks/useSessions'

/**
 * デバッグモード: 開発環境でのみ有効
 * - true: 認証をスキップしてチャット画面を表示（画面確認用）
 * - false: 通常の認証フローを使用
 */
const DEBUG_SHOW_CHAT = import.meta.env.DEV && import.meta.env.VITE_DEBUG_MODE === 'true'

function App() {
  // ───────────────────────────────────────────────────────────────
  // カスタムフックを使って状態を取得
  // ───────────────────────────────────────────────────────────────

  // 認証状態（ユーザー情報、ログイン関数など）
  const { user, loading, error: authError, loginWithGoogle, logout } = useAuth()

  // セッション管理（複数の会話を管理）
  const {
    sessions,              // セッション一覧
    activeSession,         // 現在選択中のセッション
    activeSessionId,       // 現在のセッションID
    createSession,         // 新規セッション作成
    switchSession,         // セッション切り替え
    closeSession,          // セッション削除
    updateSessionMessages, // メッセージ更新
  } = useSessions()

  // チャット状態（メッセージ、送信関数など）
  const { messages, isLoading, error: chatError, sendMessage } = useChat({
    activeSession,
    onMessagesUpdate: updateSessionMessages,
  })

  // ───────────────────────────────────────────────────────────────
  // 条件分岐で表示する画面を決定
  // ───────────────────────────────────────────────────────────────

  // ローディング中（認証状態の確認中）
  if (loading && !DEBUG_SHOW_CHAT) {
    return (
      <div className="loading-screen">
        <div className="spinner" />
        <p>読み込み中...</p>
      </div>
    )
  }

  // 未ログイン → ログイン画面を表示
  if (!user && !DEBUG_SHOW_CHAT) {
    return <LoginScreen onLogin={loginWithGoogle} error={authError} />
  }

  // ログイン済み → チャット画面を表示
  const displayUser = user || { email: 'demo@example.com', displayName: 'Demo User' }

  return (
    <ChatScreen
      user={displayUser}
      messages={messages}
      isLoading={isLoading}
      error={chatError}
      onSendMessage={sendMessage}
      onLogout={logout}
      sessions={sessions}
      activeSessionId={activeSessionId}
      onSelectSession={switchSession}
      onNewSession={createSession}
      onCloseSession={closeSession}
    />
  )
}

export default App
```

<div class="flow-box">
<h3>🔍 App.tsx の処理フロー</h3>
<pre>
┌────────────┐
│  App 起動   │
└─────┬──────┘
      │
      ▼
┌────────────┐     ┌─────────────────────────────────────────────────┐
│ loading?   │────▶│ ローディング画面表示（スピナー）                  │
│   true     │     └─────────────────────────────────────────────────┘
└─────┬──────┘
      │ false
      ▼
┌────────────┐     ┌─────────────────────────────────────────────────┐
│  user?     │────▶│ LoginScreen（ログイン画面）                       │
│   null     │     └─────────────────────────────────────────────────┘
└─────┬──────┘
      │ user あり
      ▼
┌────────────────────────────────────────────────────────────────────┐
│ ChatScreen（チャット画面）                                           │
│  - セッション一覧                                                    │
│  - メッセージ表示                                                    │
│  - 入力フォーム                                                      │
└────────────────────────────────────────────────────────────────────┘
</pre>
</div>

---

## 6. useAuth.ts - 認証フックの完全解説

### 完全なコード

```tsx
/**
 * 認証フック
 *
 * Firebase Authenticationの状態を管理します。
 */
import { useState, useEffect } from 'react'
import { User, signInWithPopup, signOut, onAuthStateChanged } from 'firebase/auth'
import { auth, googleProvider } from '../services/firebase'

export function useAuth() {
  // ───────────────────────────────────────────────────────────────
  // 状態の定義
  // ───────────────────────────────────────────────────────────────
  const [user, setUser] = useState<User | null>(null)      // ログイン中のユーザー
  const [loading, setLoading] = useState(true)              // 読み込み中フラグ
  const [error, setError] = useState<string | null>(null)   // エラーメッセージ

  // ───────────────────────────────────────────────────────────────
  // 認証状態の監視（重要！）
  // ───────────────────────────────────────────────────────────────
  useEffect(() => {
    // onAuthStateChanged: Firebaseの認証状態が変わったら呼ばれる
    // - ログインしたとき
    // - ログアウトしたとき
    // - ページリロード時（既存のログイン状態を復元）
    const unsubscribe = onAuthStateChanged(auth, (user) => {
      setUser(user)       // ユーザー情報をセット（null = 未ログイン）
      setLoading(false)   // 読み込み完了
    })

    // クリーンアップ: 監視を解除
    return unsubscribe
  }, [])

  // ───────────────────────────────────────────────────────────────
  // Googleでログイン
  // ───────────────────────────────────────────────────────────────
  const loginWithGoogle = async () => {
    setError(null)  // エラーをクリア
    try {
      // signInWithPopup: ポップアップでGoogleログイン画面を表示
      await signInWithPopup(auth, googleProvider)
      // ログイン成功 → onAuthStateChanged が自動で呼ばれる
    } catch (err) {
      setError('ログインに失敗しました')
      console.error(err)
    }
  }

  // ───────────────────────────────────────────────────────────────
  // ログアウト
  // ───────────────────────────────────────────────────────────────
  const logout = async () => {
    try {
      await signOut(auth)
      // ログアウト成功 → onAuthStateChanged が自動で呼ばれる
    } catch (err) {
      setError('ログアウトに失敗しました')
      console.error(err)
    }
  }

  // ───────────────────────────────────────────────────────────────
  // 戻り値
  // ───────────────────────────────────────────────────────────────
  return {
    user,                     // Userオブジェクト or null
    loading,                  // 認証確認中か
    error,                    // エラーメッセージ
    loginWithGoogle,          // ログイン関数
    logout,                   // ログアウト関数
    isLoggedIn: !!user,       // ログイン済みか（boolean）
  }
}
```

### onAuthStateChanged の仕組み

<div class="flow-box">
<h3>🔐 onAuthStateChanged の動作</h3>
<p><strong>【パターン1: ログイン】</strong></p>
<pre>
[ユーザー] ──▶ [Googleログイン] ──▶ [Firebase]
                                        │
                                        ▼
[useAuth] ◀── onAuthStateChanged(user) ─┘
    │
    ▼
setUser(user) → 画面更新
</pre>
<p><strong>【パターン2: ページリロード】</strong></p>
<pre>
[ブラウザ] ──▶ [ページ読み込み]
                   │
                   ▼
[Firebase] ── ローカルストレージから認証情報を復元
    │
    ▼
[useAuth] ◀── onAuthStateChanged(user)
    │
    ▼
自動的にログイン状態が復元！
</pre>
<p><strong>【ポイント】</strong><br>
Firebase が認証状態を localStorage に保存してくれる<br>
→ ページを閉じても、再訪問時に自動ログイン！</p>
</div>

---

## 7. useChat.ts - チャットフックの完全解説

### 完全なコード

```tsx
/**
 * チャットフック
 *
 * AIエージェントとの会話を管理します。
 * セッション管理フックと連携して動作します。
 */
import { useState, useCallback, useEffect } from 'react'
import { sendChatMessage } from '../services/api'
import type { ChatSession } from './useSessions'

/**
 * ユニークなIDを生成
 * crypto.randomUUID()を使用して衝突のないIDを生成
 */
function generateUniqueId(): string {
  return crypto.randomUUID()
}

// メッセージの型
export interface Message {
  id: string                    // ユニークなID
  role: 'user' | 'assistant'    // 誰のメッセージか
  content: string               // メッセージ内容
}

interface UseChatOptions {
  activeSession: ChatSession | null
  onMessagesUpdate: (sessionId: string, messages: Message[], threadId: string | null) => void
}

export function useChat(options?: UseChatOptions) {
  const { activeSession, onMessagesUpdate } = options || {}

  // ───────────────────────────────────────────────────────────────
  // 状態の定義
  // ───────────────────────────────────────────────────────────────
  const [messages, setMessages] = useState<Message[]>(activeSession?.messages || [])
  const [threadId, setThreadId] = useState<string | null>(activeSession?.threadId || null)
  const [isLoading, setIsLoading] = useState(false)
  const [error, setError] = useState<string | null>(null)

  // ───────────────────────────────────────────────────────────────
  // アクティブセッションが変更されたらメッセージを復元
  // ───────────────────────────────────────────────────────────────
  useEffect(() => {
    if (activeSession) {
      setMessages(activeSession.messages)
      setThreadId(activeSession.threadId)
      setError(null)
    }
  }, [activeSession?.id])  // セッションIDが変わったら実行

  // ───────────────────────────────────────────────────────────────
  // メッセージを送信
  // ───────────────────────────────────────────────────────────────
  const sendMessage = useCallback(async (content: string) => {
    // 空メッセージや送信中は無視
    if (!content.trim() || isLoading) return

    setError(null)
    setIsLoading(true)

    // ─────────────────────────────────────────────────────────────
    // Step 1: ユーザーメッセージを追加
    // ─────────────────────────────────────────────────────────────
    const userMessage: Message = {
      id: generateUniqueId(),
      role: 'user',
      content,
    }

    const updatedMessagesWithUser = [...messages, userMessage]
    setMessages(updatedMessagesWithUser)

    // ─────────────────────────────────────────────────────────────
    // Step 2: AIの応答用プレースホルダーを追加
    // ─────────────────────────────────────────────────────────────
    const assistantMessageId = generateUniqueId()
    const assistantMessage: Message = {
      id: assistantMessageId,
      role: 'assistant',
      content: '',  // 最初は空
    }

    const updatedMessagesWithAssistant = [...updatedMessagesWithUser, assistantMessage]
    setMessages(updatedMessagesWithAssistant)

    // ─────────────────────────────────────────────────────────────
    // Step 3: ストリーミングでメッセージを受信
    // ─────────────────────────────────────────────────────────────
    try {
      let currentContent = ''

      const newThreadId = await sendChatMessage(
        content,
        threadId,
        (chunk) => {
          // チャンク（断片）を受信するたびに呼ばれる
          currentContent += chunk

          // メッセージを更新（リアルタイム表示！）
          setMessages(prev =>
            prev.map(msg =>
              msg.id === assistantMessageId
                ? { ...msg, content: currentContent }
                : msg
            )
          )
        }
      )

      setThreadId(newThreadId)

      // セッションにメッセージを保存
      if (activeSession && onMessagesUpdate) {
        const finalMessages = updatedMessagesWithUser.concat({
          ...assistantMessage,
          content: currentContent,
        })
        onMessagesUpdate(activeSession.id, finalMessages, newThreadId)
      }
    } catch (err) {
      // ─────────────────────────────────────────────────────────
      // エラー処理
      // ─────────────────────────────────────────────────────────
      const errorMessage = err instanceof Error ? err.message : 'エラーが発生しました'
      setError(errorMessage)

      // 失敗したメッセージを削除
      setMessages(prev => prev.filter(msg => msg.id !== assistantMessageId))

      // セッションにはユーザーメッセージまで保存
      if (activeSession && onMessagesUpdate) {
        onMessagesUpdate(activeSession.id, updatedMessagesWithUser, threadId)
      }
    } finally {
      setIsLoading(false)
    }
  }, [threadId, isLoading, messages, activeSession, onMessagesUpdate])

  // ───────────────────────────────────────────────────────────────
  // 会話をリセット
  // ───────────────────────────────────────────────────────────────
  const resetChat = useCallback(() => {
    setMessages([])
    setThreadId(null)
    setError(null)
  }, [])

  return {
    messages,      // メッセージ一覧
    isLoading,     // 送信中か
    error,         // エラーメッセージ
    sendMessage,   // 送信関数
    resetChat,     // リセット関数
    threadId,      // スレッドID
  }
}
```

### useCallback とは？

<div class="info-box">
<h3>🔄 useCallback の役割</h3>
<p><strong>問題:</strong><br>
React は再レンダリングのたびに関数を新しく作り直す<br>
→ 子コンポーネントに渡すと、毎回「新しい関数」と判断される<br>
→ 不要な再レンダリングが発生</p>
<p><strong>解決:</strong><br>
useCallback で関数をメモ化（キャッシュ）<br>
→ 依存配列の値が変わらない限り、同じ関数を再利用</p>
<pre>
const sendMessage = useCallback(async (content) => {
  // 処理
}, [threadId, isLoading, ...]);  // この値が変わったら新しい関数を作る
</pre>
<p>💡 パフォーマンス最適化のため。なくても動くが、あると効率的。</p>
</div>

### ストリーミング表示の仕組み

<div class="flow-box">
<h3>📡 ストリーミング表示</h3>
<pre>
[フロントエンド]                        [バックエンド]

sendMessage("こんにちは") ──────────────▶

content = ""              ◀───────────── "こ"
content = "こ"            ◀───────────── "ん"
content = "こん"          ◀───────────── "に"
content = "こんに"        ◀───────────── "ち"
content = "こんにち"      ◀───────────── "は"
content = "こんにちは"    ◀───────────── "！"
content = "こんにちは！"  ◀───────────── [DONE]
</pre>
<p><strong>画面:</strong><br>
「こ」→「こん」→「こんに」→「こんにち」→「こんにちは」→「こんにちは！」</p>
<p>💡 onChunk コールバックで setMessages を呼ぶ<br>
→ 毎回画面が更新される<br>
→ ユーザーはリアルタイムで文字が増えていくのを見れる！</p>
</div>

---

## 8. useSessions.ts - セッション管理の完全解説

複数の会話を管理する仕組みです。

### 主な機能

| 機能 | 説明 |
|------|------|
| セッション作成 | 新しい会話を開始 |
| セッション切り替え | 過去の会話に戻る |
| セッション削除 | 不要な会話を削除 |
| 自動保存 | ローカルストレージに保存 |
| タイトル自動生成 | 最初のメッセージからタイトルを作成 |

### 完全なコード

```tsx
/**
 * セッション管理フック
 *
 * 複数のチャットセッションを管理し、ローカルストレージに永続化します。
 *
 * 【制限事項】
 * - 最大10セッションまで保存（容量制限のため）
 * - ブラウザのローカルストレージに保存（デバイス間同期なし）
 */
import { useState, useCallback, useEffect } from 'react'
import type { Message } from './useChat'

/** ローカルストレージのキー */
const STORAGE_KEY = 'chat_sessions'

/**
 * 最大セッション数
 * - ローカルストレージの容量制限（5-10MB）を考慮
 * - 1セッション約8KB（20メッセージ想定）× 10 = 約80KB
 */
const MAX_SESSIONS = 10

/** デフォルトのセッションタイトル */
const DEFAULT_SESSION_TITLE = '新しい会話'

/**
 * チャットセッションの型定義
 */
export interface ChatSession {
  id: string            // 一意のセッションID
  title: string         // セッションのタイトル
  messages: Message[]   // メッセージ履歴
  threadId: string | null  // バックエンドとの会話スレッドID
  createdAt: number     // 作成日時（Unix timestamp）
  updatedAt: number     // 最終更新日時
}

/**
 * セッションIDを生成
 * 形式: session_{timestamp}_{ランダム文字列}
 */
function generateSessionId(): string {
  return `session_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
}

/**
 * 新しい空のセッションを作成
 */
function createNewSession(): ChatSession {
  return {
    id: generateSessionId(),
    title: DEFAULT_SESSION_TITLE,
    messages: [],
    threadId: null,
    createdAt: Date.now(),
    updatedAt: Date.now(),
  }
}

/**
 * ローカルストレージからセッション一覧を読み込み
 */
function loadSessionsFromStorage(): ChatSession[] {
  try {
    const stored = localStorage.getItem(STORAGE_KEY)
    if (stored) {
      return JSON.parse(stored)
    }
  } catch {
    // エラー時は空配列を返す（データ破損時の安全対策）
  }
  return []
}

/**
 * セッション一覧をローカルストレージに保存
 */
function saveSessionsToStorage(sessions: ChatSession[]): void {
  try {
    localStorage.setItem(STORAGE_KEY, JSON.stringify(sessions))
  } catch {
    // 容量超過などのエラーは握りつぶす
  }
}

/**
 * メッセージ内容からタイトルを生成
 * - 最大20文字まで
 * - 改行はスペースに変換
 */
function generateTitleFromMessage(content: string): string {
  const maxLength = 20
  const trimmed = content.trim().replace(/\n/g, ' ')
  if (trimmed.length <= maxLength) {
    return trimmed
  }
  return trimmed.substring(0, maxLength) + '...'
}

/**
 * セッション管理フック
 */
export function useSessions() {
  // ───────────────────────────────────────────────────────────────
  // セッション一覧
  // useState の初期化関数を使用（初回のみ実行）
  // ───────────────────────────────────────────────────────────────
  const [sessions, setSessions] = useState<ChatSession[]>(() => {
    const loaded = loadSessionsFromStorage()
    return loaded.length === 0 ? [createNewSession()] : loaded
  })

  // アクティブなセッションのID
  const [activeSessionId, setActiveSessionId] = useState<string>(
    () => sessions[0]?.id || ''
  )

  // ───────────────────────────────────────────────────────────────
  // セッション変更時に自動保存
  // ───────────────────────────────────────────────────────────────
  useEffect(() => {
    saveSessionsToStorage(sessions)
  }, [sessions])

  // 現在アクティブなセッション
  const activeSession = sessions.find(s => s.id === activeSessionId) || sessions[0]

  // ───────────────────────────────────────────────────────────────
  // 新しいセッションを作成
  // ───────────────────────────────────────────────────────────────
  const createSession = useCallback(() => {
    const newSession = createNewSession()
    setSessions(prev => {
      const updated = [newSession, ...prev]  // 先頭に追加
      // 最大数を超えたら古いものを削除
      if (updated.length > MAX_SESSIONS) {
        return updated.slice(0, MAX_SESSIONS)
      }
      return updated
    })
    setActiveSessionId(newSession.id)
    return newSession.id
  }, [])

  // ───────────────────────────────────────────────────────────────
  // セッションを切り替え
  // ───────────────────────────────────────────────────────────────
  const switchSession = useCallback((sessionId: string) => {
    setActiveSessionId(sessionId)
  }, [])

  // ───────────────────────────────────────────────────────────────
  // セッションを削除
  // ───────────────────────────────────────────────────────────────
  const closeSession = useCallback((sessionId: string) => {
    setSessions(prev => {
      const remainingSessions = prev.filter(s => s.id !== sessionId)

      // 全て削除された場合は新しいセッションを作成
      if (remainingSessions.length === 0) {
        const newSession = createNewSession()
        setActiveSessionId(newSession.id)
        return [newSession]
      }

      // 削除されたのがアクティブセッションだった場合
      if (sessionId === activeSessionId) {
        const deletedIndex = prev.findIndex(s => s.id === sessionId)
        const nextIndex = Math.min(deletedIndex, remainingSessions.length - 1)
        setActiveSessionId(remainingSessions[nextIndex].id)
      }

      return remainingSessions
    })
  }, [activeSessionId])

  // ───────────────────────────────────────────────────────────────
  // セッションのメッセージを更新
  // ───────────────────────────────────────────────────────────────
  const updateSessionMessages = useCallback((
    sessionId: string,
    messages: Message[],
    threadId: string | null
  ) => {
    setSessions(prev => prev.map(session => {
      if (session.id !== sessionId) return session

      // タイトル自動生成（まだ「新しい会話」の場合のみ）
      let title = session.title
      if (title === DEFAULT_SESSION_TITLE && messages.length > 0) {
        const firstUserMessage = messages.find(m => m.role === 'user')
        if (firstUserMessage) {
          title = generateTitleFromMessage(firstUserMessage.content)
        }
      }

      return {
        ...session,
        messages,
        threadId,
        title,
        updatedAt: Date.now(),
      }
    }))
  }, [])

  return {
    sessions,              // セッション一覧
    activeSession,         // 現在のセッション
    activeSessionId,       // 現在のセッションID
    createSession,         // 新規作成
    switchSession,         // 切り替え
    closeSession,          // 削除
    updateSessionMessages, // メッセージ更新
  }
}
```

### ローカルストレージの仕組み

<div class="info-box">
<h3>💾 ローカルストレージ</h3>
<p>ブラウザに内蔵された「簡易データベース」</p>
<pre>
┌─────────────────────────────────────────────────────────────────────┐
│  localStorage                                                        │
│  ┌────────────────┬──────────────────────────────────────────────┐  │
│  │  キー           │  値                                          │  │
│  ├────────────────┼──────────────────────────────────────────────┤  │
│  │ chat_sessions   │ [{"id":"session_123","title":"天気について",│  │
│  │                 │   "messages":[...]}, {...}]                 │  │
│  └────────────────┴──────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────────┘
</pre>
<p><strong>【特徴】</strong></p>
<ul>
<li>✅ ブラウザを閉じてもデータが残る</li>
<li>✅ 約 5-10MB まで保存可能</li>
<li>❌ 他のデバイスとは同期されない</li>
<li>❌ ブラウザのデータ削除で消える</li>
</ul>
<p><strong>【使い方】</strong></p>
<pre>
localStorage.setItem('key', 'value')  // 保存
localStorage.getItem('key')           // 取得
localStorage.removeItem('key')        // 削除
</pre>
<p>⚠️ 注意: 文字列しか保存できない<br>
→ オブジェクトは JSON.stringify() で文字列に変換<br>
→ 取得時は JSON.parse() でオブジェクトに戻す</p>
</div>

---

## 9. api.ts - API通信の完全解説

バックエンドとの通信を担当するモジュールです。

### 完全なコード

```tsx
/**
 * API通信モジュール
 *
 * バックエンドAPIとの通信を行います。
 */
import { auth } from './firebase'

// APIベースURL（環境変数から取得）
const API_BASE_URL = import.meta.env.VITE_API_BASE_URL || 'http://localhost:8080'

/**
 * 認証トークンを取得
 *
 * Firebase からIDトークンを取得する。
 * このトークンがバックエンドへの「認証の証」になる。
 */
async function getAuthToken(): Promise<string> {
  const user = auth.currentUser
  if (!user) {
    throw new Error('ログインが必要です')
  }
  return user.getIdToken()
}

/**
 * 認証ヘッダーを生成
 *
 * HTTP リクエストに付加するヘッダーを作成。
 * Bearer トークン形式で認証情報を送る。
 */
async function createAuthHeaders(): Promise<HeadersInit> {
  const token = await getAuthToken()
  return {
    'Content-Type': 'application/json',
    'Authorization': `Bearer ${token}`,  // これが認証の証！
  }
}

/**
 * チャットメッセージを送信（ストリーミング）
 *
 * @param message ユーザーのメッセージ
 * @param threadId スレッドID（省略可）
 * @param onChunk チャンク受信時のコールバック
 * @returns スレッドID
 */
export async function sendChatMessage(
  message: string,
  threadId: string | null,
  onChunk: (chunk: string) => void
): Promise<string> {
  // ─────────────────────────────────────────────────────────────
  // Step 1: 認証ヘッダーを作成
  // ─────────────────────────────────────────────────────────────
  const headers = await createAuthHeaders()

  // ─────────────────────────────────────────────────────────────
  // Step 2: APIにPOSTリクエスト
  // ─────────────────────────────────────────────────────────────
  const response = await fetch(`${API_BASE_URL}/chat`, {
    method: 'POST',
    headers,
    body: JSON.stringify({
      message,
      thread_id: threadId,
    }),
  })

  // ─────────────────────────────────────────────────────────────
  // Step 3: エラーチェック
  // ─────────────────────────────────────────────────────────────
  if (!response.ok) {
    const error = await response.json()
    throw new Error(error.error || 'エラーが発生しました')
  }

  // ─────────────────────────────────────────────────────────────
  // Step 4: レスポンスヘッダーからスレッドIDを取得
  // ─────────────────────────────────────────────────────────────
  const newThreadId = response.headers.get('X-Thread-Id') || threadId || ''

  // ─────────────────────────────────────────────────────────────
  // Step 5: Server-Sent Events を処理
  // ─────────────────────────────────────────────────────────────
  const reader = response.body?.getReader()
  // stream: true で日本語の文字化けを防止
  const decoder = new TextDecoder()

  if (!reader) {
    throw new Error('レスポンスの読み取りに失敗しました')
  }

  // ─────────────────────────────────────────────────────────────
  // Step 6: チャンクを読み続ける
  // ─────────────────────────────────────────────────────────────
  while (true) {
    const { done, value } = await reader.read()
    if (done) break

    // バイナリ → テキストに変換
    const text = decoder.decode(value, { stream: true })
    const lines = text.split('\n')

    // 各行を処理
    for (const line of lines) {
      if (line.startsWith('data: ')) {
        const data = line.slice(6)  // "data: " を除去
        if (data === '[DONE]') {
          break
        }
        if (data.startsWith('[ERROR]')) {
          throw new Error(data.slice(8))
        }
        onChunk(data)  // コールバック関数を呼ぶ
      }
    }
  }

  return newThreadId
}
```

### SSE（Server-Sent Events）の仕組み

<div class="info-box">
<h3>📡 Server-Sent Events (SSE)</h3>
<p><strong>【普通のHTTP通信】</strong></p>
<pre>
[クライアント] ────リクエスト────▶ [サーバー]
                                     │
               （3秒待ち...）        │
                                     ▼
[クライアント] ◀───レスポンス（全部）── [サーバー]
</pre>
<p><strong>【SSE】</strong></p>
<pre>
[クライアント] ────リクエスト────▶ [サーバー]
[クライアント] ◀───"data: こ"───── [サーバー]
[クライアント] ◀───"data: ん"───── [サーバー]
[クライアント] ◀───"data: に"───── [サーバー]
[クライアント] ◀───"data: ち"───── [サーバー]
[クライアント] ◀───"data: は"───── [サーバー]
[クライアント] ◀───"data: [DONE]"─ [サーバー]
</pre>
<p>→ リアルタイムで画面に文字が表示される！</p>
<p><strong>【SSEのデータ形式】</strong></p>
<pre>
data: 文字列\n
data: 文字列\n
data: [DONE]\n
</pre>
<p>各行が "data: " で始まる<br>
最後は "[DONE]" で終了を知らせる</p>
</div>

### TextDecoder の重要性

```tsx
// stream: true がないと日本語が文字化けする！

// 悪い例
const text = decoder.decode(value);  // ❌ 日本語が化ける可能性

// 良い例
const text = decoder.decode(value, { stream: true });  // ✅ 正しく処理

// なぜ？
// UTF-8では日本語1文字 = 3バイト
// チャンクの境界で分断されると...
// 例: "日" = [E6, 97, A5]
//     チャンク1: [E6, 97]  ← 不完全！
//     チャンク2: [A5, ...]
// stream: true で不完全なバイトをバッファリングしてくれる
```

---

## 10. firebase.ts - Firebase初期化

Firebase SDKの初期化を行うファイルです。

### 完全なコード

```tsx
/**
 * Firebase初期化
 *
 * 【設定方法】
 * .envファイルに以下の環境変数を設定してください:
 * - VITE_FIREBASE_API_KEY
 * - VITE_FIREBASE_AUTH_DOMAIN
 * - VITE_FIREBASE_PROJECT_ID
 */
import { initializeApp } from 'firebase/app'
import { getAuth, GoogleAuthProvider } from 'firebase/auth'

// Firebase設定（環境変数から取得）
const firebaseConfig = {
  apiKey: import.meta.env.VITE_FIREBASE_API_KEY,
  authDomain: import.meta.env.VITE_FIREBASE_AUTH_DOMAIN,
  projectId: import.meta.env.VITE_FIREBASE_PROJECT_ID,
}

// Firebase初期化
const app = initializeApp(firebaseConfig)

// 認証インスタンス
export const auth = getAuth(app)

// Googleログインプロバイダ
export const googleProvider = new GoogleAuthProvider()
```

### 環境変数について

<div class="info-box">
<h3>🔐 環境変数と Vite</h3>
<p><strong>【.envファイル】</strong></p>
<pre>
frontend/.env
┌─────────────────────────────────────────────────────────────────────┐
│ VITE_FIREBASE_API_KEY=AIza...                                        │
│ VITE_FIREBASE_AUTH_DOMAIN=your-project.firebaseapp.com              │
│ VITE_FIREBASE_PROJECT_ID=your-project-id                            │
│ VITE_API_BASE_URL=https://your-api.run.app                          │
└─────────────────────────────────────────────────────────────────────┘
</pre>
<p><strong>【Viteでの環境変数のルール】</strong></p>
<ul>
<li>✅ VITE_ で始まる変数だけがフロントエンドで使える</li>
<li>✅ import.meta.env.VITE_XXX でアクセス</li>
<li>❌ VITE_ がない変数はフロントエンドからアクセスできない（セキュリティ）</li>
</ul>
<p><strong>【なぜ環境変数を使う？】</strong></p>
<ol>
<li>秘密情報をコードに直書きしない</li>
<li>開発/本番で設定を切り替えやすい</li>
<li>.gitignore で .env を除外 → Gitに秘密情報が入らない</li>
</ol>
<p>⚠️ 注意: フロントエンドの環境変数は結局ブラウザに送られる<br>
→ 本当の秘密（APIキーなど）はバックエンドに置く</p>
</div>

---

## 11. TypeScriptの型システム

TypeScriptはJavaScriptに「型」を追加した言語です。
間違いを事前に防げる！

### 基本的な型

```tsx
// プリミティブ型
const name: string = "太郎";
const age: number = 25;
const isActive: boolean = true;

// 配列
const numbers: number[] = [1, 2, 3];
const names: string[] = ["Alice", "Bob"];

// オブジェクト型
type User = {
  id: string;
  name: string;
  email: string;
};

const user: User = {
  id: "1",
  name: "太郎",
  email: "taro@example.com",
};

// user.age = 25;  // ❌ エラー！User型にageはない
```

### interface と type

```tsx
// interface: オブジェクトの形を定義
interface Message {
  id: string;
  role: 'user' | 'assistant';  // リテラル型（この2つだけ許可）
  content: string;
}

// type: 任意の型を定義
type MessageRole = 'user' | 'assistant';

// どちらを使う？
// → 基本的にどちらでもOK
// → オブジェクトは interface が一般的
// → 複雑な型や Union は type が便利
```

### Union型とOptional

```tsx
// Union型: 複数の型のどれか
type Status = 'loading' | 'success' | 'error';

let status: Status = 'loading';
status = 'success';  // ✅ OK
// status = 'pending';  // ❌ エラー！

// Optional（省略可能）
interface User {
  id: string;
  name: string;
  email?: string;  // ? で省略可能に
}

const user1: User = { id: "1", name: "太郎" };  // ✅ emailなしでもOK
const user2: User = { id: "2", name: "花子", email: "hanako@example.com" };  // ✅
```

### ジェネリクス

```tsx
// ジェネリクス: 型を引数のように渡せる
function useState<T>(initialValue: T): [T, (value: T) => void] {
  // ...
}

// 使うとき
const [count, setCount] = useState<number>(0);
const [name, setName] = useState<string>("太郎");
const [user, setUser] = useState<User | null>(null);

// <T> は「型引数」
// 呼び出し側が具体的な型を指定できる
```

<div class="tip-box">
<h3>💡 TypeScript のメリット</h3>
<ol>
<li><strong>補完が効く</strong><br>user. と打つと id, name, email が候補に出る！</li>
<li><strong>間違いを事前に発見</strong><br>message.rolr と打つとエラー（role のtypo）</li>
<li><strong>リファクタリングが安全</strong><br>関数名や型を変えると、影響箇所が全て分かる</li>
<li><strong>ドキュメント代わり</strong><br>型定義を見れば、何が必要か分かる</li>
</ol>
<p>⚠️ 注意: 実行時には型情報は消える<br>
→ 実行時エラーは防げない（あくまで開発時のチェック）</p>
</div>

---

## 12. 全体の処理フロー

すべてのコードがどう連携するか、全体像を把握しましょう。

<div class="flow-box">
<h3>🔄 チャット送信の完全フロー</h3>
<pre>
[ユーザー] メッセージ入力
    │
    ▼
[ChatScreen] onSendMessage(text) 呼び出し
    │
    ▼
[useChat] sendMessage(content)
    │
    ├── setMessages([...messages, userMessage])  ← ユーザーメッセージ追加
    │
    ├── setMessages([..., assistantMessage])  ← 空のAIメッセージ追加
    │
    ▼
[api.ts] sendChatMessage(content, threadId, onChunk)
    │
    ├── getAuthToken()  ← IDトークン取得
    │
    ├── fetch('/chat', { headers: { Authorization: 'Bearer ...' } })
    │
    ▼
[バックエンド] ─────────────────────────────────────────────────
    │  ・トークン検証
    │  ・AI に問い合わせ
    │  ・ストリーミングで返答
────┴───────────────────────────────────────────────────────────
    │
    ▼
[api.ts] reader.read() でチャンクを受信
    │
    ├── onChunk("こ") → setMessages 更新
    ├── onChunk("ん") → setMessages 更新
    ├── onChunk("に") → setMessages 更新
    ├── ...
    ├── onChunk("[DONE]") → 終了
    │
    ▼
[useChat] → [useSessions] updateSessionMessages()
    │
    ▼
[useSessions] → localStorage に保存
</pre>
</div>

---

## まとめ

<div class="summary-box">
<h3>🎓 この章で学んだこと</h3>
<table>
<tr><th>概念</th><th>ポイント</th></tr>
<tr><td>コンポーネント</td><td>画面のパーツ。組み合わせてUIを作る</td></tr>
<tr><td>useState</td><td>状態を持つ。変更すると再描画される</td></tr>
<tr><td>useEffect</td><td>副作用を実行。マウント時やデータ変更時に処理</td></tr>
<tr><td>カスタムフック</td><td>ロジックを再利用。useAuth, useChatなど</td></tr>
<tr><td>TypeScript</td><td>型で安全に。間違いを事前に防ぐ</td></tr>
<tr><td>SSE</td><td>リアルタイムでデータを受け取る</td></tr>
</table>
<ul>
<li>✅ useAuth: Firebase認証の状態管理</li>
<li>✅ useChat: メッセージ送受信とストリーミング処理</li>
<li>✅ useSessions: 複数会話のローカル保存</li>
<li>✅ api.ts: バックエンドとのHTTP通信</li>
</ul>
</div>

---

## 次に読むべきドキュメント

| 順番 | ドキュメント | 内容 |
|------|-------------|------|
| 1 | [05_セットアップの流れ.md](./05_セットアップの流れ.md) | 環境構築の手順 |
| 2 | [11_チャット送信の流れ.md](./11_チャット送信の流れ.md) | 詳細なデータフロー |
| 3 | [12_ログインの流れ.md](./12_ログインの流れ.md) | 認証フローの詳細 |

---

## 練習問題

### Q1: useState について

```tsx
const [count, setCount] = useState(0);

// 以下のコードで count は何になる？
setCount(count + 1);
setCount(count + 1);
setCount(count + 1);

// A. 3
// B. 1
// C. 0
```

<details>
<summary>答えを見る</summary>

**答え: B. 1**

理由: setCount は非同期的に更新されるため、3回呼んでも全て `0 + 1 = 1` になる。

連続して加算したい場合は:
```tsx
setCount(prev => prev + 1);
setCount(prev => prev + 1);
setCount(prev => prev + 1);
// → 3 になる
```

</details>

### Q2: useEffect の依存配列

```tsx
useEffect(() => {
  console.log("実行されました");
}, [userId]);
```

このコードはいつ実行される？

<details>
<summary>答えを見る</summary>

**答え:**
1. コンポーネントが最初に表示されたとき（マウント時）
2. `userId` の値が変わったとき

`userId` が同じ値のままなら、再レンダリングしても実行されない。

</details>

### Q3: TypeScript の型エラー

```tsx
interface User {
  id: string;
  name: string;
}

const user: User = {
  id: 1,
  name: "太郎",
};
```

このコードにはエラーがあります。何が問題？

<details>
<summary>答えを見る</summary>

**答え:** `id` の型が違う

`id` は `string` 型として定義されているが、`1`（number）を渡している。

正しくは:
```tsx
const user: User = {
  id: "1",  // 文字列にする
  name: "太郎",
};
```

</details>
