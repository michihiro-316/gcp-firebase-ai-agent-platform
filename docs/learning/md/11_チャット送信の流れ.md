# チャット送信の流れ - 完全解説

**このドキュメントの目的**：
「チャットを送信したら何が起きるか」を、**実際のコード**と**繋がり**を見ながら理解する。

**想定読者**: GASを少し触ったことがある新卒エンジニア

**読了時間**: 約45分

---

## まず知っておくべきこと

### 同期通信とは？

<div class="flow-box">
<h3>📡 同期通信の仕組み</h3>
<p><strong>【同期通信】</strong></p>
<pre>
質問 ───────────────────────────────→ サーバー
                                        ↓ AIが回答を生成
        「AIが考え中...」と表示          ↓
                                        ↓
「こんにちは、今日は良い天気ですね！」 ←─────────────────
                                        （一括で返す）
</pre>
<p>→ 処理中は「AIが考え中...」が表示され、完了したら一括で回答が表示される</p>
</div>

### async/await とは？（GAS経験者向け）

```javascript
// GASの場合（同期処理）
function myFunction() {
  const response = UrlFetchApp.fetch('https://...');  // ここで待つ
  const data = response.getContentText();  // 終わってから次へ
}

// TypeScript/Pythonの場合（非同期処理）
async function myFunction() {
  const response = await fetch('https://...');  // awaitで「待つ」と明示
  const data = await response.json();
}
```

**ポイント**: `await` は「この処理が終わるまで待って」という意味。
GASでは自動で待っていたが、TypeScript/Pythonでは `await` を書く必要がある。

---

## 全体フロー図

<div class="architecture-box">
<h3>🔄 チャット送信の全体フロー</h3>
<pre>
【ブラウザ】                     【サーバー】                    【外部サービス】

1. 入力ボックスに
   「こんにちは」と入力
        ↓
2. 送信ボタンをクリック
        ↓
   ┌─────────────────┐
   │  useChat.ts     │  ← 「チャットのロジック担当」
   │  sendMessage()  │
   └────────┬────────┘
            ↓
   ┌─────────────────┐
   │  api.ts         │  ← 「サーバーとの通信担当」
   │  sendChatMessage()
   │  + IDトークン取得 │─────────────→ Firebase Auth
   └────────┬────────┘               (トークン発行)
            ↓
   ┌─────────────────┐
   │ Authorization:  │  ← 「私は〇〇です」という証明書
   │ Bearer xxxx     │
   └────────┬────────┘
            ↓
════════════════════════ インターネット ════════════════════════
            ↓
   ┌─────────────────┐
   │  Gateway        │  ← 「認証・振り分け担当」（1つだけ）
   │  main.py        │
   │  ・トークン検証   │──────────────→ Firebase Admin SDK
   │  ・customer_id取得│               (本人確認)
   │  ・転送先URL取得  │──────────────→ Firestore (customers)
   └────────┬────────┘
            ↓ 内部ヘッダー付与
              X-Gateway-Verified: true
              X-User-Id: xxx
              X-Customer-Id: xxx
            ↓
   ┌─────────────────┐
   │  Backend        │  ← 「会社ごとのバックエンド」
   │  main.py        │
   │  /chat          │
   └────────┬────────┘
            ↓
   ┌─────────────────┐
   │  agent.py       │  ← 「AI担当」
   │  AIに質問       │──────────────→ Vertex AI (Gemini)
   └────────┬────────┘               (応答生成)
            ↓
   ┌─────────────────┐
   │ checkpointer.py │  ← 「記録担当」
   │  会話履歴保存    │──────────────→ Firestore
   └────────┬────────┘               (データ保存)
            ↓
════════════════════════ インターネット ════════════════════════
            ↓
3. 「AIが考え中...」表示後
   回答が一括で表示される
</pre>
</div>

**それぞれのファイルの役割**:
| ファイル | 役割 | 例えると |
|----------|------|----------|
| useChat.ts | チャット画面の状態管理 | メモ帳 |
| api.ts | サーバーとの通信 | 電話 |
| Gateway main.py | 認証・振り分け | ホテルのフロント（どの部屋に案内するか） |
| Backend main.py | リクエストの受付 | 各部屋の係員 |
| agent.py | AI処理 | 相談員 |
| checkpointer.py | 履歴保存 | 書記 |

---

## ステップ1: ユーザーがメッセージを送信

### なぜこのファイルがあるのか？

**問題**: チャット画面のボタンやテキストボックスに、送信ロジックを直接書くと...
- コードが長くなる
- 他の画面で再利用できない
- テストしにくい

**解決**: ロジックを「フック（Hook）」として分離する

### 場所: `src/frontend/src/hooks/useChat.ts`

```typescript
// useChat.ts の sendMessage 関数（簡略版）

const sendMessage = useCallback(async (content: string) => {
  // ====================================
  // 【この関数の役割】
  // 1. ユーザーのメッセージを画面に表示
  // 2. サーバーにメッセージを送信
  // 3. AIの返答を受け取って表示
  // ====================================

  if (!content.trim() || isLoading) return  // 空文字や連打を防止

  setIsLoading(true)  // ← 「AIが考え中...」状態にする

  // ユーザーのメッセージを画面に追加
  const userMessage = { id: '...', role: 'user', content }
  const updatedMessagesWithUser = [...messages, userMessage]
  setMessages(updatedMessagesWithUser)

  try {
    // ★ ここで api.ts の関数を呼ぶ
    const { response, threadId: newThreadId } = await sendChatMessage(
      content,         // 「こんにちは」
      threadId,        // 会話のID
    )

    // AIの返答をメッセージに追加
    const assistantMessage = { id: '...', role: 'assistant', content: response }
    const finalMessages = [...updatedMessagesWithUser, assistantMessage]
    setMessages(finalMessages)
    setThreadId(newThreadId)
  } catch (err) {
    setError(err.message)  // エラーがあれば表示
  } finally {
    setIsLoading(false)  // 送信完了
  }
}, [threadId, isLoading, messages])
```

### GAS経験者向け解説

```javascript
// GASでの似たような処理
function sendMessage(content) {
  // GASではこう書くところを...
  const response = UrlFetchApp.fetch(url, options);
  return response.getContentText();
}

// TypeScriptでは async/await を使う
async function sendMessage(content: string) {
  const response = await fetch(url, options);
  return await response.json();
}
```

---

## ステップ2: APIを呼び出す（トークン付き）

### なぜこのファイルがあるのか？

**問題**: サーバーにリクエストを送るとき、毎回「私は誰です」という証明が必要
**解決**: 認証トークンを自動で付ける処理を一箇所にまとめる

### 場所: `src/frontend/src/services/api.ts`

```typescript
// api.ts（簡略版）

// ★ チャットメッセージを送信する関数
export async function sendChatMessage(
  message: string,                      // 送りたいメッセージ
  threadId: string | null,              // 会話のID
  onChunk: (chunk: string) => void      // 返答を少しずつ受け取るコールバック
): Promise<string> {

  // 1. 認証トークンを取得して、ヘッダーに付ける
  const token = await auth.currentUser?.getIdToken()
  const headers = {
    'Authorization': `Bearer ${token}`,  // ← これが「私は〇〇です」の証明
  }

  // 2. サーバーにリクエストを送信
  const res = await fetch(`${API_URL}/chat`, {
    method: 'POST',
    headers,
    body: JSON.stringify({ message, thread_id: threadId }),
  })

  // 3. エラーチェック
  if (!res.ok) {
    const error = await res.json()
    throw new Error(error.error || 'エラーが発生しました')
  }

  // 4. JSONレスポンスを取得
  const data = await res.json()
  return {
    response: data.data.response,    // AIの返答
    threadId: data.data.thread_id,   // スレッドID
  }
}
```

### IDトークンとは？

<div class="info-box">
<h3>🎫 IDトークン</h3>
<p>「この人は本物の山田太郎さんです」という証明書</p>
<p><strong>中身:</strong></p>
<pre>
{
  "name": "山田太郎",      ← 名前
  "email": "yamada@...",  ← メールアドレス
  "uid": "abc123",        ← ユーザーID
  "exp": 1705471200       ← 有効期限（1時間）
}
</pre>
<ul>
<li>Googleが「この人は本物です」と署名している</li>
<li>改ざんすると署名が壊れるので、偽造できない</li>
</ul>
</div>

---

## ステップ3: Gatewayで認証・振り分け

### なぜGatewayがあるのか？

**役割**: すべてのリクエストの「入口」
- 認証チェック（トークン検証）
- customer_id から転送先URL取得
- 会社ごとのバックエンドに転送

### 場所: `src/gateway/src/main.py`

```python
# Gateway main.py（簡略版）

@app.route("/chat", methods=["POST"])
def chat():
    """チャットAPIをプロキシ"""

    # 1. 認証チェック
    uid, customer_id = verify_request()

    # 2. 転送先URLを取得（Firestoreから）
    target_url = get_company_url(customer_id)

    # 3. 内部ヘッダーを付けて転送
    return proxy_request(
        target_url,
        headers={
            "X-Gateway-Verified": "true",
            "X-User-Id": uid,
            "X-Customer-Id": customer_id,
        }
    )
```

### Gateway の役割を図解

<div class="flow-box">
<h3>🚦 Gateway の処理フロー</h3>
<pre>
リクエスト到着（Authorization: Bearer xxx）
    ↓
┌─────────────────────────────────────────┐
│              Gateway                     │
├─────────────────────────────────────────┤
│                                         │
│  ① verify_request()                    │
│     → Firebase Admin SDK でトークン検証  │
│     → customer_id を Custom Claims から取得│
│                                         │
│  ② get_company_url(customer_id)        │
│     → Firestore から転送先URL取得        │
│     → customers/{customer_id}/cloud_functions_url │
│                                         │
│  ③ proxy_request()                     │
│     → 内部ヘッダーを付けて転送           │
│                                         │
└─────────────────────────────────────────┘
    ↓
 会社ごとのバックエンドへ
</pre>
</div>

---

## ステップ4: 会社別バックエンドでリクエストを処理

### なぜ会社ごとにバックエンドがあるのか？

**メリット**:
- A社だけの特殊カスタマイズが可能
- 他社への影響ゼロで安全に更新
- 障害が他社に波及しない

### 場所: `src/backend/src/main.py`

```python
# Backend main.py（簡略版）

@app.route("/chat", methods=["POST"])
def chat():
    """チャットAPI（同期）"""

    # 1. 認証チェック（Gateway経由かどうかで分岐）
    user_info = authenticate_request_with_gateway(request)
    customer_id = user_info["customer_id"]

    # 2. レート制限チェック
    if not check_rate_limit(user_info["uid"]):
        return error_response("リクエスト制限を超えました", 429)

    # 3. メッセージを取得
    data = request.get_json()
    message = data.get("message")

    # 4. AIエージェントを呼び出し
    agent = get_agent("template", customer_id)

    # 5. AIを呼び出してJSON返却（タイムアウト付き）
    AI_TIMEOUT_SECONDS = 55  # Cloud Run の60秒制限対策
    loop = asyncio.new_event_loop()
    try:
        response_text = loop.run_until_complete(
            asyncio.wait_for(agent.run_sync(message, thread_id), timeout=AI_TIMEOUT_SECONDS)
        )
        # 後処理パイプライン（拡張ポイント）
        processed_response = post_process(response_text, customer_id)
    except asyncio.TimeoutError:
        return error_response("AI処理がタイムアウトしました", 504)
    finally:
        loop.close()

    return success_response({
        "response": processed_response,
        "thread_id": thread_id
    })
```

### Backend main.py の役割を図解

<div class="flow-box">
<h3>🚦 Backend main.py の処理フロー</h3>
<pre>
リクエスト到着（Gateway から内部ヘッダー付き）
    ↓
┌─────────────────────────────────────────┐
│              Backend main.py             │
├─────────────────────────────────────────┤
│                                         │
│  ① authenticate_request_with_gateway() │
│     → X-Gateway-Verified を確認          │
│     → true なら内部ヘッダーを信頼         │
│                                         │
│  ② check_rate_limit()                  │
│     → 使いすぎていないかチェック          │
│                                         │
│  ③ get_agent()                         │
│     → 適切なAIエージェントを取得          │
│                                         │
│  ④ agent.run_sync()                    │
│     → AIに質問（55秒タイムアウト付き）    │
│                                         │
│  ⑤ post_process()                      │
│     → 後処理パイプライン（拡張ポイント）   │
│                                         │
└─────────────────────────────────────────┘
    ↓
 JSON形式で返す
</pre>
</div>

---

## ステップ5: 認証処理（Gateway経由対応）

### なぜこのファイルがあるのか？

**問題**: 「認証」処理はいろんな場所で使いたい
- `/chat` エンドポイント
- `/agents` エンドポイント
- 将来の新しいエンドポイント

**解決**: 認証処理を別ファイルにまとめる + Gateway経由に対応

### 場所: `src/backend/src/common/auth.py`

```python
# auth.py（簡略版）

def authenticate_request_with_gateway(request) -> dict:
    """
    Gateway 経由のリクエストを認証

    【処理の流れ】
    1. X-Gateway-Verified ヘッダーを確認
    2. Gateway経由なら内部ヘッダーを信頼
    3. Gateway経由でなければ従来の認証
    """
    gateway_verified = request.headers.get("X-Gateway-Verified")

    if gateway_verified == "true":
        # Gateway が認証済みなので、内部ヘッダーを信頼
        user_id = request.headers.get("X-User-Id")
        customer_id = request.headers.get("X-Customer-Id")
        return {
            "uid": user_id,
            "customer_id": customer_id,
        }

    # Gateway 経由でない場合は従来の認証
    return authenticate_request(request)


def authenticate_request(request) -> dict:
    """
    リクエストを認証し、ユーザー情報を返す（従来の方式）

    【処理の流れ】
    1. ヘッダーからトークンを取り出す（形式を厳密に検証）
    2. トークンが本物か検証（失効チェック含む）
    3. このユーザーは許可されているか確認
    4. どの会社（顧客）に所属しているか取得
    """
    # 1. ヘッダーからトークンを取り出す（セキュリティ強化版）
    auth_header = request.headers.get("Authorization", "")
    if not auth_header:
        raise ValueError("認証トークンがありません")

    parts = auth_header.split(" ")
    if len(parts) != 2 or parts[0] != "Bearer":
        raise ValueError("認証ヘッダーの形式が不正です")

    id_token = parts[1]

    # 2. Firebase Admin SDK でトークンを検証
    # check_revoked=True: ログアウト済み/無効化されたトークンを拒否
    user_info = auth.verify_id_token(id_token, check_revoked=True)

    # 3. このユーザーは許可されているか
    if not is_user_allowed(user_info["email"]):
        raise ValueError("アクセスが許可されていません")

    # 4. 顧客IDを取得（マルチテナント用）
    user_info["customer_id"] = get_user_customer_id(user_info["uid"])

    return user_info
```

### 認証の流れ図

<div class="flow-box">
<h3>🔐 認証フロー（Gateway対応版）</h3>
<pre>
リクエスト到着
        ↓
┌───────────────────────────────┐
│ X-Gateway-Verified == "true"? │
└───────────┬───────────────────┘
            ↓
    ┌───────┴───────┐
    ↓               ↓
  true            false
    ↓               ↓
内部ヘッダー      従来の認証
を信頼           (トークン検証)
    ↓               ↓
    └───────┬───────┘
            ↓
      次の処理へ
</pre>
</div>

---

## ステップ6: AIエージェントが応答を生成

### なぜこのファイルがあるのか？

**問題**: 将来、違う種類のAIエージェントを追加したい
- カスタマーサポート用
- 社内FAQ用
- 翻訳用

**解決**: エージェントを「差し替え可能」な形で作る

### 場所: `src/backend/src/agents/_template/agent.py`

```python
# agent.py（簡略版）

class TemplateAgent(BaseAgent):
    """テンプレートQ&Aエージェント"""

    # ★ AIの「性格」を定義
    SYSTEM_PROMPT = """あなたは親切で丁寧なAIアシスタントです。
ユーザーの質問に対して、わかりやすく簡潔に回答してください。"""

    # ★ 使用するモデル（Gemini 1.5 Flash）
    MODEL_NAME = "gemini-1.5-flash"

    async def _chat_node(self, state):
        """
        チャット処理の本体

        【流れ】
        1. これまでの会話履歴を取得
        2. 「あなたは親切な...」というシステムプロンプトを先頭に追加
        3. Vertex AI (Gemini) に送信
        4. 応答を返す
        """
        messages = state["messages"]

        # システムプロンプトを追加
        full_messages = [
            {"role": "system", "content": self.SYSTEM_PROMPT},
            *messages
        ]

        # Vertex AI に問い合わせ
        response = await self.llm.ainvoke(full_messages)

        return {"messages": [response]}
```

### エージェントの仕組み

<div class="info-box">
<h3>🤖 TemplateAgent の処理</h3>
<p><strong>SYSTEM_PROMPT = "あなたは親切な..."</strong> ← AIの性格を決める</p>
<p><strong>_chat_node() の処理:</strong></p>
<pre>
[システムプロンプト]
[ユーザー: こんにちは]     ← これまでの会話
[AI: こんにちは！]
[ユーザー: 今日の天気は？]  ← 今回の質問
        ↓
    Gemini に送信
        ↓
[AI: 今日は晴れですね]     ← Geminiからの返答
</pre>
</div>

---

## ステップ7: 会話履歴をFirestoreに保存

### なぜこのファイルがあるのか？

**問題**:
- サーバーを再起動すると、会話履歴が消える
- 違う会社の会話が混ざると情報漏洩

**解決**:
- Firestoreに保存して永続化
- 会社（顧客）ごとにデータを分離

### 場所: `src/backend/src/agents/_base/firestore_checkpointer.py`

```python
# firestore_checkpointer.py（簡略版）

class FirestoreCheckpointer(BaseCheckpointSaver):
    """会話履歴をFirestoreに保存"""

    def __init__(self, db, customer_id: str):
        self.db = db
        self.customer_id = customer_id  # ★ どの会社のデータか

    def _get_checkpoint_ref(self, thread_id: str):
        """
        保存先のパスを生成

        例: customers/acme-corp/checkpoints/user123_abc/...
        """
        return (
            self.db.collection("customers")
            .document(self.customer_id)      # ← 会社ごとに分離
            .collection("checkpoints")
            .document(thread_id)
        )
```

### Firestoreのデータ構造

<div class="architecture-box">
<h3>🗄️ Firestore データ構造</h3>
<pre>
Firestore（データベース）
│
└── customers/                        ← 「顧客」コレクション
    │
    ├── acme-corp/                    ← 会社A のデータ
    │   └── checkpoints/
    │       ├── user1_abc123/         ← ユーザー1の会話
    │       └── user2_def456/         ← ユーザー2の会話
    │
    └── beta-inc/                     ← 会社B のデータ
        └── checkpoints/
            └── ...                   ← 会社Bの会話（会社Aからは見えない）
</pre>
<p><strong>【ポイント】</strong><br>
会社Aの人は会社Bのデータにアクセスできない → 情報漏洩を防止</p>
</div>

---

## まとめ：ファイルの繋がり

<div class="architecture-box">
<h3>📁 フロントエンド・Gateway・バックエンドの連携</h3>
<pre>
【ブラウザ側（フロントエンド）】

┌──────────────┐        ┌──────────────┐
│ useChat.ts   │ ─────→ │   api.ts     │
│              │        │              │
│ ・画面の状態管理│        │ ・サーバー通信  │
│ ・メッセージ一覧│        │ ・認証トークン付与│
└──────────────┘        └──────────────┘
                              │
                              ↓ HTTP リクエスト
════════════════════════ インターネット ════════════════════════
                              │
                              ↓

【Gateway（1つだけ）】

┌──────────────────────────────────────────┐
│           Gateway main.py                 │
│                                          │
│  ・Firebase トークン検証                   │
│  ・customer_id から転送先URL取得           │
│  ・内部ヘッダー付与して転送                 │
│    (X-Gateway-Verified, X-User-Id, etc.)  │
└──────────────────┬───────────────────────┘
                   │
                   ↓ 転送

【サーバー側（会社ごとのバックエンド）】

┌──────────────┐        ┌──────────────┐
│ Backend      │ ─────→ │   auth.py    │
│ main.py      │        │              │
│              │        │ ・Gateway連携  │
│ ・リクエスト受付│        │ ・内部ヘッダー信頼│
│ ・エージェント呼出│       │              │
└──────┬───────┘        └──────────────┘
       │
       ├─────────────→ ┌──────────────┐
       │               │  agent.py    │
       │               │              │
       │               │ ・AI処理      │
       │               │ ・応答生成    │
       │               └──────────────┘
       │
       └─────────────→ ┌──────────────┐
                       │checkpointer.py│
                       │              │
                       │ ・履歴保存    │
                       │ ・顧客分離    │
                       └──────────────┘
</pre>
</div>

---

## よくあるエラーと対処法

| エラーメッセージ | 原因 | 対処法 |
|-----------------|------|--------|
| `ログインが必要です` | 未ログイン状態でAPI呼び出し | ログインする |
| `認証トークンがありません` | Authorization ヘッダーがない | ログインし直す |
| `認証ヘッダーの形式が不正です` | Bearer形式でない | ログインし直す |
| `セッションが無効です` | ログアウト後のトークン使用 | 再ログインする |
| `セッションの有効期限が切れました` | トークンの有効期限切れ（1時間） | ページをリロード |
| `認証トークンが無効です` | 改ざんされたトークン | 再ログインする |
| `顧客に紐付けされていません` | ユーザーが会社に登録されていない | 管理者に連絡 |
| `リクエスト制限を超えました` | 短時間に送りすぎ | 1分待つ |
| `メッセージが長すぎます` | 10,000文字を超えた | メッセージを短くする |
| `thread_idの形式が不正です` | 不正なthread_id | thread_idを指定しない |
| `AI処理がタイムアウトしました` | AI処理が55秒超過 | シンプルな質問を試す |
| `CORSエラー` | フロントエンドのURLが許可されていない | ALLOWED_ORIGINS 確認 |
| `エラーが発生しました` | サーバー内部エラー | しばらく待って再試行 |

---

## 確認問題

### 理解度チェック

1. **送信ボタンを押してから、画面に文字が表示されるまでに、何個のファイルを通過する？**

   <details>
   <summary>答え</summary>
   7個（useChat.ts → api.ts → Gateway main.py → Backend main.py → auth.py → agent.py → checkpointer.py）
   </details>

2. **「Bearer」とは何？**

   <details>
   <summary>答え</summary>
   「トークンを持っている人」という意味。Authorization ヘッダーでトークンを送る標準的な形式。
   </details>

3. **Gatewayの役割は？**

   <details>
   <summary>答え</summary>
   認証（トークン検証）と振り分け（customer_idから転送先URL取得）。AI処理は行わない。
   </details>

4. **会社Aのユーザーが会社Bのデータを見れないのは、どのような仕組みのおかげ？**

   <details>
   <summary>答え</summary>
   複数の仕組みで保護：
   - Gatewayが正しい会社のバックエンドにのみ転送
   - checkpointer.pyがcustomer_idで保存先を分離
   - Firestoreセキュリティルールで自社データのみアクセス可能
   </details>

### 実践チャレンジ

ブラウザの開発者ツール（F12）を開いて、実際にチャットを送信し、
Network タブで以下を確認してみよう：

1. `/chat` へのリクエストに `Authorization: Bearer ...` が付いているか
2. レスポンスが `data: こん` のような形式で返ってきているか

---

## 次に読むべきドキュメント

- `12_ログインの流れ.md` - ログイン処理の詳細
- `05_セットアップの流れ.md` - 環境構築の手順
