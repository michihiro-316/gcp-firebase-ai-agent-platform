# バックエンド解説 - サーバーの中身を完全理解！

<div class="goal-box">
<div class="box-title">🎯 このページのゴール</div>
<div class="box-content">

「サーバー側のコードを見て、何をしてるかわかる！」状態になる

🔥 ゴール達成後のあなた:
「このAPI、認証 → レート制限 → AI呼び出しの順で処理してるね」
と言えるようになる！

</div>
</div>

---

## バックエンドって何してるの？

<div class="info-box">
<div class="box-title">🐍 バックエンドの仕事</div>
<div class="box-content">

「見えないところで頑張る縁の下の力持ち」

<ul>
<li>この人は本物？ → 認証</li>
<li>この人はアクセスしていい？ → 許可確認</li>
<li>使いすぎてない？ → レート制限</li>
<li>AIに聞いて答えを返す → AI呼び出し</li>
<li>会話を覚えておく → 履歴保存</li>
</ul>

💡 GASで言うと: doGet() や doPost() の中身を作るイメージ

</div>
</div>

---

## ファイル構成

```
backend/src/
├── main.py              ★ すべての入口（最初に読む）
├── common/
│   ├── auth.py          ★ 認証処理（2番目に読む）
│   ├── config.py           設定読み込み
│   ├── firebase_init.py    Firebase初期化
│   └── rate_limiter.py     レート制限
└── agents/
    ├── _base/
    │   ├── base_agent.py        エージェントの基底クラス
    │   └── firestore_checkpointer.py  会話履歴保存
    └── _template/
        └── agent.py     ★ AIエージェント本体（3番目に読む）

backend/scripts/
└── manage_customer.py   ★ 顧客管理コマンド（運用時に必須）
```

---

## 1. main.py - すべての入口

### なぜ「入口」が必要？

<div class="info-box">
<div class="box-title">🚪 main.py = ホテルのフロントデスク</div>
<div class="box-content">

<strong>【フロントデスクの仕事】</strong>

お客さん:「チェックインしたいんですけど」
↓
フロント:「かしこまりました。お名前は？予約番号は？」
↓
フロント:「確認できました。こちらがお部屋の鍵です」

<strong>【main.py の仕事】</strong>

リクエスト:「/chat に POST したいんですけど」
↓
main.py:「かしこまりました。トークンは？メッセージは？」
↓
main.py:「確認できました。こちらがAIの回答です」

</div>
</div>

### エンドポイント一覧

<div class="info-box">
<div class="box-title">📡 用意されているエンドポイント</div>
<div class="box-content">

<table>
<tr><th>エンドポイント</th><th>メソッド</th><th>役割</th></tr>
<tr><td>/health</td><td>GET</td><td>生存確認（サーバー動いてる？）</td></tr>
<tr><td>/chat</td><td>POST</td><td>チャットAPI（メイン機能）</td></tr>
<tr><td>/agents</td><td>GET</td><td>使えるAIエージェント一覧</td></tr>
</table>

💡 エンドポイントとは:
「このURLにこのメソッドでリクエストすると、この処理が実行されますよ」という窓口のこと

</div>
</div>

### /chat エンドポイントの全処理フロー

<div class="flow-box">
<div class="box-title">💬 /chat の処理フロー（完全版）</div>
<div class="box-content">

<strong>POST /chat</strong> → `{ "message": "こんにちは", "thread_id": "abc123" }`

<strong>ステップ1: 認証チェック</strong>
<ul>
<li>トークンがない → エラー「認証トークンがありません」</li>
<li>トークンが偽物 → エラー「認証トークンが無効です」</li>
<li>許可されてない → エラー「アクセスが許可されていません」</li>
<li>OK → user_info を取得（uid, email, customer_id）</li>
</ul>

<strong>ステップ2: レート制限チェック</strong>
<ul>
<li>1分60回超過 → エラー「リクエスト制限を超えました」</li>
<li>OK → 処理続行</li>
</ul>

💡 なぜレート制限？ 悪意のあるユーザーがAPIを大量に叩いてサーバーをダウンさせることを防ぐ。AI呼び出しはお金がかかるので課金攻撃も防ぐ

<strong>ステップ3: 入力値検証</strong>
<ul>
<li>メッセージが空？ → エラー</li>
<li>メッセージが10,000文字超？ → エラー（DoS対策）</li>
<li>thread_idに変な文字？ → エラー（インジェクション対策）</li>
</ul>

<strong>ステップ4: AIエージェント取得</strong>
<ul>
<li>顧客IDに紐づいたエージェントを取得</li>
</ul>

<strong>ステップ5: AIを呼び出してストリーミング返却</strong>
<ul>
<li>Server-Sent Events (SSE) 形式で返す</li>
<li>`data: 内容` の形で送ると、ブラウザが自動で受け取る</li>
<li>`[DONE]` は「もう終わりだよ」の合図</li>
</ul>

</div>
</div>

### コード（実際の構造に近い形）

```python
# main.py の構造（簡略化したもの）

from flask import Flask, request, Response
from common.auth import authenticate_request
from common.rate_limiter import check_rate_limit

app = Flask(__name__)

# ========================================
# ヘルスチェック: サーバーが生きてるか確認
# ========================================
@app.route("/health", methods=["GET"])
def health():
    """サーバー生存確認"""
    return {"status": "healthy"}


# ========================================
# チャットAPI: メインの機能
# ========================================
@app.route("/chat", methods=["POST"])
def chat():
    """チャットAPI（ストリーミング対応）"""

    # === ステップ1: 認証チェック ===
    try:
        user_info = authenticate_request(request)
    except ValueError as e:
        return {"error": str(e)}, 401  # 401 = 認証エラー

    user_id = user_info["uid"]
    customer_id = user_info["customer_id"]

    # === ステップ2: レート制限チェック ===
    if not check_rate_limit(user_id):
        return {"error": "リクエスト制限を超えました。1分後に再試行してください。"}, 429

    # === ステップ3: 入力値検証 ===
    data = request.get_json()
    message = data.get("message", "")
    thread_id = data.get("thread_id")

    # メッセージが空
    if not message.strip():
        return {"error": "メッセージが空です"}, 400

    # メッセージが長すぎる（DoS対策）
    if len(message) > 10000:
        return {"error": "メッセージが長すぎます（10,000文字まで）"}, 400

    # thread_idの形式チェック（インジェクション対策）
    if thread_id and not is_valid_thread_id(thread_id):
        return {"error": "thread_idの形式が不正です"}, 400

    # === ステップ4: AIエージェント取得 ===
    agent = get_agent("template", customer_id)

    # === ステップ5: ストリーミングで返す ===
    def generate():
        """AIの回答を少しずつ返すジェネレーター"""
        try:
            for chunk in agent.run(message, thread_id, user_id):
                # Server-Sent Events 形式で返す
                yield f"data: {chunk}\n\n"
            yield "data: [DONE]\n\n"
        except Exception as e:
            yield f"data: エラーが発生しました: {str(e)}\n\n"
            yield "data: [DONE]\n\n"

    return Response(
        generate(),
        mimetype="text/event-stream",  # これがSSEの印
        headers={
            "Cache-Control": "no-cache",     # キャッシュしない
            "X-Accel-Buffering": "no"        # Nginx用のバッファリング無効化
        }
    )


def is_valid_thread_id(thread_id: str) -> bool:
    """thread_idの形式を検証（英数字、ハイフン、アンダースコアのみ）"""
    import re
    return bool(re.match(r'^[a-zA-Z0-9_-]+$', thread_id))
```

---

## 2. auth.py - 認証処理（超重要！）

### なぜ認証が必要？

<div class="warning-box">
<div class="box-title">🔐 認証がないと何が起きる？</div>
<div class="box-content">

<strong>【認証なしの場合】</strong>

悪い人:「俺は山田だ！データ見せろ！」
サーバー:「はい、どうぞ」

→ 情報漏洩！セキュリティ事故！新聞沙汰！😱

<strong>【認証ありの場合】</strong>

悪い人:「俺は山田だ！データ見せろ！」
サーバー:「身分証見せて」
悪い人:「...持ってない」
サーバー:「じゃあダメ」

→ 安全！😊

</div>
</div>

### 認証の4つの関門（詳細版）

<div class="flow-box">
<div class="box-title">🚨 認証の4つの関門</div>
<div class="box-content">

<strong>リクエスト到着</strong> → Headers: `{ "Authorization": "Bearer eyJhbGciOiJSUzI1NiIsInR5cCI6..." }`

<strong>関門1: トークンがあるか？</strong>
<ul>
<li>`auth_header = request.headers.get("Authorization")`</li>
<li>ない → エラー「認証トークンがありません」</li>
<li>"Bearer "で始まらない → エラー「認証ヘッダーの形式が不正です」</li>
<li>💡 "Bearer" = 「持ち主」の意味。「このトークンを持ってる人に権限を与える」形式</li>
</ul>

<strong>関門2: トークンは本物か？</strong>
<ul>
<li>Firebase Admin SDK で検証</li>
<li>署名をGoogleの公開鍵で検証</li>
<li>有効期限が切れていないか確認（1時間）</li>
<li>トークンの発行者がFirebaseか確認</li>
<li>check_revoked=True なら失効リストも確認</li>
</ul>

<strong>関門3: このユーザーは許可されているか？</strong>
<ul>
<li>Firestoreの config/access_control を確認</li>
<li>許可ドメインリスト (@acme.co.jp など)</li>
<li>許可メールリスト (tanaka@gmail.com など)</li>
<li>どちらかにマッチすればOK</li>
</ul>

<strong>関門4: どの会社に所属しているか？</strong>
<ul>
<li>まずCustom Claimsに customer_id があるか確認 → あればそれを返す</li>
<li>なければ自動振り分けを試行 → メールドメインから顧客を検索</li>
<li>見つかったら自動でCustom Claimsを設定</li>
<li>どちらにも該当しなければエラー → 「顧客に紐付けされていません」</li>
<li>💡 Custom Claims = IDトークンに追加できる属性。サーバーでしか設定できない（改ざん不可能）</li>
</ul>

<strong>✅ 認証成功！</strong> `{ "uid": "abc123", "email": "yamada@acme.co.jp", "name": "山田太郎", "customer_id": "acme-corp" }`

</div>
</div>

### コード（実際の構造に近い形）

```python
# auth.py の主要な関数

from firebase_admin import auth
from common.firebase_init import get_firestore_client

db = get_firestore_client()


def authenticate_request(request) -> dict:
    """
    リクエストを認証し、ユーザー情報を返す

    Returns:
        dict: {uid, email, name, customer_id, ...}

    Raises:
        ValueError: 認証に失敗した場合
    """

    # === 関門1: トークンがあるか？ ===
    auth_header = request.headers.get("Authorization", "")

    if not auth_header:
        raise ValueError("認証トークンがありません")

    # "Bearer " で始まっているか？
    # セキュリティ上、形式を厳密にチェック
    parts = auth_header.split(" ")
    if len(parts) != 2 or parts[0] != "Bearer":
        raise ValueError("認証ヘッダーの形式が不正です")

    id_token = parts[1]

    # === 関門2: トークンは本物か？ ===
    try:
        # Firebase Admin SDK でトークンを検証
        # check_revoked=True: ログアウト後のトークン使用を防ぐ
        user_info = auth.verify_id_token(id_token, check_revoked=True)

    except auth.RevokedIdTokenError:
        # トークンが失効済み（ログアウト後など）
        raise ValueError("セッションが無効です。再度ログインしてください。")

    except auth.ExpiredIdTokenError:
        # トークンの有効期限切れ（1時間）
        raise ValueError("セッションの有効期限が切れました。再度ログインしてください。")

    except auth.InvalidIdTokenError:
        # トークンが不正（改ざん、形式エラーなど）
        raise ValueError("認証トークンが無効です")

    # === 関門3: このユーザーは許可されているか？ ===
    email = user_info.get("email", "")

    if not is_user_allowed(email):
        raise ValueError(f"アクセスが許可されていません: {email}")

    # === 関門4: 顧客IDを取得 ===
    uid = user_info["uid"]
    customer_id = get_user_customer_id(uid, email)
    user_info["customer_id"] = customer_id

    return user_info


def is_user_allowed(email: str) -> bool:
    """
    このメールアドレスはアクセス許可されているか？

    Firestoreの config/access_control ドキュメントを確認
    """
    if not email:
        return False

    # Firestore から許可リストを取得
    doc_ref = db.collection("config").document("access_control")
    doc = doc_ref.get()

    if not doc.exists:
        # 設定がない場合はデフォルトで拒否（セキュリティ優先）
        return False

    data = doc.to_dict()
    allowed_emails = data.get("allowed_emails", [])
    allowed_domains = data.get("allowed_domains", [])

    # メールが直接許可されている？
    if email in allowed_emails:
        return True

    # ドメインが許可されている？
    domain = email.split("@")[1] if "@" in email else ""
    if domain in allowed_domains:
        return True

    return False


def get_user_customer_id(uid: str, email: str = None) -> str:
    """
    ユーザーの顧客IDを取得（自動振り分け対応）

    1. Custom Claims に customer_id があればそれを返す
    2. なければメールドメインから自動検索・設定
    """

    # Firebase Auth からユーザー情報を取得
    user = auth.get_user(uid)
    claims = user.custom_claims or {}

    # 既に customer_id がある場合
    if claims.get("customer_id"):
        return claims["customer_id"]

    # 自動振り分けを試行
    if email:
        customer_id = auto_assign_customer(uid, email)
        if customer_id:
            return customer_id

    # どちらにも該当しない
    raise ValueError("顧客に紐付けされていません。管理者に連絡してください。")


def auto_assign_customer(uid: str, email: str) -> str | None:
    """
    メールアドレスから顧客を自動検索し、紐付ける

    Returns:
        str | None: 紐付けに成功した場合は customer_id、失敗した場合は None
    """
    domain = email.split("@")[1] if "@" in email else ""

    # 顧客を検索
    customers_ref = db.collection("customers")

    # 1. メールアドレスで直接検索
    query = customers_ref.where("allowed_emails", "array_contains", email)
    docs = list(query.stream())
    if docs:
        customer_id = docs[0].id
        _set_customer_id_claim(uid, customer_id)
        return customer_id

    # 2. ドメインで検索
    query = customers_ref.where("allowed_domains", "array_contains", domain)
    docs = list(query.stream())
    if docs:
        customer_id = docs[0].id
        _set_customer_id_claim(uid, customer_id)
        return customer_id

    return None


def _set_customer_id_claim(uid: str, customer_id: str):
    """Custom Claims に customer_id を設定"""
    auth.set_custom_user_claims(uid, {"customer_id": customer_id})
```

---

## 3. agent.py - AIエージェント

### AIエージェントって何？

<div class="info-box">
<div class="box-title">🤖 AIエージェント = AIを使いやすくするラッパー</div>
<div class="box-content">

<strong>【AIを直接使う場合】</strong>

毎回これを書く必要がある:
<ul>
<li>システムプロンプトを設定</li>
<li>会話履歴を取得</li>
<li>AIに送信</li>
<li>結果を保存</li>
</ul>
...面倒！😵

<strong>【エージェントを使う場合】</strong>

`agent.run("質問", thread_id)`
↑
これだけ！中身は全部エージェントがやってくれる 😊

</div>
</div>

### エージェントの構造

<div class="architecture-box">
<div class="box-title">🏗️ エージェントの構造</div>
<div class="box-content">

```
TemplateAgent（実際に使うやつ）
    ↓ 継承
BaseAgent（共通機能を持つ）
  - LLM初期化
  - グラフ構築
  - run() メソッド
    ↓ 使用
FirestoreCheckpointer（会話履歴を保存）
```

💡 なぜこんな構造？ 共通処理は BaseAgent に、個別の性格は TemplateAgent にすると、新しいエージェントを追加するのが楽！

</div>
</div>

### SYSTEM_PROMPT - AIの「性格」

<div class="tip-box">
<div class="box-title">🎭 SYSTEM_PROMPT でAIの性格を決める</div>
<div class="box-content">

<strong>【デフォルト】</strong>
```
あなたは親切で丁寧なAIアシスタントです。
ユーザーの質問に対して、わかりやすく簡潔に回答してください。
日本語で回答してください。
```

<strong>【関西弁に変えると...】</strong>
```
あなたは関西弁で話すAIアシスタントやで。
ユーザーの質問にフレンドリーに答えてな。
「やで」「やん」「なんでやねん」を使ってな。
```

→ 同じ質問でも、返答のスタイルが変わる！

</div>
</div>

### コード（実際の構造に近い形）

```python
# agent.py の主要部分

from langchain_google_vertexai import ChatVertexAI
from langgraph.graph import StateGraph, MessagesState

# =============================================
# ★ ここを編集してAIをカスタマイズ
# =============================================

# AIの性格・役割
SYSTEM_PROMPT = """あなたは親切で丁寧なAIアシスタントです。
ユーザーの質問に対して、わかりやすく簡潔に回答してください。
日本語で回答してください。"""

# 使用するモデル
MODEL_NAME = "gemini-1.5-flash"

# 会話履歴の最大数（多いほどコストがかかる）
MAX_HISTORY_MESSAGES = 20  # 約10往復分


class TemplateAgent(BaseAgent):
    """テンプレートQ&Aエージェント"""

    def __init__(self, customer_id: str, user_id: str):
        """
        Args:
            customer_id: 顧客ID（データ分離用）
            user_id: ユーザーID（会話履歴管理用）
        """
        self.customer_id = customer_id
        self.user_id = user_id

        # LLM（Large Language Model）を初期化
        self.llm = ChatVertexAI(
            model=MODEL_NAME,
            temperature=0.7,  # 0=確実な回答、1=創造的な回答
            max_output_tokens=2048,
            streaming=True,  # ストリーミング有効
        )

        # 会話履歴保存用のチェックポインター
        self.checkpointer = FirestoreCheckpointer(
            db=get_firestore_client(),
            customer_id=customer_id
        )

        # グラフを構築
        self.graph = self._build_graph()

    def _build_graph(self):
        """
        LangGraphのグラフを構築

        LangGraph = AIの処理フローを「グラフ」として定義するライブラリ
        """
        # グラフを作成
        builder = StateGraph(MessagesState)

        # ノードを追加（処理のステップ）
        builder.add_node("chat", self._chat_node)

        # エントリーポイントを設定
        builder.set_entry_point("chat")

        # 終了ノードを設定
        builder.set_finish_point("chat")

        # コンパイルしてグラフを確定
        return builder.compile(checkpointer=self.checkpointer)

    async def _chat_node(self, state: MessagesState) -> dict:
        """
        チャット処理のメインロジック

        Args:
            state: 現在の会話状態（メッセージ履歴を含む）

        Returns:
            dict: 新しいメッセージを含む状態
        """
        messages = state["messages"]

        # システムプロンプトを先頭に追加
        full_messages = [
            {"role": "system", "content": SYSTEM_PROMPT},
            *messages[-MAX_HISTORY_MESSAGES:]  # 履歴を制限
        ]

        # Gemini に問い合わせ
        response = await self.llm.ainvoke(full_messages)

        return {"messages": [response]}

    def run(self, message: str, thread_id: str = None, user_id: str = None):
        """
        チャットを実行（ストリーミング）

        Args:
            message: ユーザーのメッセージ
            thread_id: 会話のID（新規の場合は自動生成）
            user_id: ユーザーID

        Yields:
            str: AIの返答（少しずつ）
        """
        # thread_id がなければ生成
        if not thread_id:
            thread_id = f"{user_id}_{uuid.uuid4().hex[:8]}"

        # 設定
        config = {
            "configurable": {
                "thread_id": thread_id,
            }
        }

        # 入力
        input_data = {
            "messages": [
                {"role": "user", "content": message}
            ]
        }

        # ストリーミング実行
        for event in self.graph.stream(input_data, config, stream_mode="values"):
            # 最後のメッセージを取得
            if event.get("messages"):
                last_message = event["messages"][-1]
                if hasattr(last_message, "content"):
                    yield last_message.content
```

---

## 4. firestore_checkpointer.py - 会話履歴保存

### なぜ会話履歴が必要？

<div class="info-box">
<div class="box-title">💾 会話履歴がないと...</div>
<div class="box-content">

<strong>【履歴なし】</strong>

ユーザー: 「私の名前は山田です」
AI: 「山田さん、こんにちは！」

ユーザー: 「私の名前は何でしたか？」
AI: 「すみません、わかりません」 ← 忘れてる！😱

<strong>【履歴あり】</strong>

ユーザー: 「私の名前は山田です」
AI: 「山田さん、こんにちは！」

ユーザー: 「私の名前は何でしたか？」
AI: 「山田さんですね！」 ← 覚えてる！😊

</div>
</div>

### Firestore のデータ構造

<div class="architecture-box">
<div class="box-title">📁 Firestore のデータ構造</div>
<div class="box-content">

```
Firestore
└── customers/                    ← 顧客コレクション
    ├── acme-corp/                ← 顧客ドキュメント
    │   ├── name: "株式会社ACME"
    │   ├── allowed_domains: ["acme.co.jp"]
    │   └── checkpoints/          ← 会話履歴コレクション
    │       ├── user1_abc123/     ← 会話1のドキュメント
    │       │   └── checkpoints/  ← チェックポイントサブコレクション
    │       │       ├── cp_1: {messages: [...], timestamp: ...}
    │       │       └── cp_2: {...}
    │       └── user1_def456/     ← 会話2のドキュメント
    │           └── ...
    └── beta-inc/                 ← 別の顧客
        └── ...
```

💡 customer_id でパスを分けることで、A社がB社のデータにアクセスすることを防ぐ

</div>
</div>

---

## 重要な概念

### async/await（非同期処理）

<div class="info-box">
<div class="box-title">⚡ async/await を完全理解</div>
<div class="box-content">

<strong>【GASの場合（同期処理）】</strong>
```javascript
function fetchData() {
  var response = UrlFetchApp.fetch(url);  // ここで止まる
  var data = response.getContentText();   // 終わるまで待つ
  return data;
}
```
→ 処理Aを待っている間、処理Bができない

<strong>【Python/TypeScriptの場合（非同期処理）】</strong>
```python
async def fetch_data():
    response = await aiohttp.get(url)  # 待つけど他の処理可
    data = await response.text()
    return data
```
→ 処理Aを待っている間に、処理Bを進められる

<strong>【イメージ】</strong>
<ul>
<li>同期 : 料理の注文 → 待つ → 受け取り → 次の注文</li>
<li>非同期 : 料理の注文 → 次の注文 → 次の注文 → 最初の料理受け取り</li>
</ul>

💡 AIの回答を待つ間、他のユーザーのリクエストを処理できる

</div>
</div>

### ジェネレーター（yield）

<div class="info-box">
<div class="box-title">🌊 yield（ジェネレーター）を完全理解</div>
<div class="box-content">

<strong>【普通の関数】</strong>
```python
def get_numbers():
    return [1, 2, 3, 4, 5]  # 全部まとめて返す

result = get_numbers()  # [1, 2, 3, 4, 5] が一度に来る
```

<strong>【ジェネレーター（yield使用）】</strong>
```python
def get_numbers():
    yield 1  # 1を返して、ここで一時停止
    yield 2  # 次に呼ばれたら2を返して、また一時停止
    yield 3
    yield 4
    yield 5

for num in get_numbers():
    print(num)  # 1, 2, 3, 4, 5 が順番に来る
```

<strong>【ストリーミングでの活用】</strong>
```python
def stream_response():
    yield "こん"    # ブラウザに「こん」が表示
    yield "にち"    # ブラウザに「にち」が追加表示
    yield "は"      # ブラウザに「は」が追加表示
```
→ 全部できるのを待たずに、できた分から表示！

</div>
</div>

### デコレーター（@）

<div class="info-box">
<div class="box-title">🎀 デコレーターを完全理解</div>
<div class="box-content">

<strong>【デコレーターって何？】</strong>
関数に「追加機能」をつける仕組み。`@something` を関数の前に書く

<strong>【よく見るパターン】</strong>
```python
@app.route("/chat", methods=["POST"])
def chat():
    ...
```

↑ これは以下と同じ意味:
```python
def chat():
    ...
chat = app.route("/chat", methods=["POST"])(chat)
```

<strong>【イメージ】</strong>
プレゼントに リボン をつける
   ↑           ↑
 関数     デコレーター

中身（関数）は同じだけど、見た目（機能）が変わる

`@app.route(...)` → 「この関数をURLに紐づける」機能を追加

</div>
</div>

---

## よくあるエラーと対処法

| エラー | 原因 | 対処 |
|--------|------|------|
| `認証トークンがありません` | Authorizationヘッダーがない | ログインし直す |
| `認証ヘッダーの形式が不正です` | Bearer形式でない | ログインし直す |
| `セッションが無効です` | ログアウト後のトークン使用 | 再ログイン |
| `セッションの有効期限が切れました` | トークンが1時間超過 | ページリロード |
| `認証トークンが無効です` | 改ざんされたトークン | 再ログイン |
| `アクセスが許可されていません` | 許可リストにない | 管理者に連絡 |
| `顧客に紐付けされていません` | 自動振り分けにもマッチしない | 管理者に連絡 |
| `リクエスト制限を超えました` | 1分60回超過 | 1分待つ |
| `メッセージが長すぎます` | 10,000文字超過 | 短くする |
| `thread_idの形式が不正です` | 変な文字が入っている | thread_idを指定しない |

---

## 理解度チェック

以下の質問に答えられたら、バックエンドはバッチリ！

| 質問 | 自信あり? |
|------|----------|
| main.py の /chat はどんな順番で処理を行う？ | □ |
| 認証で「4つの関門」とは何？ | □ |
| SYSTEM_PROMPT を変えるとどうなる？ | □ |
| yield と return の違いは？ | □ |
| なぜ customer_id でデータを分けている？ | □ |

---

## 次のステップ

<div class="summary-box">
<div class="box-title">✅ バックエンドの仕組みが完全にわかった！</div>
<div class="box-content">

<strong>→ 次は 04_フロントエンド解説.md で画面側を学ぼう！</strong>

💡 バックエンドがわかると、フロントエンドも理解しやすくなる！

</div>
</div>
